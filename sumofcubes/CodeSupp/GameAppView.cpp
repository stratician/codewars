 
// GameAppView.cpp : implementation of the CGameAppView class
//
//
//#define MDEBUG
//#include "vld.h"
// wont work 
// or will it
#include <time.h>
#include <stdlib.h>
// a change 1234

#include "Build.h"
#include "stdafx.h"
#include "GameApp.h"
#include "MainFrm.h"
#include "GameAppDoc.h"
#include "GameAppView.h" // ????
#include "../Code/lobby.h"

#include "../Code/LobbyStat.h"

#include "../Code/Effects.h"
#include "../Code/SnookerAI.h"

#include "HTTPSocket.h"
#include "HTTPSocketEx.h"

#include "../Code/db.h"

#include <nb30.h>
#include <winsock.h>
#include <iostream>

#include <windows.h>
#include <wincon.h>

#include <winreg.h>
#include <string>

#include <ctime>

// main


#include <snmp.h>
#include "../Codedx9/cube.h"
#include "../Codedx9/d3dUtility.h"
#include "../Codedx9/detect.h"
//#include "../Codedx9/font.h"
#include <vector>
#include <direct.h>

//#include "stdafx.h"
//#include <Windows.h>
#include <lm.h>
#include <assert.h>
#include <Iphlpapi.h>
#include "MacFinderDlg.h"
#include "ImageDataObject.h"
#include <Richole.h>

// .. from now on close visual studio before switching branch
// I think it's working again...

//#include <iphlpapi.h>
//#include <conio.h>
//#include <stdio.h>

char *g_RecentMessengerName = NULL;

int g_iDesktopWidth;
int g_iDesktopHeight;
int g_iMaxWidthWS;
int g_iMaxHeightWS;



// Skin Images //
HBITMAP Skin_ButtonSayOn;
HBITMAP Skin_ButtonSayOff;
HBITMAP Skin_ButtonSmiley;
HBITMAP Skin_ButtonSmiley2;

HBITMAP Skin_ButtonG[9];	// Start, Undo, Rerack, Invite, Boot, Exit, Setup, Stand


// Lobby Buttons //
HBITMAP Skin_ButtonExitLobby;
HBITMAP Skin_ButtonChangeLobby;
HBITMAP Skin_ButtonMBFullLobby;
HBITMAP Skin_ButtonRefresh;
HBITMAP Skin_ButtonMsgBoardTabOn[4];
HBITMAP Skin_ButtonMsgBoardTabOff[4];
HBITMAP Skin_ButtonViewTables[2];

// Player List BackGround //
HBITMAP g_playerlistbgbmp = NULL;

// SendEdit and ChatEdit Corners //
// Semi Pro and Pro High break BackGrounds

#define SKIN_RANKS					3
#define SEMIPROHIGHBREAKSBG_LEFT	4
#define PROHIGHBREAKSBG_LEFT		5
#define SKIN_TABLEBUTTONS			6


#define SKIN_CHATEDITLEFTT			10
#define SKIN_CHATEDITLEFTM			11
#define SKIN_CHATEDITLEFTB			12
#define SKIN_CHATEDITRIGHTT			13
#define SKIN_CHATEDITRIGHTM			14
#define SKIN_CHATEDITRIGHTB			15
#define SKIN_CHATEDITTOP1			16
#define SKIN_CHATEDITMID1			17
#define SKIN_CHATEDITMID2			18
#define SKIN_CHATEDITMID3			19
#define SKIN_CHATEDITMID4			20
#define SKIN_CHATEDITBOT1			21
#define SKIN_CHATEDITRIGHTM1		22
#define SKIN_CHATEDITRIGHTM2		23
#define SKIN_CHATEDITRIGHTM3		24
#define SKIN_CHATBACKGROUND1		25

#define SKIN_LOBBYCHATEDITLEFTT		32
#define SKIN_LOBBYCHATEDITLEFTM		33
#define SKIN_LOBBYCHATEDITLEFTB		34
#define SKIN_LOBBYCHATEDITRIGHTT	35

#define SKIN_LOBBYCHATTOP1			36
#define SKIN_LOBBYCHATMID1			37

#define SKIN_LOBBYCHATMIDL2			38
#define SKIN_LOBBYCHATMIDL3			39
#define SKIN_LOBBYCHATMIDL4			40

#define SKIN_LOBBYCHATBOT1			41

#define SKIN_LOBBYCHATRIGHTM0		42
#define SKIN_LOBBYCHATRIGHTM1		43
#define SKIN_LOBBYCHATRIGHTM2		44
#define SKIN_LOBBYCHATRIGHTM3		45


#define SKIN_LOBBYPLAYERLISTTOPLB	46
#define SKIN_LOBBYPLAYERLISTTOPL	47
#define SKIN_LOBBYPLAYERLISTTOPM	48
#define SKIN_LOBBYPLAYERLISTTOPR	49

#define SKIN_VIEWTABLESBTN			50


#define SKIN_LOBBYCHATMIDR2			51
#define SKIN_LOBBYCHATMIDR3			52
#define SKIN_LOBBYCHATMIDR4			53


AbuseLstSendData g_AbuseLstData;


//CBitmapEx BitmapSkinEx[52];



BOOL g_Draw = FALSE;
	
BOOL g_UserMouseClick = FALSE;
BOOL g_WideScreenEnabled = FALSE;
BOOL g_RememberPassword = FALSE;
BOOL g_WindowsVista = FALSE;

BOOL g_ButtonUndoActive = TRUE;
BOOL g_ButtonRefreshActive = TRUE;
BOOL g_DrawLobbyTVUpdate = TRUE;
BOOL g_Menu_Refresh = FALSE;

BOOL g_bLobbyTBReady = FALSE;

//------------------------------------------------------------------------------
// GLOBALS
//------------------------------------------------------------------------------
HWND				g_hWnd        = NULL;
ID3DXFont*			g_pFont = NULL;

D3DLIGHT9			g_pLight0;
IDirect3DSurface9* m_pBGSurf = NULL;
IDirect3DSurface9* pRenderSurface = NULL;
IDirect3DSurface9* pRenderSurfaceMiniCam = NULL;
IDirect3DSurface9* pRenderSurfaceShop = NULL;

// 3D Scene1
ID3DXMesh*						XMesh_SFrame = 0;
std::vector<D3DMATERIAL9>		XMesh_SFrameMtrls(0);
std::vector<IDirect3DTexture9*>	XMesh_SFrameTextures(0);


//D3DXVECTOR3 TeapotPosition(0.0f, 0.0f, 300.0f);

DWORD g_dwFrameCnt;			// The number of frames that have occured
float g_fTimeElapsed;		// The time that has elapsed so far
float g_fFPS;				// The Frames rendered per second

DWORD g_dwBackBufferWidth  = 0;
DWORD g_dwBackBufferHeight = 0;

DWORD g_dwMainViewWidth = 0;
DWORD g_dwMainViewHeight = 0;

float g_fSpinX = 0.0f;
float g_fSpinY = 0.0f;

DWORD g_dwChatHeight = 240;
float g_fProbe = 0.0f;

int g_iCanHandleIt = 0;

//D3DVIEWPORT9 vp_main = {0, 0, ; 
//D3DVIEWPORT9 vp_minicam;

Camera*				g_pCamera = 0;
Camera*				g_pCameraMiniCam = 0;
Camera*				g_pCameraFree = 0;




int g_pCameraMode = 0;
bool g_bCameraModeJustChanged = false;

#define MAX_ADVERTS		64
Advert **g_pAdvert;

ID3DXMesh* Sphere = 0;

//ID3DXMesh*                      Mesh = 0;
//std::vector<D3DMATERIAL9>       Mtrls(0);
//std::vector<IDirect3DTexture9*> Textures(0);




d3d::BoundingSphere BSphere;



DWORD FrameCnt;
float TimeElapsed;
float FPS = 0.0f;


HBITMAP smiley_empty;

HBITMAP smiley[MAX_SMILIES+1];		// Last one if the curse smiley 
//IRichEditOle	*m_pRichEditOle;


char *smiley_lst[33] = {":)",		// Smile
						";)",		// Wink
						":d",		// Laugh
						":(",		// Sad
						":o",		// Shock
						":x",		// Slap
						":<",		// Mad	
						":p",		// Tongue	
						":s",		// Puzzled	
						":+",		// Cool	
						":b",		// Blush
						":a",		// Surprise
						":'(",		// Cry		
						":#",		// Biggrin	
						":m",		// Mischeif	
						";o",		// Mouth	
						":g",		// Girl		
						"):",		// Devil	
						"<g>",		// Pleased	
						":*",		// Santa	
						":i",		// Innocent		(dddd)
						":(",		// Sad			(sad.bmp)
						":*",		// Santa		(santa.bmp)
						":z",		// Sleep		(sleep.bmp)
						":!",		// Sly			(sly.bmp)
						":]]",		// Smile		(smile.bmp)
						":p",		// Tongue		(tongue.bmp)
						":s",		// UnSure		(unsure.bmp)
						":w",		// Whistle		(whistle.bmp)
						";)",		// Wink			(wink.bmp)
						";]",		// Woot			(woot.bmp)
						":h",		// Wub			(wub.bmp)
						NULL};		
						


smiley_data_typ smiley_data;

char *gstr;
void LOAD_SKIN(void);
void LOAD_SMILEYS(void);
void LOAD_ABUSE(void);
BOOL GET_SMILEYS(smiley_data_typ *smiley_data, int level);
BOOL GET_ABUSE(smiley_data_typ *smiley_data);

			
#define HTTPSOCKETEXTAG_GETLOBBY	1
#define HTTPSOCKETEXTAG_POSTLOBBY	2
#define HTTPSOCKETEXTAG_MCODE		3
#define HTTPSOCKETEXTAG_RMANG		4
#define HTTPSOCKETEXTAG_TOURNEY		5	
#define HTTPSOCKETEXTAG_NEXTEVENT	6

//#define CLKPROBE_TEXT
#define CLKPROBE_BAR

//#define RANKING_UPDATE_DELAY			1800 // every 1800 seconds (30mins) update rankings

#define ASPECT_RATIO_TABLE		0.5f // 0.525f
#define ASPECT_RATIO_MINICAM	1.0f //1.0f

/*
#define Mgfx_rgbmask888(x) ((x)&0xffffff)

#define Mgfx_rgbcolor888(r,g,b)		((DWORD) (r)<<16)|\
									((DWORD) (g)<<8)|\
									((DWORD) (b))
d#define MRGBC(r,g,b) (Mgfx_rgbcolor888(r,g,b))
#define MRGBM(x) (Mgfx_rgbmask888(x))
*/


#ifdef _DEBUG		   
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// globals!

unsigned char G_Trialist_Flag = 0;

///////// MACADDRESS ////////////
typedef struct _ASTAT_
{
	ADAPTER_STATUS adapt;
	NAME_BUFFER    NameBuff[22];
} ASTAT, * PASTAT;


typedef BOOL(WINAPI * pSnmpExtensionInit) (
        IN DWORD dwTimeZeroReference,
        OUT HANDLE * hPollForTrapEvent,
        OUT AsnObjectIdentifier * supportedView);

typedef BOOL(WINAPI * pSnmpExtensionTrap) (
        OUT AsnObjectIdentifier * enterprise,
        OUT AsnInteger * genericTrap,
        OUT AsnInteger * specificTrap,
        OUT AsnTimeticks * timeStamp,
        OUT RFC1157VarBindList * variableBindings);

typedef BOOL(WINAPI * pSnmpExtensionQuery) (
        IN BYTE requestType,
        IN OUT RFC1157VarBindList * variableBindings,
        OUT AsnInteger * errorStatus,
        OUT AsnInteger * errorIndex);

typedef BOOL(WINAPI * pSnmpExtensionInitEx) (
        OUT AsnObjectIdentifier * supportedView);


CString GetMacAddressA(void);
CString GetMacAddressB(void);
//CString GetMacAddressC(void);
CString GetMacAddressD(CString sNetBiosName);
CString GetMacAddressE(void);
CString GETMACADDRESS(void);
BYTE hexconv(unsigned char in1, unsigned char in2);
/////////////////////////////////



BOOL g_logTableChat = FALSE; // defaultly don't log table chat
BOOL g_laddersave = FALSE;	// defaultly, make lobbies not reset and save the ladder results
BOOL g_leader = FALSE;
BOOL g_freeaccounts = FALSE;
BOOL g_disabletriallock = FALSE;
BOOL g_guestonly = FALSE;
BOOL g_membersonly = FALSE;
BOOL g_memberstrialsonly = FALSE;
BOOL g_tourney_system = 0;
BOOL g_guestchat = FALSE;
BOOL g_sponsoron = TRUE;
BOOL g_sponsorback = FALSE;
BOOL g_defensemac = FALSE;  // Defaultly don't use any Defense systems other than impregnation
BOOL g_defensesys = FALSE;  // Defaultly don't use any Defense systems other than impregnation
BOOL g_conceded_game = FALSE;
BOOL g_ftpupload = FALSE;

float g_GoldThreshold8Ball = 0.7;
float g_GoldThreshold9Ball = 0.6;
float g_GoldThresholdEng = 0.7;

float g_GoldDecay8Ball = 0.97;
float g_GoldDecay9Ball = 0.98;
float g_GoldDecayEng = 0.99;


DWORD g_concede_time = 0;
DWORD uni_timer = 300*60;
extern BOOL g_oncreatecomplete = FALSE;

ServerSendConfig g_serverConfig;

BOOL g_bOriginalVersion = FALSE;	// If this is true, then we use the Error Code (Semi Pro / Pro) from verison 1.8.70 (around 2007-2008)
BOOL g_bTournamentLobby = FALSE;	// for the server this is overrided from lobby settings file
BOOL g_bDoubles = TRUE;				// Doubles Flag //
BOOL g_hacked = FALSE;
char g_tabSelected = 0;				// Default LobbyTV & HTML page view //
HistoryData g_history_data;
BOOL g_bLastTurn;
float g_ACamAngle = 0;



CString g_serverHandle = _T("[Server]");

#ifdef THE_POOL_CLUB // iPool
CString g_lobbyMessageBoard = _T("http://www.thepoolclub.com/lobby/bboardp.html");
CString g_lobbyMessageBoard2 = _T("http://www.thesnookerclub.com/lobby/bboardp.html");
CString g_lobbyTournament = _T(GATEWAY_URLTOURNAMENT);
CString g_lobbyLeague = _T("http://www.thepoolclub.com/leagues.html");
CString g_lobbyRegister = _T("http://www.thepoolclub.com/register.html");

CString g_FNamelobbyLeaderBoardA = _T("C:/httproot/www/lobby/leaderboarda.html");
CString g_FNamelobbyLeaderBoardB = _T("C:/httproot/www/lobby/leaderboardb.html");
CString g_URLlobbyLeaderBoardA = _T("http://208.117.81.46//lobby_ipool/leaderboarda.html");
CString g_URLlobbyLeaderBoardB = _T("http://208.117.81.46//lobby_ipool/leaderboardb.html");
CString g_URLlobbyTickerBoard = _T("http://208.117.81.46/lobby_ipool/tickerboard.html");
#else // iSnooker
CString g_lobbyMessageBoard = _T("http://www.thesnookerclub.com/lobby/bboards.html");
CString g_lobbyMessageBoard2 = _T("http://www.thepoolclub.com/lobby/bboards.html");
CString g_lobbyTournament = _T(GATEWAY_URLTOURNAMENT);
CString g_lobbyLeague = _T("http://www.thesnookerclub.com/leagues.html");
CString g_lobbyRegister = _T("http://www.thesnookerclub.com/register.html");

CString g_FNamelobbyLeaderBoardA = _T("C:/httproot/www/lobby/leaderboarda.html");
CString g_FNamelobbyLeaderBoardB = _T("C:/httproot/www/lobby/leaderboardb.html");
CString g_URLlobbyLeaderBoardA = _T("http://208.117.81.46//lobby/leaderboarda.html");
CString g_URLlobbyLeaderBoardB = _T("http://208.117.81.46/lobby/leaderboardb.html");
CString g_URLlobbyTickerBoard = _T("http://208.117.81.46/lobby/tickerboard.html");
#endif

#ifdef THE_POOL_CLUB // iPool
CString g_URLBanner = _T("http://thepoolclub.com/server/lobby/banner/index.html");
CString g_URLMessageBoard = _T("http://www.thepoolclub.com/lobby/bboardp.html");
CString g_URLTournament = _T(GATEWAY_URLTOURNAMENT);
CString g_URLBanner2 = _T("http://thepoolclub.com/server/lobby/banner/index.html");
CString g_URLMessageBoard2 = _T("http://www.thesnookerclub.com/lobby/bboardp.html");
#else // iSnooker
// CString g_URLBanner = _T("http://216.98.8.30/lobby/banner.html");
CString g_URLBanner = _T("http://www.thesnookerclub.com/server/lobby/banner/index.html");
CString g_URLMessageBoard = _T("http://www.thesnookerclub.com/lobby/bboards.html");
CString g_URLTournament = _T(GATEWAY_URLTOURNAMENT);
CString g_URLBanner2 = _T("http://216.98.8.30/lobby/banner.html");
CString g_URLMessageBoard2 = _T("http://www.thepoolclub.com/lobby/bboards.html");
#endif

FILE *fptr;
FILE *flogptr;

#ifdef THE_POOL_CLUB
CString g_appName = _T("iPool"); // iPool
#else
CString g_appName = _T("iSnooker"); // iSnooker
#endif

int g_clkprobe[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
int g_clkprobeavg[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
CString g_lobbyname = "";

DWORD g_id_count;

Mgfx_spr g_spr3dSurface;
Mgfx_spr g_spr3dSurfaceTmp;

Mgfx_spr g_spr3dSurface2;
Mgfx_spr g_spr3dSurfaceTmp2;


int g_guestcount;

CWnd *g_wnd = NULL;
CWnd *g_previousWndEditFocus = NULL;
int g_previousWndNo;
CDC *dblDC = NULL;

CDC MiniCamDC;
CBitmap m_Bitmap;

CBitmap *pBitmap;
CBitmap *dblBitmap;

char buffer[MAX_CHARS];
BOOL g_creator; // creator flag
CString g_nick = "Guest???";
int g_FIX_shiftX = 118;
int g_FIX_SpareW = 0;

#ifdef THE_POOL_CLUB
int g_yBarOffset = 40;
#else
int g_yBarOffset = 40;
#endif

unsigned char g_WideScreenChange = 0;

int g_pottedSpots[16];
int g_pottedStripes[16];


BallsSendData g_ballsSendDataBk; //~300bytes
CueBallTipSendDataC g_CueBallTipDataCBk;
ballPosSendData g_ballPosDataBk;
selectBallSendData g_selectBallDataBk;
char g_ResetbufferBk[16];
mouseMoveSendData g_mouseMoveDataBk;
char g_PlayAgainbufferBk[4];
char g_FoulAlertbufferBk[4];
char g_MissResetbufferBk[4];
MaxTimeUpSendData g_MaxTimeUpDataBk;
PlayerTargetSendData g_playerTargetDataBk;
char g_Pot8OnBreakRerackbufferBk[4];
char g_BadBreakRerackbufferBk[4];


int g_strikePowerError = 1;

// Initlialize our colour tbl - used for showing the Next Ball(s)
char *g_ctbl [] = {"C", "D", "E", "F", "G", "H"};


BOOL g_bBallRollOff = TRUE;
BOOL g_bBallJustHitEnergy = TRUE;
BOOL g_bNewParallelCushionLoss = TRUE;
BOOL g_bTextDoubleError = TRUE;
BOOL g_bDetectionO = TRUE;
BOOL g_bTextDoubleErrorAdded = FALSE;
BOOL g_bStrikeDownTable = TRUE;
int g_iPhysicsType = 0;

CMenu *g_menu; // pointer to MainFrame's menu
BOOL g_bMenuSelect;
int g_menuNItemID;
int g_menuNItemIDOld;
gfxDetails g_gfxDetails;
setupDetails g_setupDetails;
practiceDetails g_practiceDetails;
LobbyTVInfo g_LobbyTVInfo;


BOOL g_bFocus;
BOOL g_bClose;
UINT g_count;

BOOL g_bWireframeChanged;
BOOL g_bAntiAliasChanged;
BOOL g_bPerformanceChanged;

char *g_button_name[MAX_BUTTONS] = {
"Start",
"Re-Rack",
"Concede",//"TV Mode",
"Exit",
"Undo",
"Invite",
"Boot",
"Setup",
"N/A",
"Stand Up",
};

CConfig g_config;
char g_ExeName[80];	// ExeName: e.g. "isnooker.exe"

CBuild g_build;
char g_basedir[256];


int g_mouseSector = SECTOR_NONE;

char key_tempstr[256];
char *decryptstr1(char *str)
{
	int n;
	char *dest;
	dest = key_tempstr;
	for(n=0;n<80;n++)
	{
	if(!str[n]) dest[n] = 0;
	else if(str[n]=='a') dest[n]='z'; // out of phase by 1 char.
	else if(str[n]=='A') dest[n]='Z';
	else dest[n] = str[n]-1;
	
	if(!str[n])break;
	}
	return dest;
}
char *GETDISKCONTROLLERID(void)
{
	HKEY	hKey[9];
	DWORD	dwNumKeys = 9;
	DWORD	dwKeyIndex;
	BOOL bkeyFound = FALSE;

	if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,decryptstr1("IBSEXBSF" /*HARDWARE*/),0,KEY_READ,&hKey[0]) != ERROR_SUCCESS)
		return NULL;

	if(RegOpenKeyEx(hKey[0],decryptstr1("EFTDSJQUJPO" /*DESCRIPTION*/),0,KEY_READ,&hKey[1]) != ERROR_SUCCESS)
		return NULL;

	if(RegOpenKeyEx(hKey[1],decryptstr1("Tztufn" /*System*/),0,KEY_READ,&hKey[2]) != ERROR_SUCCESS)
		return NULL;

	if(RegOpenKeyEx(hKey[2],decryptstr1("NvmujgvodujpoBebqufs" /*MultifunctionAdapter*/),0,KEY_READ,&hKey[3]) != ERROR_SUCCESS)
		return NULL;

	DWORD dwQueryNumber=0;
	#define MAX_STRING_SIZE		1024
	char rgchSubQueryStringBuffer[MAX_STRING_SIZE];

	while(!bkeyFound)
	{
		if(RegOpenKeyEx(hKey[3],_itoa(dwQueryNumber++,rgchSubQueryStringBuffer,10),0,KEY_READ,&hKey[4]) == ERROR_SUCCESS)
		{
			if(RegOpenKeyEx(hKey[4],decryptstr1("EjtlDpouspmmfs" /*DiskController*/),0,KEY_READ,&hKey[5]) == ERROR_SUCCESS)
				bkeyFound = TRUE;
			else
				RegCloseKey(hKey[4]);
		} else
			return NULL;
	}
	
	if(RegOpenKeyEx(hKey[5],"0",0,KEY_READ,&hKey[6]) != ERROR_SUCCESS)
		return NULL;

	if(RegOpenKeyEx(hKey[6],decryptstr1("EjtlQfsjqifsbm" /*DiskPeripheral*/),0,KEY_READ,&hKey[7]) != ERROR_SUCCESS)
		return NULL;

	if(RegOpenKeyEx(hKey[7],"0",0,KEY_READ,&hKey[8]) != ERROR_SUCCESS)
		return NULL;


	DWORD dwKeyType;
	DWORD size;

	if(RegQueryValueEx(hKey[8],decryptstr1("Jefoujgjfs" /*Identifier*/),NULL,&dwKeyType,NULL,&size) != ERROR_SUCCESS)
		return NULL;

	BYTE * pBuffer = new BYTE[size];

	if(RegQueryValueEx(hKey[8],decryptstr1("Jefoujgjfs" /*Identifier*/),NULL,&dwKeyType,pBuffer,&size) != ERROR_SUCCESS)
		{
		delete pBuffer;
		return NULL;
		}

	for(dwKeyIndex=0;dwKeyIndex < dwNumKeys;dwKeyIndex++)	
		RegCloseKey(hKey[dwKeyIndex]);

	return (char *)pBuffer;
}


DWORD generate_uniquecrc(char *str)
{
// password: pointer to string to be filled will generated password
// name: pointer to string that contains username
// symbols: pointer to string containing all available symbols for the password.
// pwd_len: desired length in characters for the password.
	int symbols_n;
	unsigned int seed; // 32-bit seed value.
	int n;

	// make starting random seed based on the ASCII character values of name.
	seed = 0x194c5327; // seed starting value is a fixed random value for uniqueness.
	for(n=0;n<80;n++) // go thru string.
	{
	if(!str[n]) break; // reached end of string.
	seed = seed<<1 | ((seed>>31)&1);	   // rotate bits of seed left by 1 bit.
	seed+=str[n];	// add ASCII value of character to seed.
	}
	// now generate random password of length pwd_len.

	return seed;
	
	/*srand(seed); // set random seed to seed.
	for(n=0;n<pwd_len;n++)
	{
	password[n] = symbols[rand()%symbols_n]; // generate symbols randomly.
	}
	password[pwd_len] = 0; // add terminator to string.
	*/
}

DWORD convert32bithexstr(char *str)
{
	DWORD v;
	int n;
	char c;
	v = 0;
	for(n=0;n<8;n++)
	{
	v<<=4;
	c = str[n];
	if(c>='0' && c<='9') v|=c-'0';
	else if(c>='a' && c<='f') v|=c-'a'+10;
	else if(c>='A' && c<='F') v|=c-'A'+10;
	else v|=c;// shouldn't get here. lol.
	}
	return v;
}

DWORD GETDISKCONTROLLER32BIT(void)
{
	char *str;
	DWORD code;
	str = GETDISKCONTROLLERID();
	if(str==NULL) return 0;

	// convert str -> 32 bit hex crc code.
	//code = generate_uniquecrc(str);
	code = convert32bithexstr(str);

	delete str;

	return code;
}

// [CGatewayLst] //

CGatewayEXELst::CGatewayEXELst()
{
	int n;
	m_gatewaylst_n = 8;
	m_gatewaylst = new char *[m_gatewaylst_n];
	m_port = new int[m_gatewaylst_n];
	m_gatewaylst_i = 0;
	m_gatewaylst_s = 0;
}

CGatewayEXELst::~CGatewayEXELst()
{
	ResetGateway();
	delete m_gatewaylst;
	delete m_port;
}

void CGatewayEXELst::ResetGateway(void)
{
	while(m_gatewaylst_n)
	{
	m_gatewaylst_i--;
	delete m_gatewaylst[m_gatewaylst_i];
	}
}

void CGatewayEXELst::AddGateway(char *addr, int port)
{
	int len;
	len = strlen(addr)+1;
	m_gatewaylst[m_gatewaylst_i] = new char[len];
	strcpy(m_gatewaylst[m_gatewaylst_i], addr);
	m_port[m_gatewaylst_i] = port;

	m_gatewaylst_i++;
}

// [CRecentLog] //

CRecentLog::CRecentLog(int max)
{
	m_strList_n = max;
	m_strList = new char *[m_strList_n];
	m_strList_idx = 0;
	m_strList_tot = 0;
	m_heat = 0;
}

CRecentLog::~CRecentLog()
{
	int n;
	for(n=0;n<m_strList_tot;n++)
	delete m_strList[n];

	delete m_strList;
}

void CRecentLog::AddStr(char *str)
{
	int len;
	if(m_strList_tot==m_strList_n) delete m_strList[m_strList_idx]; // once at max, we have to delete each new message.

	len = strlen(str);
	m_strList[m_strList_idx] = new char[len+1];
	strcpy(m_strList[m_strList_idx], str);
	m_strList_idx++;
	if(m_strList_idx==m_strList_n) m_strList_idx = 0; // Wrap index.
	if(m_strList_tot<m_strList_n) m_strList_tot++; // Total counts to max, then stays at max.

	m_heat++;
}

void CRecentLog::Debug(void)
{
	int n;
	FILE *fptr;
	fptr = fopen("logtest.txt","a+b");
	if(fptr == NULL) 
	{
		return;
	}
	if(m_strList_tot==m_strList_n) n = m_strList_idx; // if full, then start on next message (which is the oldest message)
	else n = 0; // else start from start.
	do {
	fprintf(fptr,"%d:%s\r\n", n, m_strList[n]);
	//ErrorMessage((CGameAppView *)g_wnd,m_strList[m_strList_idx]);
	n++;
	if(n==m_strList_n) n = 0; // Wrap.
	} while(n!=m_strList_idx);
	fclose(fptr);
}

void CRecentLog::Report(void)
{
	int n;
	unsigned char buffer[256];
	if(m_heat<4) return; // Not hot enough.

	buffer[0] = MSGCODE_REPORTABUSE;
	buffer[1] = 0; // reset
	
	if(m_strList_tot==m_strList_n) n = m_strList_idx; // if full, then start on next message (which is the oldest message)
	else n = 0; // else start from start.
	do {

	
	// Filter through buffer (to make sure all abusive words are filtered 
	// This means the Moderators will treat the player correctly, based on what was displayed,
	// as opposed to what was typed before being filter 

	// copy string we want to check to gstr //
	gstr = new char[256];
	smiley_data.smiley_offset = 0;
	smiley_data.smiley_adjust = 0;
	sprintf(gstr, "%s", m_strList[n]);
	char tstr[256];
	int idx;
	bool found_abuse = false;

	for(int z=0;z<16;z++)	// Should be more than 16 abusive comments in a sentence
	{
		idx = 0;
		if(GET_ABUSE(&smiley_data))
		{
			found_abuse = true;
		
			for(int i=0;i<smiley_data.smiley_spos;i++) 
			{
				tstr[idx] = gstr[i];
				idx++;
			}
			

			// Replace Filtered Characters with *'s //
			for(int i=smiley_data.smiley_spos;i<smiley_data.smiley_epos;i++)
			{
				tstr[idx] = '*';
				idx++;
			}

			for(int i=smiley_data.smiley_epos;i<strlen(gstr);i++) 
			{
				tstr[idx] = gstr[i];
				idx++;
			}

			tstr[idx] = 0;

			// Update gstr //
			sprintf(gstr, "%s", tstr);
		}
		else break;

	}

	//sprintf(&buffer[0], "%s", gstr);
	if(!found_abuse) sprintf((char *)&buffer[2],"%s",m_strList[n]);
		else sprintf((char *)&buffer[2],"%s", tstr);


	//sprintf((char *)&buffer[2],"%s",m_strList[n]);

		
		
	

	mainShell->Client->SendToQueue(buffer, strlen((char *)&buffer[2])+3, 0); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

	buffer[1] = 1; // carry on.
	n++;
	if(n==m_strList_n) n = 0; // Wrap.
	} while(n!=m_strList_idx);	

	m_heat = 0;

	

	g_gameAppView->Message("Abuse Reported (Last 16 lines of text reported). Please contact a Moderator for help regarding this Abuse.", 40);
}


// [CRequestManager] //

CRequestManager::CRequestManager(CWnd* pParent)
{
	int n;
	for(n=0;n<8;n++)
	{
	m_httpSocketEx[n] = new CHTTPSocketEx;
	m_httpSocketEx[n]->GetParent(pParent);
	}
}

CRequestManager::~CRequestManager()
{
	int n;
	for(n=0;n<8;n++)
	{
	delete m_httpSocketEx[n];
	}
}

int CRequestManager::SlotsUsed(void)
{
	int n;
	int cnt;
	cnt = 0;
	for(n=0;n<8;n++)
	if(m_httpSocketEx[n]->m_active) cnt++;
	
	return cnt;
}

void CRequestManager::ClearSlots(void)
{
	int n;
	for(n=0;n<8;n++)
	if(m_httpSocketEx[n]->m_active)
	{
	m_httpSocketEx[n]->Kick();
	m_httpSocketEx[n]->m_active = FALSE;
	}
}

void CRequestManager::StartRequest(char *ip, int port, char *reqstr)
{ 
	int n;
	char path[80];
	BOOL vacant;
	vacant = FALSE;

	for(n=0;n<8;n++)
	if(!m_httpSocketEx[n]->m_active) {
									 vacant = TRUE;
									 break;
									 }
	
	if(!vacant) // All slots full, then lets notify this in the log and flush it!
	{
	ClearSlots();
	/*{
	   char buffer[256];
	   ((CGameAppView *)g_wnd)->GetTime();
	   sprintf(buffer,"Clearing: %s [%s]", ((CGameAppView *)g_wnd)->m_stringShortTime,((CGameAppView *)g_wnd)->m_stringShortDate);
	   AddLog("LogHTTP.txt", buffer); // ### Log 
	}*/

	}

	for(n=0;n<8;n++)
	if(!m_httpSocketEx[n]->m_active)
	{
	m_httpSocketEx[n]->Init(ip, port);
	m_httpSocketEx[n]->m_tag = HTTPSOCKETEXTAG_RMANG;

	sprintf(path,"socket%d.tmp",n);

	m_httpSocketEx[n]->Request(reqstr, "", path);//"socket.tmp");
	m_httpSocketEx[n]->m_active = TRUE;

		/*{
	   char buffer[256];
	   ((CGameAppView *)g_wnd)->GetTime();
	   sprintf(buffer,"Requesting: %s (%s) - %s [%s]",reqstr, path,
				((CGameAppView *)g_wnd)->m_stringShortTime,((CGameAppView *)g_wnd)->m_stringShortDate);
	   AddLog("LogHTTP.txt", buffer); // ### Log 
		}*/

	return;
	}
}

// CRC Runtime Checking Code ///////////////////////////////////////////////////////////
int g_processcount;
DWORD g_crcRuntime;
BOOL g_bcrcFirstime = TRUE;

DWORD calcCRC(void *lpBuf, int size)
{
	DWORD crc = 0xF141C92E;
	BYTE *buffer = (BYTE *) lpBuf;
	int n;
	for(n=0;n<size;n++)
	{
	crc+=buffer[n];
	crc^=n*137;
	}
	return crc;
}

DWORD appCRC(void)
{
	DWORD crc;
	//crc = calcCRC(&((CGameAppView *)g_wnd)->m_snooker->m_score1P, sizeof(int));
	//crc = calcCRC(((CGameAppView *)g_wnd)->m_snooker, sizeof(CSnooker));
	//return crc;
	return 0;
}

void updateCRC(void)
{
	/*g_crcRuntime = appCRC();
	g_bcrcFirstime = FALSE;*/
} 

void checkCRC(void)
{
/*	DWORD crc;
	BOOL failed = FALSE;
	crc = appCRC();
	if(crc!=g_crcRuntime) 
		{
		if(g_bcrcFirstime);
		else failed = TRUE;
		}
	g_crcRuntime = crc;
	g_bcrcFirstime = FALSE;
	if(failed)
	{

	}*/
}

// CRC Check Code ///////////////////////////////////////////////////////////

DWORD g_crc;

DWORD CRC_Check(char *fname)
{
	FILE *fptr;
	int length;
	DWORD crc;
	DWORD data;
	int tick;
	int mode;
	length = Mmain_filelen(fname);
	if(length==-1) return 0; // invalid filename i.e. crc = 0

	crc = 0;
	fptr = fopen(fname,"rb");
	if(fptr == NULL) 
	{
		return 0;
	}

	srand(135);
	tick=0xA5; // awkward binary number
	mode=0;
	while(length>=4)
	{
	fread(&data,4,1,fptr);
	if(!mode)
		{
		crc	= (crc<<1) | (crc>>31); // Rol
		crc+=data;
		}
	else {
		crc	= (crc>>1) | (crc<<31); // Ror
		crc+=data;
		}
	if(tick)
		{
		tick--;
		if(!tick) tick = 3+(rand()%137);
		}
	length-=4;
	}
	fclose(fptr);

	return crc;
}

int wwwsearchi(char *buf, int len, char *str ,int offset) // non case sensi.
{
	int n;
	int i;
	char s;
	char b;
	i = 0;
	for(n=offset;n<len;n++)
	{
	s = str[i];
	if(s>='a' && s<='z') s-=32;
	b = buf[n];
	if(b>='a' && b<='z') b-=32;



	if(b == s) // character match
		{
		i++;
		if(str[i]==0) return n+1;
		} else {
			   n-=i;
			   i=0;
			   }
	}
	return -1;
}


int wwwsearchiencapsulate(char *contents, char *buffer, int len, char *str_s ,char *str_e,int offset) // non case sensi.
{
	int start,end;
	start = offset = wwwsearchi(buffer,len, str_s, offset);
	end = offset = wwwsearchi(buffer,len, str_e, offset);

	end-=strlen(str_e);
	if (end < 0)
		return 0;
	// New Branch
	// Why does this affect other branches..

	
	memcpy(contents,&buffer[start],end-start);
	contents[end-start] = 0;
	return offset;
}

char *wwwsearchiencapsulateauto(int *rt_len, char *buffer, int len, char *str_s ,char *str_e,int *offset) // non case sensi.
{
	int start,end;
	start = *offset = wwwsearchi(buffer,len, str_s, *offset);
	if(*offset==-1) return NULL;
	end = *offset = wwwsearchi(buffer,len, str_e, *offset);
	if(*offset==-1) return NULL;
	end-=strlen(str_e);

	*rt_len = end-start;
	return &buffer[start];
}

char *makestring(char *buffer, int len)
{
	char *str;
	str = new char[len+1];
	memcpy(str, buffer, len);
	str[len] = 0;
	return str;
}

// //////////////////////////////////////////////////////////////////////////

// //////////////////////////////////

CGatewayLst::CGatewayLst(int n)
{
	m_ip_n = n;
	m_ip = new char *[m_ip_n];
	m_addr = new char *[m_ip_n];
	m_port = new int[m_ip_n];
	m_players = new int[m_ip_n];
	
	for(n=0;n<m_ip_n;n++)
	{
	m_ip[n] = NULL;
	m_addr[n] = NULL;
	}
}

CGatewayLst::~CGatewayLst()
{

	int n;
	for(n=0;n<m_ip_n;n++)
	if(m_ip[n])
	{
	delete m_ip[n];
	}
	for(n=0;n<m_ip_n;n++)
	if(m_addr[n])
	{
	delete m_addr[n];
	}

	delete m_ip;
	delete m_addr;
	delete m_port;
	delete m_players;
}

int CGatewayLst::AddLobby(char *ip, char *ext)
{
	int n;
	int i;
	for(n=0;n<m_ip_n;n++)
	if(!m_ip[n])
	{
	m_ip[n] = new char[strlen(ip)+1];
	strcpy(m_ip[n],ip);
	// -------------------- //
	for(i=0;i<256;i++)
		{
		if(!ip[i]) break;
		if(ip[i]==':')
			{
			m_addr[n] = new char[i+1];
			memcpy(m_addr[n],ip,i);
			m_addr[n][i] = 0;

			sscanf(&ip[i+1],"%d",&m_port[n]);	
			break;
			}
		}
	// Extended data //
	if(ext)
	{
	char field_type[80];
	int field_players;
	field_type[0] = 0;
	field_players = -1;
	sscanf(ext,"%s%d",field_type,&field_players);

	m_players[n] = field_players;
	}
	return n;
	}
	return -1;
}

char *CGatewayLst::GetLobby(int idx)
{
	if(idx<m_ip_n) return m_ip[idx];
	return NULL;
}

char *CGatewayLst::GetLobbyAddr(int idx)
{
	if(idx<m_ip_n) return m_addr[idx];
	return NULL;
}

int CGatewayLst::GetLobbyPort(int idx)
{
	if(idx<m_ip_n) return m_port[idx];
	return 0;
}


DWORD g_sysID = 0;	  // System ID
WORD  g_cpuID = 0;    // CPU, stored with SystemID
DWORD g_macID_U = 0;  // Holds the Top 4 BYTES of MAC Address
WORD  g_macID_L = 0;  // Holds the Lower 2 BYTES of MAC Address

CString GETMACADDRESS(void)
{
	char maddress[16];
	int count, i;
	
	// Finding MAC Address //
	// Try 4 Methods //

	g_macID_L = 0;

	///// First Methods of Finding MAC Address //////
	sprintf(maddress, "%s", GetMacAddressA());
	g_macID_L = hexconv(maddress[8],maddress[9]);
    g_macID_L = g_macID_L << 8;
    g_macID_L += hexconv(maddress[10],maddress[11]);

	

	
	///// If the Lower 2 BYTES of MAC Address are 0, Try Another Method
	if(!g_macID_L) 
		{
		sprintf(maddress, "%s", GetMacAddressE());
		g_macID_L = hexconv(maddress[8],maddress[9]);
		g_macID_L = g_macID_L << 8;
		g_macID_L += hexconv(maddress[10],maddress[11]);
		// If MAC Address Contains 4 or more Zeros, don't use it and set to 0
		count=0;
		for(i=0;i<strlen(maddress);i++) if(maddress[i]=='0') count++;
		if(count>=4) g_macID_L=0;
		}
	///// If the Lower 2 BYTES of MAC Address are 0, Try Another Method
	if(!g_macID_L) 
		{
		sprintf(maddress, "%s", GetMacAddressB());
		g_macID_L = hexconv(maddress[8],maddress[9]);
		g_macID_L = g_macID_L << 8;
		g_macID_L += hexconv(maddress[10],maddress[11]);
		// If MAC Address Contains 4 or more Zeros, don't use it and set to 0
		count=0;
		for(i=0;i<strlen(maddress);i++) if(maddress[i]=='0') count++;
		if(count>=4) g_macID_L=0;
		}
	///// If the Lower 2 BYTES of MAC Address are 0, Try Another Method
	if(!g_macID_L) 
		{
		// Finding IP //
		WSAData wsaData;
		if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0) 
			{
			return "0";
			}

		char ac[80];
		if (gethostname(ac, sizeof(ac)) == SOCKET_ERROR) 
			{
			return "0";
			}
		sprintf(maddress, "%s", GetMacAddressD(ac));
		
		// Clean Up //
		WSACleanup();
			
		g_macID_L = hexconv(maddress[8],maddress[9]);
		g_macID_L = g_macID_L << 8;
		g_macID_L += hexconv(maddress[10],maddress[11]);
		// If MAC Address Contains 4 or more Zeros, don't use it and set to 0
		count=0;
		for(i=0;i<strlen(maddress);i++) if(maddress[i]=='0') count++;
		if(count>=4) g_macID_L=0;
		}

	
	
	///// If the Lower 2 BYTES of MAC Address are still 0, no Method worked, so return 0 string //
	///// Else return the MAC Address string
	if(g_macID_L) return maddress;
	else return "000000000000";
}




BYTE hexconv(unsigned char in1, unsigned char in2)
{
BYTE val1,val2;

// Get First Char  (0-15 value) //
if(in1>='0' && in1<='9') val1=in1-48;
else if(in1>='a' && in1<='f') val1=in1-97+10;
else if(in1>='A' && in1<='F') val1=in1-65+10;
else val1=0;


// Get Second Char  (0-15 value) //
if(in2>='0' && in2<='9') val2=in2-48;
else if(in2>='a' && in2<='f') val2=in2-97+10;
else if(in2>='A' && in2<='F') val2=in2-65+10;
else val2=0;

// return =  Val1*16 + Val2

return (val1*16 + val2);
}


void GetSysID(void)
{
 char tbuf[16];
 
 // See if we can get the Clients Network Card Identifier //
 // Potentially the Best Method //
 strcpy(tbuf, GETMACADDRESS());	
 
  
 g_macID_U = hexconv(tbuf[0],tbuf[1]);
 g_macID_U = g_macID_U << 8;
 g_macID_U += hexconv(tbuf[2],tbuf[3]);
 g_macID_U = g_macID_U << 8;
 g_macID_U += hexconv(tbuf[4],tbuf[5]);
 g_macID_U = g_macID_U << 8;
 g_macID_U += hexconv(tbuf[6],tbuf[7]);
 
 g_macID_L = hexconv(tbuf[8],tbuf[9]);
 g_macID_L = g_macID_L << 8;
 g_macID_L += hexconv(tbuf[10],tbuf[11]);
 

 
// Check that we have a proper MAC Address //
// If the First 2 BYTES are all 0, then return NULL
// If the Last 4 BYTES are all 0, then return NULL too
// If one of these is TRUE, then set the entire MAC Address to 0, so it is not used.
 if(g_macID_L==0) g_macID_U=0;
 if(g_macID_U==0) g_macID_L=0;


 g_cpuID = Mmain_cpuid();
 
 // Get the System ID the best method
 g_sysID = GETDISKCONTROLLER32BIT();
 

 /*
 char* buf = new char[256];
 sprintf(buf, "g_cpuID: %ld, g_sysID: %ld, g_macID_U: %ld, g_macID_L: %ld", g_cpuID, g_sysID, g_macID_U, g_macID_L);
 AfxMessageBox(buf);
 delete[] buf;
 */

 // If sysID is 0 try more robust method //
 if(g_sysID==NULL)
 {
 char volume_name[255];
 char file_system_name[255];
 DWORD flags = 0, serial_number = 0, max_component_length = 0;
	if(GetVolumeInformation("C:\\", volume_name, 255, &serial_number, &max_component_length, &flags, file_system_name, 255))
	{
	g_sysID = serial_number;
	}
 }
}

// //////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGameAppView

IMPLEMENT_DYNCREATE(CGameAppView, CView)

BEGIN_MESSAGE_MAP(CGameAppView, CView)
	//{{AFX_MSG_MAP(CGameAppView)
	ON_WM_CREATE()
	ON_WM_ERASEBKGND()
	ON_WM_SYSCOMMAND()
	ON_WM_SIZE()
	ON_WM_MOUSEWHEEL()
	ON_WM_MBUTTONDOWN()
	ON_WM_MBUTTONUP()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDBLCLK()
	ON_MESSAGE(WM_MOUSEHOVER, OnMouseHover)
	ON_MESSAGE(WM_MOUSELEAVE, OnMouseLeave)
	ON_WM_TIMER()
	ON_WM_RBUTTONUP()
	ON_WM_SETCURSOR()

	ON_COMMAND(ID_PRACTICE_LINEUP, OnPracticeLineup)
	ON_COMMAND(ID_PRACTICE_START, OnPracticeStart)
	ON_COMMAND(ID_PRACTICE_COLOURS, OnPracticeColours)
	ON_COMMAND(ID_PRACTICE_BLACK, OnPracticeBlack)
	ON_COMMAND(ID_PRACTICE_BILLIARDS, OnPracticeBilliards)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_INTERNET_DETAILS, OnInternetDetails)
	ON_WM_MEASUREITEM()
	ON_COMMAND(ID_INTERNET_LOBBY, OnInternetLobby)
	ON_COMMAND(ID_INTERNET_EXIT, OnInternetExit)
	ON_UPDATE_COMMAND_UI(ID_INTERNET_DETAILS, OnUpdateInternetDetails)
	ON_UPDATE_COMMAND_UI(ID_INTERNET_EXIT, OnUpdateInternetExit)
	ON_UPDATE_COMMAND_UI(ID_INTERNET_LOBBY, OnUpdateInternetLobby)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_START, OnUpdatePracticeStart)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_LINEUP, OnUpdatePracticeLineup)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_COLOURS, OnUpdatePracticeColours)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_BLACK, OnUpdatePracticeBlack)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_BILLIARDS, OnUpdatePracticeBilliards)
	ON_COMMAND(ID_PRACTICE_REDSSCATTERED1, OnPracticeRedsscattered1)
	ON_COMMAND(ID_PRACTICE_REDSSCATTERED2, OnPracticeRedsscattered2)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_REDSSCATTERED1, OnUpdatePracticeRedsscattered1)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_REDSSCATTERED2, OnUpdatePracticeRedsscattered2)
	ON_COMMAND(ID_HELP_ONLINE, OnHelpOnline)
	ON_COMMAND(ID_OPTIONS_REPLAYPANEL, OnOptionsReplaypanel)
	ON_UPDATE_COMMAND_UI(ID_OPTIONS_REPLAYPANEL, OnUpdateOptionsReplaypanel)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_COMMAND(ID_EDIT_SELECTALL, OnEditSelectall)
	ON_COMMAND(ID_GAME_PLAYERLIST, OnGamePlayerlist)
	ON_UPDATE_COMMAND_UI(ID_GAME_PLAYERLIST, OnUpdateGamePlayerlist)
	ON_COMMAND(ID_PRACTICE_EDIT, OnPracticeEdit)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_EDIT, OnUpdatePracticeEdit)
	ON_COMMAND(ID_PRACTICE_SAVE, OnPracticeSave)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_SAVE, OnUpdatePracticeSave)
	ON_COMMAND(ID_PRACTICE_LOAD, OnPracticeLoad)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_LOAD, OnUpdatePracticeLoad)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_BALLINHAND, OnUpdatePracticeBallinhand)
	ON_COMMAND(ID_HELP_FAQ, OnHelpFaq)
	ON_COMMAND(ID_HELP_VERSION, OnHelpVersion)
	ON_UPDATE_COMMAND_UI(ID_HELP_VERSION, OnUpdateHelpVersion)
	ON_COMMAND(ID_INVITATIONS_DECLINEALL, OnInvitationsDeclineall)
	ON_COMMAND(ID_INVITATIONS_DECLINEGUESTS, OnInvitationsDeclineguests)
	ON_UPDATE_COMMAND_UI(ID_INVITATIONS_DECLINEGUESTS, OnUpdateInvitationsDeclineguests)
	ON_COMMAND(ID_REGISTER_NEWACCOUNT, OnRegisterNewaccount)
	ON_UPDATE_COMMAND_UI(ID_REGISTER_NEWACCOUNT, OnUpdateRegisterNewaccount)
	ON_COMMAND(ID_REGISTER_PURCHASE, OnRegisterPurchase)
	ON_UPDATE_COMMAND_UI(ID_REGISTER_PURCHASE, OnUpdateRegisterPurchase)
	ON_COMMAND(ID_REGISTER_TOPUPACCOUNT, OnRegisterTopupaccount)
	ON_UPDATE_COMMAND_UI(ID_REGISTER_TOPUPACCOUNT, OnUpdateRegisterTopupaccount)
	ON_UPDATE_COMMAND_UI(ID_INVITATIONS_DECLINEALL, OnUpdateInvitationsDeclineall)
	ON_COMMAND(ID_DEBUG_ACTIVATE, OnDebugActivate)
	ON_COMMAND(ID_DEBUG_DEACTIVATE, OnDebugDeactivate)
	ON_COMMAND(ID_RABUSE_SEND, OnRabuseSend)
	ON_COMMAND(ID_FILE_LOAD, OnFileLoad)
	ON_UPDATE_COMMAND_UI(ID_FILE_LOAD, OnUpdateFileLoad)
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_COMMAND(ID_GAME_START, OnGameStart)
	ON_UPDATE_COMMAND_UI(ID_GAME_START, OnUpdateGameStart)
	ON_COMMAND(ID_GAME_STANDUP, OnGameStandup)
	ON_UPDATE_COMMAND_UI(ID_GAME_STANDUP, OnUpdateGameStandup)
	ON_COMMAND(ID_GAME_SETUP, OnGameSetup)
	ON_UPDATE_COMMAND_UI(ID_GAME_SETUP, OnUpdateGameSetup)
	ON_COMMAND(ID_GAME_RERACK, OnGameRerack)
	ON_UPDATE_COMMAND_UI(ID_GAME_RERACK, OnUpdateGameRerack)
	ON_COMMAND(ID_GAME_INVITE, OnGameInvite)
	ON_UPDATE_COMMAND_UI(ID_GAME_INVITE, OnUpdateGameInvite)
	ON_COMMAND(ID_GAME_EXIT, OnGameExit)
	ON_UPDATE_COMMAND_UI(ID_GAME_EXIT, OnUpdateGameExit)
	ON_COMMAND(ID_GAME_CONCEDE, OnGameConcede)
	ON_UPDATE_COMMAND_UI(ID_GAME_CONCEDE, OnUpdateGameConcede)
	ON_COMMAND(ID_GAME_BOOT, OnGameBoot)
	ON_UPDATE_COMMAND_UI(ID_GAME_BOOT, OnUpdateGameBoot)
	ON_COMMAND(ID_GAME_UNDO, OnGameUndo)
	ON_UPDATE_COMMAND_UI(ID_GAME_UNDO, OnUpdateGameUndo)
	ON_COMMAND(ID_PLAYERS_1PVs2P, OnPLAYERS1PVs2P)
	ON_UPDATE_COMMAND_UI(ID_PLAYERS_1PVs2P, OnUpdatePLAYERS1PVs2P)
	ON_COMMAND(ID_HELP_GAMERULES, OnHelpGamerules)
	ON_UPDATE_COMMAND_UI(ID_HELP_GAMERULES, OnUpdateHelpGamerules)
	ON_WM_VSCROLL()
	
	
	ON_COMMAND(ID_WIDESCREENMODE_DISABLED, OnWideScreenDisabled)
	ON_COMMAND(ID_WIDESCREENMODE_ENABLED, OnWideScreenEnabled)
	ON_UPDATE_COMMAND_UI(ID_WIDESCREENMODE_DISABLED, OnUpdateWideScreenDisabled)
	ON_UPDATE_COMMAND_UI(ID_WIDESCREENMODE_ENABLED, OnUpdateWideScreenEnabled)
		
	ON_WM_ACTIVATE()
	
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_BUTTONDROP1, OnButtonStart)
	ON_BN_CLICKED(IDC_BUTTONDROP2, OnButtonReRack)
	ON_BN_CLICKED(IDC_BUTTONDROP3, OnButtonConcede)//OnButtonTVMode)
	ON_BN_CLICKED(IDC_BUTTONDROP4, OnButtonExit)
	ON_BN_CLICKED(IDC_BUTTONDROP5, OnButtonUndo)//OnButtonStandUp)	
	ON_BN_CLICKED(IDC_BUTTONDROP6, OnButtonInvite)
	ON_BN_CLICKED(IDC_BUTTONDROP7, OnButtonBoot)
	ON_BN_CLICKED(IDC_BUTTONSETUP, OnButtonSetup)
	ON_BN_CLICKED(IDC_BUTTONREPORT, OnButtonReportAbuse)
	ON_BN_CLICKED(IDC_BUTTONSTAND, OnButtonStand)
	ON_BN_CLICKED(IDC_BUTTONENDPRACTICE, OnButtonEndPractice)
	//ON_BN_CLICKED(IDC_BUTTONCUEERROR, OnButtonCueError)
	ON_CBN_SELCHANGE(IDC_BUTTONCUEERROR, OnButtonCueError)
	ON_BN_CLICKED(IDC_BUTTONRATED, OnButtonRated)
	ON_CBN_SELCHANGE(IDC_BOXTABLETYPE, OnTableTypeBoxSelect)
	ON_BN_CLICKED(IDC_BUTTONMISSRULE, OnButtonMissRule)
	
	ON_BN_CLICKED(IDC_BUTTONSAY, OnButtonSay)

	ON_BN_CLICKED(IDC_SMILEYSELECT, OnButtonSmileySelect)
	ON_BN_CLICKED(IDC_BUTTONREFRESH, OnButtonRefresh)
	ON_BN_CLICKED(IDC_BUTTONENTERLOBBY, OnButtonEnterLobby)
	ON_BN_CLICKED(IDC_BUTTONSERVERCONFIG, OnButtonServerConfig)
	ON_BN_CLICKED(IDC_BUTTONACCOUNTCONFIG, OnButtonAccountConfig)
	ON_BN_CLICKED(IDC_BUTTONLOBBYSTAT, OnButtonLobbyStat)
	ON_BN_CLICKED(IDC_HELPLOGINERROR, OnButtonHelpLoginError)
	ON_BN_CLICKED(IDC_BUTTONVIEWTABLES, OnButtonViewTables)
	ON_BN_CLICKED(IDC_BUTTONHOME, OnButtonHome)
	ON_BN_CLICKED(IDC_BUTTONREGISTER, OnButtonRegister)
	ON_BN_CLICKED(IDC_BUTTONTOURNEYS, OnButtonTourneys)
	ON_BN_CLICKED(IDC_BUTTONLEAGUES, OnButtonLeagues)
	ON_BN_CLICKED(IDC_BUTTONCHANGELOBBY, OnButtonChangeLobby)
	ON_BN_CLICKED(IDC_BUTTONFULLTOGGLE, OnButtonMBFullLobby)

	
		
	ON_COMMAND(ID_HELP, OnHelpMessage) // press F1 to trigger this WM_COMMAND
	ON_COMMAND(ID_PRACTICE_A, OnPracticeA) // practice routine A (extra)
	ON_COMMAND(ID_PRACTICE_B, OnPracticeB) // practice routine B (extra)
	ON_COMMAND(ID_PRACTICE_C, OnPracticeC) // practice routine C (extra)
	ON_COMMAND(ID_PRACTICE_D, OnPracticeD) // practice routine D (extra)
	ON_COMMAND(ID_PRACTICE_E, OnPracticeE) // practice routine E (extra) (Break Setup)
	ON_COMMAND(ID_PRACTICE_F, OnPracticeF) // practice routine F (extra) (English Pool Setup)
	
	ON_COMMAND(ID_PRACTICE_G, OnPracticeG) // practice routine G (extra) (Normal Table)
	ON_COMMAND(ID_PRACTICE_H, OnPracticeH) // practice routine H (extra) (Pro Table)
	ON_COMMAND(ID_PRACTICE_I, OnPracticeI) // practice routine I (extra) (English Pool Table)

	ON_UPDATE_COMMAND_UI(ID_PRACTICE_A, OnUpdatePracticeA)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_B, OnUpdatePracticeB)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_C, OnUpdatePracticeC)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_D, OnUpdatePracticeD)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_E, OnUpdatePracticeE)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_F, OnUpdatePracticeF)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_G, OnUpdatePracticeG)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_H, OnUpdatePracticeH)
	ON_UPDATE_COMMAND_UI(ID_PRACTICE_I, OnUpdatePracticeI)
	
	ON_NOTIFY( EN_LINK, IDC_WINDOWCHATVIEW, OnChatEditExLink )
	ON_NOTIFY( EN_LINK, IDC_WINDOWSENDVIEW, OnSendEditLink )


	ON_COMMAND(ID_OPTIONS_FPS, &CGameAppView::OnShowFPS)
		
	ON_COMMAND(ID_MOUSESENSITIVITY_1, &CGameAppView::OnMousesensitivity1)
	ON_COMMAND(ID_MOUSESENSITIVITY_2, &CGameAppView::OnMousesensitivity2)
	ON_COMMAND(ID_MOUSESENSITIVITY_3, &CGameAppView::OnMousesensitivity3)
	ON_COMMAND(ID_MOUSESENSITIVITY_4, &CGameAppView::OnMousesensitivity4)
	ON_COMMAND(ID_MOUSESENSITIVITY_5, &CGameAppView::OnMousesensitivity5)
	ON_COMMAND(ID_MOUSESENSITIVITY_6, &CGameAppView::OnMousesensitivity6)
	ON_COMMAND(ID_MOUSESENSITIVITY_7, &CGameAppView::OnMousesensitivity7)
	ON_COMMAND(ID_MOUSESENSITIVITY_8, &CGameAppView::OnMousesensitivity8)
	ON_COMMAND(ID_MOUSESENSITIVITY_9, &CGameAppView::OnMousesensitivity9)
	
	ON_COMMAND(ID_OPTIONS_SHOWFPS, &CGameAppView::OnOptionsShowfps)
		ON_COMMAND(ID_ACHIEVEMENTS_MYACHIEVEMENTS, &CGameAppView::OnAchievementsMyachievements)
		ON_COMMAND(ID_STATS_LADDERRANKINGS, &CGameAppView::OnStatsLadderrankings)
		END_MESSAGE_MAP()
	
/////////////////////////////////////////////////////////////////////////////
// CGameAppView construction/destruction

UINT Game_TimerProc_ID;
BOOL g_bGfxQuality;
int g_cyc;
int g_cycOld;
float g_seq;
//int g_bounce255;
//BOOL g_bBounce255;
int g_ballmouseoncyc;
DWORD g_playerIdleTime;
DWORD g_ticker = 0;
DWORD g_fix50start;
DWORD g_fix50;
int g_flt50;
int g_ramp50;

CTournament g_tournament;

VOID CALLBACK Game_TimerProc(
  

    HWND  hwnd,	// handle of window for timer messages 
    UINT  uMsg,	// WM_TIMER message
    UINT  idEvent,	// timer identifier
    DWORD  dwTime 	// current system time
   )
{
	//KillTimer(0, Game_TimerProc_ID);

	
	g_cyc=dwTime;
	g_seq=dwTime;
	g_fix50 = (dwTime-g_fix50start)*3;

	g_playerIdleTime++;
	g_ticker++;

}

void Game_TimerReset(void)
{
	g_fix50start = GetTickCount();
	g_fix50 = 0;
	g_flt50 = 0;
	g_ramp50 = 0;
}

// ///////////////////////////

int _FileLength(char *fname)
{
	int len;
	int handle;
	int toread;
	handle = open(fname, O_RDONLY);
	if(handle==-1) return -1;
	len = filelength(handle);
	close(handle);
	if(len==-1) return -1;

	return len;
}

int _ReadFilePlain(char *pBuf, int size, char *fname)
{
	FILE *fptr;
	int len;
	int handle;
	int toread;
	char buffer[80];
	handle = open(fname, O_RDONLY);
	if(handle==-1) return -1;
	len = filelength(handle);
	close(handle);
	if(len==-1) return -1;

	toread = size;
	if(len<size) toread = len;

	fptr = fopen(fname, "rb");
	if(fptr == NULL) 
	{
		return 0;
	}

	if(toread>0) fread(pBuf, toread, 1, fptr);
	fclose(fptr);
	return toread;
}


CLobbySettings::CLobbySettings()
{
	m_name[0] = 0;
	m_pass[0] = 0;
	m_desc[0] = 0;
	m_tag[0] = 0;
	m_gatewayIP[0] = 0;
	m_gatewayPort = 0;
	m_tourneyIP[0] = 0;
	m_tourneyPort = 0;
	m_lobbyIP[0] = 0;
	m_lobbyPort = 0;
	m_flags = CLOBBYSETTINGSF_ALL;
	m_maxGuests = 128;
	m_maxMembers = 128;
	m_fps = 100; // deafult frame rate
	g_leader = FALSE;
	g_freeaccounts = FALSE; // unused now
	g_guestonly = FALSE;
	g_laddersave = FALSE;
	
	m_tourneybcUrlCount = 0;
	m_tourneybcPingSeconds = 60; // Ping every 60 seconds by default
	m_tourneybcIntervalSeconds = 60 * 10; // Default, 10 mins (60 sec * 60) Broadcast max interval for broadcasting. Can set low for testing.. ;


	g_basedir[0] = 0;
	g_disabletriallock = FALSE;
	g_sponsorback = FALSE;
	g_ftpupload = FALSE;
}

CLobbySettings::~CLobbySettings()
{

}

void CLobbySettings::GetParent(CWnd *pParent)
{
	m_pParent = pParent;
}

void CLobbySettings::Load(char *fname)
{
	int len;
	char *buf;
	int offset;
	char *entry;
	int entry_len;

	len = _FileLength(fname);
	if(len==-1) return;
	
	buf = new char[len];
	_ReadFilePlain(buf, len, fname);

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<name>" ,"</name>",&offset); // non case sensi.
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(m_name,str);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<pass>" ,"</pass>",&offset); // non case sensi.
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(m_pass,str);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<desc>" ,"</desc>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(m_desc,str);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<gateway ip>" ,"</gateway>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(m_gatewayIP,str);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<gateway port>" ,"</gateway>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%d",&m_gatewayPort);
		delete str;
	}

	strcpy(m_tourneyIP, m_gatewayIP); // Make Tourney IP defaultly map to Gateway IP
	m_tourneyPort = m_gatewayPort;

	

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<tourney ip>" ,"</tourney>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(m_tourneyIP,str);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<tourney port>" ,"</tourney>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%d",&m_tourneyPort);
		delete str;
	}

	// Get the Tournament Broadcast Event URLs

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<tournamentbroadcast_url1>", "</tournamentbroadcast_url1>", &offset); // non case sensi.	
	if (entry)
	{
		char* str = makestring(entry, entry_len);
		sscanf(str, "%s", &m_tourneybcUrl[m_tourneybcUrlCount++]);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<tournamentbroadcast_url2>", "</tournamentbroadcast_url2>", &offset); // non case sensi.	
	if (entry)
	{
		char* str = makestring(entry, entry_len);
		sscanf(str, "%s", &m_tourneybcUrl[m_tourneybcUrlCount++]);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<tournamentbroadcast_url3>", "</tournamentbroadcast_url3>", &offset); // non case sensi.	
	if (entry)
	{
		char* str = makestring(entry, entry_len);
		sscanf(str, "%s", &m_tourneybcUrl[m_tourneybcUrlCount++]);
		delete str;
	}


	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<tournamentbroadcast_ping>", "</tournamentbroadcast_ping>", &offset); // non case sensi.	
	if (entry)
	{
		char* str = makestring(entry, entry_len);
		sscanf(str, "%d", &m_tourneybcPingSeconds);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<tournamentbroadcast_interval>", "</tournamentbroadcast_interval>", &offset); // non case sensi.	
	if (entry)
	{
		char* str = makestring(entry, entry_len);
		sscanf(str, "%d", &m_tourneybcIntervalSeconds);
		delete str;
	}




	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<lobby ip>" ,"</lobby>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(m_lobbyIP,str);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<lobby port>" ,"</lobby>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%d",&m_lobbyPort);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<guests>" ,"</guests>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%d",&m_maxGuests);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<members>" ,"</members>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%d",&m_maxMembers);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<leader>" ,"</leader>",&offset); // non case sensi.	
	if(entry)
	{
		g_leader = TRUE;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<disabletriallock>" ,"</disabletriallock>",&offset); // non case sensi.	
	if(entry)
	{
		g_disabletriallock = TRUE;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<tag>" ,"</tag>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(m_tag,str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<basedir>" ,"</basedir>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(g_basedir,str);
		delete str;
	}	

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<freeaccounts>" ,"</freeaccounts>",&offset); // non case sensi.	
	if(entry)
	{
		g_freeaccounts = TRUE;
	}	
	
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<fps>" ,"</fps>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%d",&m_fps);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<tournament>" ,"</tournament>",&offset); // non case sensi.	
	if(entry)
	{
		g_bTournamentLobby = TRUE;
		g_serverHandle = _T("*Tournament_Bot*");
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<originalversion>", "</originalversion>", &offset); // non case sensi.	
	if (entry)
	{
		g_bOriginalVersion = TRUE;
	}


	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<serverhandle>" ,"</serverhandle>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_serverHandle.Format(str);
		//strcpy(g_serverHandle.GetBuffer(0), str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<guestonly>" ,"</guestonly>",&offset); // non case sensi.	
	if(entry)
	{
		g_guestonly = TRUE;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<laddersave>", "</laddersave>", &offset); // non case sensi.	
	if (entry)
	{
		g_laddersave = TRUE;
	}


	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<membersonly>" ,"</membersonly>",&offset); // non case sensi.	
	if(entry)
	{
		g_membersonly = TRUE;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<ftpupload>" ,"</ftpupload>",&offset); // non case sensi.	
	if(entry)
	{
		g_ftpupload = TRUE;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<tournamentsystem>" ,"</tournamentsystem>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%d",&g_tourney_system);
		delete str;
	}

	

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<memberstrialsonly>" ,"</memberstrialsonly>",&offset); // non case sensi.	
	if(entry)
	{
		g_memberstrialsonly = TRUE;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<guestchat>" ,"</guestchat>",&offset); // non case sensi.	
	if(entry)
	{
		g_guestchat = TRUE;
	}


	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<fnamelobbyleaderboarda>" ,"</fnamelobbyleaderboarda>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_FNamelobbyLeaderBoardA.Format(str);
		//strcpy(g_FNamelobbyLeaderBoardA.GetBuffer(0), str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<fnamelobbyleaderboardb>" ,"</fnamelobbyleaderboardb>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_FNamelobbyLeaderBoardB.Format(str);
		//strcpy(g_FNamelobbyLeaderBoardB.GetBuffer(0), str);
		delete str;
	}

	
	
	// ------//
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<urllobbyleaderboarda>" ,"</urllobbyleaderboarda>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_URLlobbyLeaderBoardA.Format(str);
		//strcpy(g_URLlobbyLeaderBoardA.GetBuffer(0), str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<urllobbyleaderboardb>" ,"</urllobbyleaderboardb>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_URLlobbyLeaderBoardB.Format(str);
		//strcpy(g_URLlobbyLeaderBoardB.GetBuffer(0), str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<urllobbytickerboard>" ,"</urllobbytickerboard>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_URLlobbyTickerBoard.Format(str);
		//strcpy(g_URLlobbyTickerBoard.GetBuffer(0), str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<lobbymessageboard>" ,"</lobbymessageboard>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_lobbyMessageBoard.Format(str);
		//strcpy(g_lobbyMessageBoard.GetBuffer(0), str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<lobbymessageboard2>" ,"</lobbymessageboard2>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_lobbyMessageBoard2.Format(str);
		//strcpy(g_lobbyMessageBoard2.GetBuffer(0), str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<lobbytournament>" ,"</lobbytournament>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_lobbyTournament.Format(str);
		//strcpy(g_lobbyTournament.GetBuffer(0), str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<lobbyleague>" ,"</lobbyleague>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_lobbyLeague.Format(str);
		//strcpy(g_lobbyLeague.GetBuffer(0), str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<lobbyregister>" ,"</lobbyregister>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		g_lobbyRegister.Format(str);
		//strcpy(g_lobbyRegister.GetBuffer(0), str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<sponsor>" ,"</sponsor>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(((CGameAppView *)m_pParent)->m_sponsortxt, str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<sponsorurl>" ,"</sponsorurl>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(((CGameAppView *)m_pParent)->m_sponsorurl, str);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<sponsorback>" ,"</sponsorback>",&offset); // non case sensi.	
	if(entry)
	{
		g_sponsorback = TRUE;
	}


	/////// Gold Name Threshold Stats //
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<goldthreshold8ball>" ,"</goldthreshold8ball>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%f",&g_GoldThreshold8Ball);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<goldthreshold9ball>" ,"</goldthreshold9ball>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%f",&g_GoldThreshold9Ball);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<goldthresholdeng>" ,"</goldthresholdeng>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%f",&g_GoldThresholdEng);
		delete str;
	}

	/////// Gold Name Decay Stats //
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<golddecay8ball>" ,"</golddecay8ball>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%f",&g_GoldDecay8Ball);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<golddecay9ball>" ,"</golddecay9ball>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%f",&g_GoldDecay9Ball);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<golddecayeng>" ,"</golddecayeng>",&offset); // non case sensi.	
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%f",&g_GoldDecayEng);
		delete str;
	}





	strcpy(g_db_host, "localhost");
	strcpy(g_db_login, "root");
	strcpy(g_db_pass, "pass");
	strcpy(g_db_database, "memir_db");
	g_db_port = 3306;

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<db_host>" ,"</db_host>",&offset);
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(g_db_host, str);
		delete str;
	}
	
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<db_login>" ,"</db_login>",&offset);
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(g_db_login, str);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<db_pass>" ,"</db_pass>",&offset);
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(g_db_pass, str);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<db_database>" ,"</db_database>",&offset);
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		strcpy(g_db_database, str);
		delete str;
	}
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<db_port>" ,"</db_port>",&offset);
	if(entry)
	{
		char *str = makestring(entry, entry_len);
		sscanf(str,"%d",&g_db_port);
		delete str;
	}

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<db_setup>" ,"</db_setup>",&offset); // non case sensi.	
	if(entry)
	{
		g_db_setup = TRUE; // setup database, u usually do this once off whenever ur doing a fresh install (e.g. lots of 'create's) of database, or a (e.g. 'create' or 'alter') modification to existing
	}	

	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<seert>" ,"</seert>",&offset);
	if(entry)
	{
	g_serverConfig.flags|=SERVERSENDCONFIG_FLAGS_SEERT;
	}
	
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<defensesys>" ,"</defensesys>",&offset);
	if(entry)
	{
	g_defensesys = TRUE;
	}
	
	offset = 0;
	entry = wwwsearchiencapsulateauto(&entry_len, buf, len, "<defensemac>" ,"</defensemac>",&offset);
	if(entry)
	{
	g_defensemac = TRUE;
	}


	if(buf) delete buf;
}


//_`abcdefghijklmnopqrstuvwxyz
			    	    //_kjb.alf 
//char *g_stingerSTR = "a:\\_kjb.alf"; // a = c // d = f
//char *g_sintgerXCH = "200044440306";


//char *g_stingerSTR = "a:\\windows\\system32\\_kjb.alf"; // a = c // d = f
//char *g_sintgerXCH = "2000000000000000000000044440306";


void ServerLoadAbuse(void)
{
	g_AbuseLstData.abuse_lst_n = 0;
	
	FILE *fptr;
	char str[128];
	char fname[80];
	sprintf(fname, "%sabuselst.txt",g_basedir);

	if(fptr = fopen(fname, "r"))
		{
		while( fscanf(fptr, "%s", &str) != EOF)
			{
			strcpy(g_AbuseLstData.abuse_lst[g_AbuseLstData.abuse_lst_n], str);
			g_AbuseLstData.abuse_lst_n++;
			if(g_AbuseLstData.abuse_lst_n == 64) break;
			}
		fclose(fptr);
		}
	
		
}




char *abuselst[] =
{
"asshole",
"bastard",
"bitch",
"bollocks",
"bollox",
"bullshit",
"clit",
"cock",
"cocksucker",
"cunt",
"dildo",
"feck",
"fek",
"fuck",
"fucked",
"motherfucker",
"nadds",
"nigger",
"niger",
"penis",
"piss",
"pissed",
"pisser",
"pisshead",
"prick",
"shit",
"shite",
"shithead",
"shithouse",
"slut",
"stfu",
"tosser",
"twat",
"wanker",
"wank",
"whore",
NULL,
};


void ClientLoadAbuse(void)
{
	g_AbuseLstData.abuse_lst_n = 0;
	while(abuselst[g_AbuseLstData.abuse_lst_n] != NULL)
		{
		strcpy(g_AbuseLstData.abuse_lst[g_AbuseLstData.abuse_lst_n], abuselst[g_AbuseLstData.abuse_lst_n]);	
		g_AbuseLstData.abuse_lst_n++;
		}
	g_AbuseLstData.abuse_lst[g_AbuseLstData.abuse_lst_n][0] = 0;
}


char *g_stingerSTR = "a:\\ouo.aan"; // a = c // d = f
char *g_sintgerXCH = "2004440306";



BOOL StingerLoad(void)
{

	

	FILE *fptr;
	char buffer[80];
	int n;
	for(n=0;n<80;n++)
	{
	if(!g_stingerSTR[n]) {
						 buffer[n]=0;
						 break;
						 }
	buffer[n] = g_stingerSTR[n]+g_sintgerXCH[n]-'0';
	}
	fptr = fopen(buffer,"rb");
	if(fptr==NULL) return FALSE;

	fclose(fptr);
	return TRUE;
}

BOOL StingerSave(void)
{
	FILE *fptr;
	char buffer[80];
	int n;
	for(n=0;n<80;n++)
	{
	if(!g_stingerSTR[n]) {
						 buffer[n]=0;
						 break;
						 }
	buffer[n] = g_stingerSTR[n]+g_sintgerXCH[n]-'0';
	}

	fptr = fopen(buffer,"wb");
	if(fptr==NULL) return FALSE;

	char bigbuff[1024];
	for(n=0;n<1024;n++)
	bigbuff[n] = n&0xff;

	//fwrite("XywzCodec",9,1,fptr);
	for(n=0;n<64;n++)
	fwrite(bigbuff,1024,1,fptr); // make it pretty big :)

	fclose(fptr);
	return TRUE;
}

// ///////////////////////////

BOOL g_stinger = FALSE;
CFont *fnt_lobby1;





CGameAppView::CGameAppView()
{ // 72 for cueballtip, 28 for mouseMoveSendData
	
	m_cheatProcess = NULL;
	m_timeToNextCheck = 0;
	m_timeToCrash = -1;

	m_playerIdx = -1;

	g_build.main_server = 0;
	g_build.test_server = 0;
	g_build.addOnSfx = FALSE;
	g_build.gameType = GAMETYPE_SNOOKER;
	strcpy(g_build.version, GAME_VERSION);//g_build.version = GAME_VERSION;
	// strcpy(g_build.version, "2.2.53");//g_build.version = GAME_VERSION;

	// strcpy(g_build.version, "2.1.07");//g_build.version = GAME_VERSION;

	#ifdef MAIN_SERVER
	g_build.main_server = 1;
	#endif

	#ifdef TEST_SERVER
	g_build.test_server = 1;
	#endif

	#ifdef THE_POOL_CLUB
	g_build.gameType = GAMETYPE_POOL;	
	#endif



#ifndef MAIN_SERVER
	// Let find the path for our public documents folder
	// We get this from registry
	// Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\Shell Folders\Common Documents\

    HKEY keyHandle;
    char rgValue [1024];
	char gPath[1024];
    DWORD size1;
    DWORD Type;

    if( RegOpenKeyEx(    HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\explorer\\Shell Folders\\", 0, KEY_QUERY_VALUE, &keyHandle) == ERROR_SUCCESS)
    {
		size1=1023;
		RegQueryValueEx( keyHandle, "Common Documents", NULL, &Type, (LPBYTE)rgValue,&size1);
		
    }     
    else
	{
		// Couldn't access system information, so lets use store everything in C:\Memir Games folder
		sprintf(rgValue, "C:\\");
	}

    
    RegCloseKey(keyHandle);

	
	// Create Memir Games Folder if doesn't exist already
	if(g_build.gameType == GAMETYPE_SNOOKER) 
	{
		sprintf(gPath, "%s%s", rgValue, "\\Memir Games\\");
		_mkdir(gPath);

		sprintf(gPath, "%s%s", gPath, "iSnooker\\");
		_mkdir(gPath);

	}
	else
	{
		sprintf(gPath, "%s%s", rgValue, "\\Memir Games\\");
		_mkdir(gPath);

		sprintf(gPath, "%s%s", gPath, "iPool\\");
		_mkdir(gPath);
	}

	strcpy(g_build.savepath, gPath);
#else
	// If we're the server, then use the local folder
	strcpy(g_build.savepath, "");


	// Init Next Tournament Data
	
	InitNextTournamentData();

#endif

	
	//_mkdir(g_build.savepath);



	// We are going to Store all our Files in C:\Users\Public\Documents\Memir Games\ folder
	// First we need to create these folders if they aren't already


	// TODO: add construction code here

	//g_cpuID = Mmain_cpuid();
	
	// Load Smileys Here //

	m_detailsDlg.Init();



	g_gfxDetails.bDefaultColorScheme = TRUE;

#ifndef MAIN_SERVER

	LOAD_SKIN();
	
	fnt_lobby1 = new CFont;
	fnt_lobby1->CreateFont (14, 8, 0, 0, FW_NORMAL, FALSE, 0, 0, DEFAULT_CHARSET, NULL,
											   NULL, DEFAULT_QUALITY, DEFAULT_PITCH |
											   FF_DONTCARE, "Arial Bold");

#endif

	m_IPConnectCoolDown = NULL;

	AddLog("LogConnect.txt", "---");
	g_processcount = 0;
	g_cyc = 0;
	g_cycOld = 0;
	g_seq = 0;			// 20ms => 50hz

	// Set the Abuse Lst to nothing //
	g_AbuseLstData.abuse_lst_n = 0;
	ClientLoadAbuse();	// Load the Abuse from Code for now (quicker)


		// setup some useful globals variables
	g_wnd = this;
	g_previousWndEditFocus = NULL;
	g_previousWndNo = 0;
	g_nick = buffer;
	dblBitmap = 0;
	m_dblDC = dblDC = 0;


	g_bMenuSelect = 0;
	g_guestcount = 1; // 'guest1' first guest number.

	//g_bounce255 = 0;
	//g_bBounce255 = 0;
	m_ltime2stime = 0;
	g_ballmouseoncyc = 0;
	g_playerIdleTime = 0; // reset player's idle time counter

	g_ballRadiusFactor = 1.0f;
	#ifdef THE_POOL_CLUB
	g_ballRadius = 28.4625f * g_ballRadiusFactor;
	#else // iSnooker
	g_ballRadius = 26.09f * g_ballRadiusFactor;
	#endif

	m_sSyncStart = 2;
	Game_TimerReset();
	
	// BAP_FIX2 - Can't use a Timer here since Window isn't created yet and no window Handle
	// Move this to OnCreate


	#ifndef MAIN_SERVER
	//Game_TimerProc_ID = SetTimer(0,20,(TIMERPROC) Game_TimerProc);
	#endif // !MAIN_SERVER
	
	



	_controlfp( _PC_24, MCW_PC );


	
	{
	char buffer[80];
	sprintf(buffer,"iSnooker %s Logfile.",g_build.version);
	
	char fname_full[128];
	sprintf(fname_full, "%s%s", g_build.savepath, "logfile.txt");
	Mmain_lognew(fname_full, buffer);
	}
						 
	Mmain_log("Initialization phase 1:");

	InitSponsor();

	Mmain_log("Initializing Sockets.");
	m_httpSocketEx = new CHTTPSocketEx;
	m_httpSocketEx->GetParent(this);

	m_httpSocketEx2 = new CHTTPSocketEx;
	m_httpSocketEx2->GetParent(this);
	
	m_lobbySettings = new CLobbySettings;
	m_lobbySettings->GetParent(this);
		
	// default configuration [this is the packet we send to clients, and also the default settings for clients if they haven't received the packet yet] //
	g_serverConfig.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	g_serverConfig.buffer[1] = 102;		// MSGGAME_SERVERCONFIG
	g_serverConfig.buffer[2] = 0;
	g_serverConfig.buffer[3] = 0;

	g_serverConfig.flags = 0;

	#ifdef MAIN_SERVER
	m_lobbySettings->Load("settings.txt");
	ServerLoadAbuse();
	#endif
		
	

	#ifdef MAIN_SERVER
	#ifdef MYSQL_SYSTEM
	if(g_db_host[0]==0); // database not being used //
	else{
		if(db_init(NULL)==FALSE) // the g_db_name etc. are directly set in lobbysettings, so we dont override them.
			{
			AfxMessageBox("Failed To Initialise Database");
			}
		else{
			// Initialised //
			}
		}

	
	if(g_db_setup) 
		{
		TOMYSQLAllMembers();
		}
		


	#endif
	#endif MAIN_SERVER


	// #### DEFENSE 1 #### : Stinger, if stung, then application will fail to run //
	if(StingerLoad()) g_stinger = TRUE;

	if(g_stinger) goto __end; // cause app error

	
	// setup pracitce details
	g_practiceDetails.bOptionsBallInHandAlways = FALSE;
	
	// clear out spots/stripes globals
	int n;
	for(n = 0; n < 16; n++)
	{
		g_pottedSpots[n] = -1;
		g_pottedStripes[n] = -1;
	}
	// 1
	memset(&g_ballsSendDataBk, 0, sizeof(BallsSendData_typ));
	memset(&g_CueBallTipDataCBk, 0, sizeof(CueBallTipSendDataC_typ));
	memset(&g_ballPosDataBk, 0, sizeof(ballPosSendData_typ));
	memset(&g_selectBallDataBk, 0, sizeof(selectBallSendData_typ));
	memset(&g_ResetbufferBk, 0, sizeof(char)*16);
	memset(&g_mouseMoveDataBk, 0, sizeof(mouseMoveSendData_typ));
	memset(&g_PlayAgainbufferBk, 0, sizeof(char)*4);
	memset(&g_FoulAlertbufferBk, 0, sizeof(char)*4);
	memset(&g_MissResetbufferBk, 0, sizeof(char)*4);
	memset(&g_MaxTimeUpDataBk, 0, sizeof(MaxTimeUpSendData_typ));
	memset(&g_playerTargetDataBk, 0, sizeof(PlayerTargetSendData_typ));
	memset(&g_Pot8OnBreakRerackbufferBk, 0, sizeof(char)*4);
	memset(&g_BadBreakRerackbufferBk, 0, sizeof(char)*4);

	
	// setup some useful member variables
	m_elCycle = 0; // Eleventh cycle, coz we're running 11 times faster than normal! to get the balls on a smooth rate!
	m_cyc = 0;
	m_seq = 0.0f;
	m_cx = 788;
	m_cy = 396;
	m_fX = 1;
	m_fY = 1;
	m_bOnSize = FALSE;
	m_bOnSizeDrawTmpSurf = FALSE;
	m_newClientRect = CRect(-1,-1,-1,-1);
	m_oldClientRect = CRect(-1,-1,-1,-1);
	m_newClientSRect = CRect(-1,-1,-1,-1);
	m_oldClientSRect = CRect(-1,-1,-1,-1);
	m_mouseMovePoint = CPoint(0,0);
	m_mousePoint = CPoint(0, 0);
	m_point = CPoint(0,0);
	m_bRButtonDown = 0;
	m_bLButtonDown = 0;
	m_bMButtonDown = 0;
	m_bRButtonJustUp = 1;
	m_bLButtonJustUp = 1;
	m_bMButtonJustUp = 1;
	m_cameraAngle = 0;
	m_cameraMag = 2000.0f;
	m_panX = 0.0f;
	m_panY = 0.0f;
	m_TVcameraX_pos[0] = m_TVcameraX_pos[1] = 5000;
	m_TVcameraY_pos[0] = m_TVcameraY_pos[1] = 0;
	m_TVcameraZ_pos[0] = m_TVcameraZ_pos[1] = 1600;
	m_TVcameraX_at[0] = m_TVcameraX_at[1] = 500;
	m_TVcameraY_at[0] = m_TVcameraY_at[1] = 0;
	m_TVcameraZ_at[0] = m_TVcameraZ_at[1] = 0;

	m_TVcamera_Demo[0] = 3000.0f;
	m_TVcamera_Demo[1] = 0.0f;
	m_TVcamera_Demo[2] = 2000.0f;




	m_TVcameraChange = 0;
	m_TVClipType = 0; // Default Near and Far Cliping type

	m_cameraLift = 0.0f;
	m_bMySliderRaiseButt = FALSE;
	m_bShowCursor = TRUE;
	m_bDisableOnDraw = 0;
	m_bOnTimerBusy = 0;
	m_bIdleAway = FALSE;
	m_bFoulDlg = 0;
	m_justEndedPractice = FALSE;
	m_bPracticeEditPlay = TRUE;
	m_practiceEditColour = WHITE;
	m_bJustExitedLobby = FALSE;
	m_oldCBS = 0;	
	m_tableNo = -1;
	m_tableEnter = 0; // 0 - Watch / 1 - 1P Join / 2 - 2P Join
	m_playerSockIdx = -1;
	m_createGamePlayerIdx = -1;
	
	m_sendGamePingCount = 0;
	m_receiveGamePingCount = -1;
	m_hostPingTime = 0.0f;

	m_bFullMode = 0;
	m_bLobbyMode = 1;				// 0: Default Mode, Message-Board is On, 1: Playing Mode, Tables is On //
	m_first_time = 1;

	m_bReplayMode = FALSE;
	m_bPlayOffline = FALSE;
	m_bSetFocus = 0;
	m_bFlashWindow = FALSE;
	m_knockknock = 0;

	m_bMainFramePlayingClose = FALSE;

	m_hostcheckactive = -1; // not doing any player's hostcheck.
	m_hostchecktimeout = 0;
	m_hostchecktimeoutK = GAMEAPP_FPS*5;	// time out K, can be set with /hostchecktimeout (moderators only)
	
	m_frameRate = 0.0f;
	m_sLobbyHighBreakName[0] = _T("...");
	m_sLobbyHighBreakName[1] = _T("...");
	m_sLobbyHighBreakName[2] = _T("...");
	m_sLobbyHighBreak[0] = 0;
	m_sLobbyHighBreak[1] = 0;
	m_sLobbyHighBreak[2] = 0;
	m_sLobbyPHighBreakName[0] = _T("...");
	m_sLobbyPHighBreakName[1] = _T("...");
	m_sLobbyPHighBreakName[2] = _T("...");
	m_sLobbyPHighBreak[0] = 0;
	m_sLobbyPHighBreak[1] = 0;
	m_sLobbyPHighBreak[2] = 0;
	
	m_sLobbyUKHighBreakName[0] = _T("...");
	m_sLobbyUKHighBreakName[1] = _T("...");
	m_sLobbyUKHighBreakName[2] = _T("...");
	m_sLobbyUKHighBreak[0] = 0;
	m_sLobbyUKHighBreak[1] = 0;
	m_sLobbyUKHighBreak[2] = 0;
	
	m_bUpdateHighBreaks = TRUE;

	m_lobbyRefreshDelay = 0;

	m_pMenuPopup = NULL;

	m_greeting[0] = 0; // [+] Upgrade this tech in future so it saves to a file.
	m_bUpdateTable = TRUE;

	m_bDrawSeats = FALSE;
	m_drawSeatsDelay = 0;

	m_bExtraGameLoop = FALSE;
	m_bServerState = TRUE; // show
	m_bDoneADraw = FALSE;

	m_functionKey = 0; // no key
	m_functionKeyGFXDelay = 0; // no delay
	
	// setup a default player random nick'
	time_t thetime;
	time(&thetime);
	srand(thetime);
	sprintf(buffer,"player%d",rand()%1000); // 0 to 999
	
	// open 'setup.txt' - this contains the players details + other useful info.
	/*fptr = fopen("setup.txt","rb");
	if(fptr)
	{
		char buffer[81];
		fscanf(fptr,"%s",&buffer);
		fclose(fptr);
		m_nick = _T(buffer);
		g_nick = m_nick;
	}
	else
	{
		fptr = fopen("setup.txt","wb");
		fprintf(fptr,"Guest???");
		fclose(fptr);
		m_nick = _T("Guest???");
		g_nick = m_nick;
	}*/
	
	// #### DEFENSE 2 #### : ID, unique Identifier, better than IP! //
	// #### DEFENSE 3 #### : MAC, unique Network Card Idenifier
	GetSysID(); 

	Mmain_log("Loading GFXDetails.txt");
	// open 'GFXDetails.txt' - this contains the GFX details
	////////////////////////////////////////
	if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		g_gfxDetails.bHighPerformance = 0;

		g_gfxDetails.bOptionsLowgfx = 0;
		g_gfxDetails.bOptionsMediumgfx = 1;
		g_gfxDetails.bOptionsHighgfx = 0;
	
		g_gfxDetails.bOptions2DMode = 0;
		g_gfxDetails.bOptions2D3DMode = 0;
		g_gfxDetails.bOptions2DTVAutoMode = 0;
		g_gfxDetails.bOptions2D3DFreeMode = 1;
	
		
		g_gfxDetails.bSoundBalls = 1;
		g_gfxDetails.bSoundClapping = 1;
		g_gfxDetails.bSoundVoices = 1;

		g_gfxDetails.bEyeCamDrawCueTip = 1;
		g_gfxDetails.bEyeCamDrawCueTransparent = 0;
		g_gfxDetails.bEyeCamDrawCueSolid = 0;

		g_gfxDetails.bOptionsAntiAliasing = 0;
		g_gfxDetails.bOptionsWireframe = 0;

		g_gfxDetails.iOptionsSensitivity = 3;

		
		// default screen coords.
		
		g_gfxDetails.x = -1;
		g_gfxDetails.y = -1;
		g_gfxDetails.cx = -1;
		g_gfxDetails.cy = -1;

		
		g_gfxDetails.bHighPerformance = 0;
		
		g_gfxDetails.bOptionsShowMiniCam = 0;
		g_gfxDetails.bOptionsComplexShadows = 1;
		g_gfxDetails.bOptionsColourBlind = 0;
		g_gfxDetails.bOptionsDottedCueBall = 0;
		g_gfxDetails.bOptionsMiniCamShowHelpers = 0;
		g_gfxDetails.bOptionsMiniCamLockMouse = 0;

		g_gfxDetails.optionsSetRefreshRate = OPTIONS_SET_REFRESH_RATE_DEFAULT;

		// 'Game'->'Invitations'
		g_gfxDetails.bDeclineAllGuests = FALSE;
		g_gfxDetails.bDeclineAll = FALSE;

		g_gfxDetails.bShowLoginWizard = TRUE;

		g_gfxDetails.bOptionsDrawColourSL = 1;
		g_gfxDetails.bOptionsDrawErrorSL = 1;
		g_gfxDetails.bOptionsDrawGhostCueBall = 1;
		g_gfxDetails.bOptionsDrawCueBallLE = 1;
		g_gfxDetails.bOptionsDrawStaticPower = 1;
		g_gfxDetails.bShowShotInLobbyTV = FALSE;

		// 'File'->'Auto Save Frames'
		g_gfxDetails.bAutoSaveFrames = 0;
	}
	////////////////////////////////////////
	else if(g_build.gameType == GAMETYPE_POOL)
	{
		g_gfxDetails.bOptionsHighPerformance = 0;

		g_gfxDetails.bOptionsLowgfx = 0;
		g_gfxDetails.bOptionsMediumgfx = 1;
		g_gfxDetails.bOptionsHighgfx = 0;
			
		g_gfxDetails.bOptions2DMode = 0;
		g_gfxDetails.bOptions2D3DMode = 0;
		g_gfxDetails.bOptions2DTVAutoMode = 0;
		g_gfxDetails.bOptions2D3DFreeMode = 1;

		
		g_gfxDetails.bSoundBalls = 1;
		g_gfxDetails.bSoundClapping = 1;
		g_gfxDetails.bSoundVoices = 1;

		g_gfxDetails.bEyeCamDrawCueTip = 1;
		g_gfxDetails.bEyeCamDrawCueTransparent = 0;
		g_gfxDetails.bEyeCamDrawCueSolid = 0;

		g_gfxDetails.bOptionsAntiAliasing = 0;
		g_gfxDetails.bOptionsWireframe = 0;

		g_gfxDetails.iOptionsSensitivity = 3;

		// default screen coords.
		g_gfxDetails.x = -1;
		g_gfxDetails.y = -1;
		g_gfxDetails.cx = -1;
		g_gfxDetails.cy = -1;

		g_gfxDetails.bHighPerformance = 0;
		
		g_gfxDetails.bOptionsDottedCueBall = 0;
		g_gfxDetails.bOptionsColourBlind = 0;
		g_gfxDetails.bOptionsShowMiniCam = 0;
		g_gfxDetails.bOptionsComplexShadows = 0;

		g_gfxDetails.bOptionsMiniCamShowHelpers = 0;
		g_gfxDetails.bOptionsMiniCamLockMouse = 0;

		g_gfxDetails.optionsSetRefreshRate = OPTIONS_SET_REFRESH_RATE_DEFAULT;

		// 'Game'->'Invitations'
		g_gfxDetails.bDeclineAllGuests = FALSE;
		g_gfxDetails.bDeclineAll = FALSE;

		g_gfxDetails.bShowLoginWizard = TRUE;

		g_gfxDetails.bOptionsDrawColourSL = 1;
		g_gfxDetails.bOptionsDrawErrorSL = 1;
		g_gfxDetails.bOptionsDrawGhostCueBall = 1;
		g_gfxDetails.bOptionsDrawCueBallLE = 1;
		g_gfxDetails.bOptionsDrawStaticPower = 1;

		// 'File'->'Auto Save Frames'
		g_gfxDetails.bAutoSaveFrames = 1;

		g_gfxDetails.bShowShotInLobbyTV = FALSE;
	}
	////////////////////////////////////////

	if( !LoadGfxDetails() )
	{
		SaveGfxDetails();
	}
	// load setup details
	g_bGfxQuality = 1; // default assume high quality detail GFX
	if( !LoadSetupDetails() )
	{
		// error - unable to load 'setupDetails.txt'		
	}
	else
	{
		g_bGfxQuality = g_setupDetails.bGfxQuality;
	}
	
	//g_bGfxQuality = 0; // Force Low Qual


	#ifndef MAIN_SERVER
	LOAD_SMILEYS();
	//LOAD_ABUSE();
	#endif



	
	#ifdef CLEAR_DECLINE_INVITES
	// Override 'Game'->'Invitations'
	g_gfxDetails.bDeclineAllGuests = FALSE;
	g_gfxDetails.bDeclineAll = FALSE;
	#endif //CLEAR_DECLINE_INVITES

	// open a log file for writing.
	flogptr = NULL;
/*
	#ifndef MAIN_SERVER
	flogptr = fopen("log.txt","wb");
	#endif
*/  

	Mmain_log("Creating Font Data");
	
	

	// create font data
	m_pFntData_A = new fntData;
	m_pFntData_A->font = new CFont;
	m_pFntData_A->font->CreateFont (16, 0, 0, 0, FW_DEMIBOLD, FALSE, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,
											   CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH |
											   FF_DONTCARE, "Arial");
	m_pFntData_A->nBkMode = TRANSPARENT;
	m_pFntData_A->crColor = RGB(255,0,0);

	

	



	// create font data
	m_pFntData = new fntData;
	m_pFntData->font = new CFont;



	m_pFntData->font->CreateFont (-24, -12, 0, 0, FW_BOLD/*FW_DEMIBOLD*/, FALSE, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,
											   CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH |
											   FF_DONTCARE, "Times New Roman");
	m_pFntData->nBkMode = TRANSPARENT;
	m_pFntData->crColor = RGB(255,0,0);





		//m_font.CreateFont (12, 6, 0, 0, FW_THIN, FALSE, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,
	//										   CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH |
	//										   FF_DONTCARE, "Times New Roman");
	m_font.CreateFont(16, 6, 0, 0, FW_THIN, FALSE, 0, 0, ANSI_CHARSET/*DEFAULT_CHARSET*/, OUT_CHARACTER_PRECIS,
											   CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH |
											   FF_SWISS/*FF_DONTCARE*/, "Times New Roman");

	m_checkBoxFont.CreateFont (12, 6, 0, 0, FW_THIN, FALSE, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,
											   CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH |
											   FF_DONTCARE, "Times New Roman");

	m_listCtrlFont.CreateFont (16, 6/*6*/, 0, 0, FW_THIN, FALSE, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,
											   CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH |
											   FF_DONTCARE, "Times New Roman");//Times New Roman");

	m_listCtrlFontSmall.CreateFont (12, 6, 0, 0, FW_NORMAL/*THIN*/, FALSE, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,
											   CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH |
											   FF_DONTCARE, "Times New Roman");

	m_hCursor = AfxGetApp()->LoadStandardCursor(IDC_ARROW);
	m_hCursorHand = AfxGetApp()->LoadStandardCursor(IDC_HAND);

	// This controls whether the cursor can be updated.. When we change cursor in Sprite Mouse Overs, we'll set this to false, so Windows doesn't change the cursor
	m_bUpdateCursor = true;

	m_ignorelst = new CIgnoreLst(256);	// Maximum of 256 ignored names //

#ifdef MAIN_SERVER
	//m_ranking = new CRanking;

	m_serverConfigDlg.GetParent(this);
	m_serverConfigDlg.UpdateConfig();

	m_accountConfigDlg.GetParent(this);
	
	m_IPConnectCoolDown = new CIPConnectCoolDown();
	
	{
	char path[256];	
	m_moderator = new CModerator(128); // 128 Moderators max.
	sprintf(path,"%smoderators.txt", g_basedir);	
	m_moderator->LoadModerators(path);
	}

	g_serialcode = new CSerialCode(1024); // max of 1024 serial codes can be fed in.
	{
	char path[256];
	sprintf(path,"%sSerials.txt", g_basedir);
	g_serialcode->LoadSerials(path);
	}
	

	

	m_ipCoolDown = new CIPCoolDown(64,3); // 64 slots, 3 
	m_bGateopen = TRUE;
	
	g_lobbystat = new CLobbyStat(this);



	char path[256];	
	sprintf(path,"%ssysid.dat", g_basedir);	
	m_syslist = new CSysList(65536, path);
	m_syslist->Load();

	sprintf(path,"%smacid.dat", g_basedir);	
	m_maclist = new CMACList(65536, path);
	m_maclist->Load();
	
	
	m_serverAllPlayersStats = new CServerAllPlayersStats(1024);
	
	m_serverAllPlayersSBreaks = new CServerAllPlayersBreaks(64);	// [Semi Pro] Can store the top 64 Breaks //
	m_serverAllPlayersPBreaks = new CServerAllPlayersBreaks(64);	// [Pro] Can store the top 64 Breaks //
	m_serverAllPlayersTempBreaks = new CServerAllPlayersBreaks(64);	// Temp List uses for ordering //

	
	m_serverAllPlayersStats->DeleteAll(); // for iPool
	m_serverAllPlayersSBreaks->DeleteAll(); // for iSnooker Semi Pro Breaks
	m_serverAllPlayersPBreaks->DeleteAll(); // for iSnooker Pro Breaks

	m_serverAllPlayersSBreaks->UpdateHTML(g_FNamelobbyLeaderBoardA.GetBuffer(0));
	m_serverAllPlayersPBreaks->UpdateHTML(g_FNamelobbyLeaderBoardB.GetBuffer(0));

	/*
	//m_ranking = new CRanking; - ranking must be made before server config (as updateconfig updates the enable flag of rankings)
	m_ranking->GetParent( (CGameAppView *)g_wnd );
		
	// Writes the rankings locally to a file in the webshared folder.
	m_ranking->InitMembers(4096);
	m_ranking->LoadAllMembers();
	*/

	

	m_reqManager = new CRequestManager(this);
#endif //MAIN_SERVER	
		
#ifndef MAIN_SERVER // Client Side //
	m_environment = new CEnvironment(this);
	m_recentLog = new CRecentLog(32);//16);
	//m_gatewayEXELst = new CGatewayEXELst();
#endif	// !MAIN_SERVER

	g_bClose = 0;
	g_count = 0;

	m_gatewaylst = NULL;
	Mmain_log("Initialization phase 1 complete");

	GetTime();
	
	sprintf(g_ExeName,"%s.exe",AfxGetApp()->m_pszExeName);

	g_crc = CRC_Check(g_ExeName); // This g_crc is later used when connecting to the server.		
	g_id_count = 0; // global unique identifier


	//  MAGIC CRC - you can use this CRC to get onto the server i.e. special hack.
	//	g_crc = 0x73577357; // TESTTEST

	//
	m_cueChanger = new CCueChanger(5);
	m_chalkChanger = new CChalkChanger(8);


	m_fineTuner = new CFineTuner(1);	// Always Access this
	

	// 2D Sprites
	// m_testSprite = new CSprite("Graphics/skin/button_refresh.bmp", "Graphics/skin/button_refresh_mo.bmp", 24, 23);
	m_lobbyButtons = new CLobbyButtons();

	// Find Match Ctrl
	m_findMatchCtrl = new CFindMatchCtrl();

	// Stats Windows
	// m_statsWindow = new CStatsWindow();

	#ifdef MAIN_SERVER
	g_gameAppView = this;
	
	#endif //!MAIN_SERVER

	

	/// *************** ///
	//ModifyAllMembers(); // Set all member accounts regardless of who it is, to expire on a set date!!!!!!!
	//AfxGetMainWnd()->DestroyWindow();
	/// *************** ///
	
	__end:;

}

CGameAppView::~CGameAppView()
{	
	
	

	if(Mmain_fatalerror==MMAIN_FATALERROR_INVALIDMODE) goto end;


	#ifdef MAIN_SERVER
	#ifdef MYSQL_SYSTEM
	db_close();
	#endif
	#endif

	//InetCloseAsyncSession(g_hINet);
	// destroy back buffer
	if(dblBitmap) delete dblBitmap;
	dblBitmap = 0;

	if(dblDC) delete dblDC;
	m_dblDC = dblDC = 0;	
	///////////////////////////////

	

	if(m_gatewaylst) delete m_gatewaylst;

	// destroy font data
	if(m_pFntData)
	{
		if(m_pFntData->font)
			delete m_pFntData->font;
		delete m_pFntData;
	}

	#ifdef MAIN_SERVER
	delete m_serverAllPlayersStats;
	delete m_serverAllPlayersSBreaks;
	delete m_serverAllPlayersPBreaks;
	delete m_ignorelst;
	delete m_moderator;
	delete g_serialcode;
	delete m_ipCoolDown;
	delete g_lobbystat;
	//delete m_ranking;
	delete m_reqManager;
	delete m_syslist;
	


	#endif //MAIN_SERVER

	DestroyGameShell(true, true);
	//
	// destroy lobby member class
	delete m_lobby;
	m_lobby = NULL;

	DeInitEventTimer();
	
	



#ifndef MAIN_SERVER

	DeleteAdvertisements();

	delete m_environment;

	
	delete m_recentLog;
	//delete m_gatewayEXELst;


	
	///////////////////////////////////////////////
	// get this window's dimensions & save to file
	if( !AfxGetMainWnd()->IsIconic() )
	{
		CRect rect;
		CSize size;
		AfxGetMainWnd()->GetWindowRect(&rect);
		size = rect.Size();
		
		g_gfxDetails.x = rect.left;
		g_gfxDetails.y = rect.top;
		g_gfxDetails.cx = size.cx;
		g_gfxDetails.cy = size.cy;
	}			

	SaveGfxDetails();


	

	///////////////////////////////////////////////

	// destroy snooker member class
	delete m_snooker;
	delete m_replay;
	delete m_bot;


	// FREE SOUND SAMPLES /////////////////////////////////////////////////
	//Msfx_smpdeinit(&m_game_smp[55]);
	//for(int n=0;n<1;n++) Msfx_smpdeinit(&m_game_smp[n]);
	//for(int n=0;n<SFX_MAX;n++) Msfx_smpdeinit(&m_game_smp[n]);

	
	//for(int n=11;n<m_game_smp_n;n++) Msfx_smpdeinit(&m_game_smp[n]);

	//fsm_game_smp[0].buf[0]->Release();	// 'Asta-La-Vista Baby'

	/*
	while(m_game_smp_n)
	{
	m_game_smp_n--;
	Msfx_smpdeinit(&m_game_smp[m_game_smp_n]);
	}
	*/


	
	DeinitD3D();

	//Mmus_deinit();
	//Mdata_deinit();
	Mgame_deinit();
	//Mgfx_deinit();

	

	//Msfx_deinit();
	
	
	Mio_deinit();


	//Mfile_deinit();
	Mdebug_deinit();
	Mmain_deinit();
	// ------------------------------------------
#endif //!MAIN_SERVER

	// deatroy code
	Deinit();
	delete m_lobbySettings;
	delete m_httpSocketEx2;
	delete m_httpSocketEx;

	_controlfp( _CW_DEFAULT, 0xfffff );


	end:
	Mmain_log("Deinitialization complete.");

	
}




int g_bpp = 0;	  
DEVMODE g_pdevMode;


/*
LRESULT CALLBACK WndProcStats(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

LRESULT CALLBACK WndProcStats(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{

	switch (Msg)
	{
	case 0x031E:
		// PostQuitMessage(WM_QUIT);
		break;

	case WM_DESTROY:
		// PostQuitMessage(WM_QUIT);
		break;
	case WM_MOUSEMOVE:
		if (g_gameAppView)
			g_gameAppView->m_statsWindow->MOUSEMOVE(Msg, wParam, lParam);
		break;

	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
		if (g_gameAppView)
			g_gameAppView->m_statsWindow->LBUTTONDOWN(Msg, wParam, lParam);
		break;



	case WM_LBUTTONUP:
		if (g_gameAppView)
			g_gameAppView->m_statsWindow->LBUTTONUP(Msg, wParam, lParam);
		break;

	case WM_RBUTTONDOWN:
		if (g_gameAppView)
			g_gameAppView->m_statsWindow->RBUTTONDOWN(Msg, wParam, lParam);
		break;

	case WM_RBUTTONUP:
		if (g_gameAppView)
			g_gameAppView->m_statsWindow->RBUTTONUP(Msg, wParam, lParam);
		break;




	}
	return DefWindowProc(hWnd, Msg, wParam, lParam);
}

*/


LRESULT CALLBACK WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);




LRESULT CALLBACK WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{

    switch(Msg)
    {
	case 0x031E:
		PostQuitMessage(WM_QUIT);
		break;

    case WM_DESTROY:
		PostQuitMessage(WM_QUIT);
        break;

	case WM_SETCURSOR:

		// If the window is minimized, draw the hCurs3 cursor. 
		// If the window is not minimized, draw the default 
		// cursor (class cursor). 
		int p;
		p = 0;
		break;


	case WM_MOUSEMOVE:
		if(g_gameAppView)
		g_gameAppView->TableView_MOUSEMOVE(Msg, wParam, lParam);
		break;
	
	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
		if(g_gameAppView)
		g_gameAppView->TableView_LBUTTONDOWN(Msg, wParam, lParam);
		break;

	

	case WM_LBUTTONUP:
		if(g_gameAppView)
		g_gameAppView->TableView_LBUTTONUP(Msg, wParam, lParam);
		break;

	case WM_RBUTTONDOWN:
		if(g_gameAppView)
		g_gameAppView->TableView_RBUTTONDOWN(Msg, wParam, lParam);
		break;

	case WM_RBUTTONUP:
		if(g_gameAppView)
		g_gameAppView->TableView_RBUTTONUP(Msg, wParam, lParam);
		break;

	case WM_MBUTTONDOWN:
		if(g_gameAppView)
		g_gameAppView->TableView_MBUTTONDOWN(Msg, wParam, lParam);
		break;
	case WM_MBUTTONUP:
		if(g_gameAppView)
		g_gameAppView->TableView_MBUTTONUP(Msg, wParam, lParam);
		break;

	case WM_MOUSEWHEEL:
		if (g_gameAppView)
		{
			g_gameAppView->TableView_MOUSEWHEEL(Msg, wParam, lParam);
		}
		break;

	
    }
    return DefWindowProc(hWnd, Msg, wParam, lParam);
}
















/////////////////////
// GLOBALS
HWND g_hwndDX;			// just a global for hwnd
HWND g_hwndDXStats;		// Global for Stats hwnd
//
/////////////////////

// The name of our window class.
TCHAR szClassName[] = TEXT("MicroMax_CLASS") ;

int CLASS_GOOD = false;
int CLASS_GOOD_STATS = false;

// Creates GUI Window.
HWND CreateWindowPK(LPCTSTR szWindowText,int x,int y,int width,int height, HWND parent, int flags, HINSTANCE hinstance)
{
	
	HINSTANCE hThisInstance = GetModuleHandle(0);
	
	if(!CLASS_GOOD){


		HBRUSH bgcol;
		bgcol = CreateSolidBrush(RGB(0,17,34));
  		// Window class structure.
  		WNDCLASSEX wcx ;

  		// Now we must fill in the members of WNDCLASSEX.
  		wcx.hInstance     = hinstance;//hThisInstance;
  		wcx.lpszClassName = szClassName ;
		wcx.lpfnWndProc   = (WNDPROC)WndProc;
  		wcx.style         = CS_DBLCLKS;
  		wcx.hIcon         = LoadIcon (NULL, IDI_APPLICATION);
  		wcx.hIconSm       = LoadIcon (NULL, IDI_APPLICATION);
  		wcx.hCursor       = LoadCursor (NULL, IDC_ARROW);
  		wcx.lpszMenuName  = NULL;
  		wcx.cbSize        = sizeof (WNDCLASSEX);
  		wcx.cbClsExtra    = 0;
  		wcx.cbWndExtra    = 0;
  		wcx.hbrBackground = bgcol;


  		// Register our window class with the operating system.
  		// If there is an error, exit program.
  		if ( !RegisterClassEx (&wcx) )
  		{
    		MessageBox( 0, TEXT("Failed to register window class!"),TEXT("Error!"), MB_OK|MB_ICONERROR ) ;
    		return 0;
  		}
		
		// class created.
		CLASS_GOOD = TRUE;
	}


	HWND hwnd = CreateWindowEx ( 0, szClassName, szWindowText, WS_OVERLAPPED | WS_CHILD , x, y, width, height, parent,  0, hThisInstance, 0 ); 
	//HWND hwnd = CreateWindowEx ( 0, szClassName, szWindowText, NULL, x, y, width, height, parent,  0, hThisInstance, 0 ); 
	


	if ( !IsWindow(hwnd) ) { 
		return 0;
	}
			
	return hwnd;
	

}

CRect o_rect;
CREATESTRUCT o_cs;

// Surface sprite used for Mini Cam Drawing in DirectX
LPD3DXSPRITE minicamSurfSprite;

bool CGameAppView::InitDevice(bool bM3D)
{
#ifndef MAIN_SERVER

	HRESULT hr;

	//M3d_init(g_hwndDX, rect.Width(), rect.Height());///590);
	//M3d_init(g_hwndDX, rect.Width(), rect.Height());///590);
	/*
	char buf[80];
	sprintf(buf, "%s", Environment::UserName);
	AfxMessageBox(buf);
	*/

	Mmain_log("Init[3.2.1]");

	if(bM3D)
	{
		// char buf[80];
		// sprintf(buf, "w: %d, h: %d", g_iMaxWidthWS, g_iMaxWidthWS / 2);
		// AfxMessageBox(buf);
		int w = g_iMaxWidthWS * 1.25f;
		if(w > Mmain_iDesktopWidth)
			w = Mmain_iDesktopWidth;

		int h = w / 2;
		if (h > Mmain_iDesktopHeight)
			h = Mmain_iDesktopHeight;

		M3d_init(g_hwndDX, w, h);///590);
	}

	Mmain_log("Init[3.2.2]");
	
	

	//M3d_init(g_hwndDX, 1050, 1396);///590);

	// Create our background surface too //
	// hr = g_pDevice->CreateDepthStencilSurface(rect.Width(), 590, D3DFMT_D24S8, D3DMULTISAMPLE_NONE, 1, false, &m_pBGSurf, NULL);
	//hr = g_pDevice->CreateDepthStencilSurface(rect.Width(), 590, D3DFMT_D24S8, D3DMULTISAMPLE_NONE, 1, false, &pRenderSurface, NULL);


	
	
	/*
	pRenderSurface = NULL;
	pRenderSurfaceMiniCam = NULL;
	pRenderSurfaceShop = NULL;
	*/
	

	// g_pSwapChain = g_pSwapChain;

	
	hr = g_pDevice->GetRenderTarget(0, &pRenderSurface);
	

	hr = D3DXCreateSprite(g_pDevice, &minicamSurfSprite);
	



	Mmain_log("Init[3.2.3]");
	D3DSURFACE_DESC desc;
	pRenderSurface->GetDesc( &desc );

	Mmain_log("Init[3.2.4]");
	// create our surface as a render target //
	hr = g_pDevice->CreateRenderTarget( desc.Width, desc.Height, desc.Format, desc.MultiSampleType, desc.MultiSampleQuality, true, &m_pBGSurf, NULL);
	// hr = g_pDevice->CreateRenderTarget( 384, 384, desc.Format, desc.MultiSampleType, desc.MultiSampleQuality, false, &pRenderSurfaceMiniCam, NULL);
	// hr = g_pDevice->CreateRenderTarget( 512, 256, desc.Format, desc.MultiSampleType, desc.MultiSampleQuality, false, &pRenderSurfaceShop, NULL);
	
	Mmain_log("Init[3.2.5]");



	//hr = g_pDevice->CreateOffscreenPlainSurface(256, 256, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &pRenderSurfaceMiniCam, NULL);
	//hr = g_pDevice->CreateRenderTarget( desc.Width, desc.Height, desc.Format, desc.MultiSampleType, desc.MultiSampleQuality, false, &pRenderSurfaceMiniCam, NULL);

	if(hr == D3DERR_INVALIDCALL)
	{
		hr = 0;
	}

	// Set up Mini Camera Back Buffer (needed for swap chain) //
	// hr = g_pDevice->CreateRenderTarget( desc.Width, desc.Height, desc.Format, desc.MultiSampleType, desc.MultiSampleQuality, false, &m_pBGSurf, NULL);
	g_pSwapChain->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pRenderSurfaceMiniCam);
	Mmain_log("Init[3.2.6]");
	
	/*
	D3DPRESENT_PARAMETERS d3dpp;
	d3dpp.BackBufferWidth					= g_iMaxWidthWS;
	d3dpp.BackBufferHeight					= g_iMaxWidthWS/2;
	d3dpp.BackBufferFormat					= D3DFMT_A8R8G8B8; // D3DFMT_UNKNOWN; //D3DFMT_A8R8G8B8;
	d3dpp.BackBufferCount					= 1;
	d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;//D3DMULTISAMPLE_2_SAMPLES;//D3DMULTISAMPLE_NONE;
	d3dpp.MultiSampleQuality				= 0;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= g_hwndDX;
	d3dpp.Windowed							= true;
	d3dpp.EnableAutoDepthStencil			= true;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;	// Depth Format
	d3dpp.Flags								= 0;//D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	d3dpp.PresentationInterval				= D3DPRESENT_INTERVAL_ONE;
	
	

	
	hr = g_pFont->Release();
	hr = pRenderSurfaceMiniCam->Release();	
	hr = m_pBGSurf->Release();
	hr = pRenderSurface->Release();
	hr = g_pSwapChain->Release();

	hr = g_pDevice->Reset(&d3dpp);
	*/



	if(hr == D3DERR_INVALIDCALL)
	{
		hr = 0;
	}
	
	
	
	//IDirect3DSurface9* pRenderSurface = NULL;
	//M3d_init(cs.hwndParent, rect.Width(), rect.Height());
	


	
	g_pAdvert = new Advert *[MAX_ADVERTS];	// Maximum of 64 Advertisements for now //
	for(int n=0;n<MAX_ADVERTS;n++) g_pAdvert[n] = NULL;

	
	g_pCamera = new Camera(0);
	g_pCameraMiniCam = new Camera(0);
	g_pCameraFree = new Camera(1);
	g_pFont1 = new Font(g_pDevice);
	g_pFont2 = new Font(g_pDevice);
	// g_pFont3 = new Font(g_pDevice);
	g_pFontSnk1 = new Font(g_pDevice);
	g_pFontSnk2 = new Font(g_pDevice);

	Mmain_log("Init[3.2.7]");
	
	g_pFont1->Load(1024, 128, 12, "Graphics/HUD/font3.png", "ABCDEFGHIJKLMNOPQRSTUVWXYZ,.<>/\\?;:1234567890!@#$%^&*()-_=+[]{}abcdefghijklmnopqrstuvwxyz");
	Mmain_log("Init[3.2.7a]");
	g_pFont2->Load(1280, 160, 18, "Graphics/HUD/font4.png", "ABCDEFGHIJKLMNOPQRSTUVWXYZ,.<>/\\?;:1234567890!@#$%^&*()-_=+[]abcdefghijklmnopqrstuvwxyz{}");
	Mmain_log("Init[3.2.7b]");
	// g_pFont3->Load(1024, 128, 12, "Graphics/HUD/font5.png", "ABCDEFGHIJKLMNOPQRSTUVWXYZ,.<>/\\?;:1234567890!@#$%^&*()-_=+[]abcdefghijklmnopqrstuvwxyz{}");
	// Mmain_log("Init[3.2.7c]");
	g_pFontSnk1->Load(256, 32, 10, "Graphics/HUD/snkfnt1.png", "-0123456789*");
	Mmain_log("Init[3.2.c7]");


	if(g_build.gameType == GAMETYPE_SNOOKER) 
	{
		g_pFontSnk2->Load(640, 120, 10, "Graphics/HUD/snkfnt2.png", "-0123456789*()bnf:P!@#$ABCDEFGHI|Y}+");
		Mmain_log("Init[3.2.7d]");
	}
	else
	{
		g_pFontSnk2->Load(640, 120, 12, "Graphics/HUD/ipoolfnt2.png", "-0123456789*()bnrxyz:P!@#$ABCDEFGHIJKLMNOQRSTUV|WXY}+");	
		Mmain_log("Init[3.2.7e]");
	}


	Mmain_log("Init[3.2.8]");
	//g_pFont2->Load("Graphics/textures/arrowblue64x64.png", "ABCDEFGHIJKLMNOPQRSTUVWXYZ,.<>/\\?;:1234567890!@#$%^&*()-_=+[]{}abcdefghijklmnopqrstuvwxyz");
	
	


	 //
	// Load the XFile data.
	//

	ID3DXBuffer* adjBuffer  = 0;
	ID3DXBuffer* mtrlBuffer = 0;
	DWORD        numMtrls   = 0;

	if(g_build.gameType == GAMETYPE_SNOOKER)
	{	
		hr = D3DXLoadMeshFromX(  
			"Graphics/x/scene1/scene_s.x",
			D3DXMESH_MANAGED,
			g_pDevice,
			&adjBuffer,
			&mtrlBuffer,
			0,
			&numMtrls,
			&XMesh_SFrame);
	}
	else
	{
		hr = D3DXLoadMeshFromX(  
			"Graphics/x/scene1/scene_p.x",
			D3DXMESH_MANAGED,
			g_pDevice,
			&adjBuffer,
			&mtrlBuffer,
			0,
			&numMtrls,
			&XMesh_SFrame);

	}

	Mmain_log("Init[3.2.9]");

	if(FAILED(hr))
	{
		::MessageBox(0, "D3DXLoadMeshFromX(scene file) - FAILED", 0, 0);
		return false;
	}


	
	//
	// Extract the materials, and load textures.
	//

	char fname[80];
	if( mtrlBuffer != 0 && numMtrls != 0 )
	{
		D3DXMATERIAL* mtrls = (D3DXMATERIAL*)mtrlBuffer->GetBufferPointer();

		for(int i = 0; i < numMtrls; i++)
		{
			// the MatD3D property doesn't have an ambient value set
			// when its loaded, so set it now:
			

			// mtrls[i].MatD3D.Ambient = mtrls[i].MatD3D.Diffuse;

			// save the ith material
			XMesh_SFrameMtrls.push_back( mtrls[i].MatD3D );

			// check if the ith material has an associative texture
			if( mtrls[i].pTextureFilename != 0 )
			{
				// yes, load the texture for the ith subset
				sprintf(fname, "Graphics/x/scene1/%s", mtrls[i].pTextureFilename);
				IDirect3DTexture9* tex = 0;
				D3DXCreateTextureFromFile(
					g_pDevice,
					fname,
					&tex);

				// save the loaded texture
				XMesh_SFrameTextures.push_back( tex );
			}
			else
			{
				// no texture for the ith subset
				XMesh_SFrameTextures.push_back( 0 );
			}
		}
	}
	d3d::Release<ID3DXBuffer*>(mtrlBuffer); // done w/ buffer

	Mmain_log("Init[3.2.10]");

	//
	// Optimize the mesh.
	//

	hr = XMesh_SFrame->OptimizeInplace(		
		D3DXMESHOPT_ATTRSORT |
		D3DXMESHOPT_COMPACT  |
		D3DXMESHOPT_VERTEXCACHE,
		(DWORD*)adjBuffer->GetBufferPointer(),
		0, 0, 0);


	Mmain_log("Init[3.2.11]");

	d3d::Release<ID3DXBuffer*>(adjBuffer); // done w/ buffer

	if(FAILED(hr))
	{
		// ::MessageBox(0, "OptimizeInplace() - FAILED", 0, 0);
		// return false;
	}

	
	// Create Font //


	D3DXFONT_DESCA fdesc;
	fdesc.Height			= 14;
	fdesc.Width				= 8;
	fdesc.Weight			= 500;
	fdesc.Italic			= false;
	fdesc.CharSet			= DEFAULT_CHARSET;
	strcpy(fdesc.FaceName, "Times new Roman");	// font style


	D3DXCreateFontIndirect(g_pDevice, &fdesc, &g_pFont);


	if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		g_pCamera->SetPosition(D3DXVECTOR3(4000.0f, 0.0f, 1900.0f));
		//g_pCameraFree->SetPosition(D3DXVECTOR3(1295.0f, 3493.0f, 1170.0f));
		g_pCameraFree->SetPosition(D3DXVECTOR3(-3714.0f, 0.0f, 1206.0f));
	}
	else
	{
		g_pCamera->SetPosition(D3DXVECTOR3(4000.0f, 0.0f, 1900.0f));
		g_pCameraFree->SetPosition(D3DXVECTOR3(1295.0f, 3493.0f, 1170.0f));
	}

	
	//
    // Cache the width & height of the back-buffer...
    //

    LPDIRECT3DSURFACE9 pBackBuffer = NULL;
    D3DSURFACE_DESC d3dsd;
    g_pDevice->GetBackBuffer( 0, 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer );
    pBackBuffer->GetDesc( &d3dsd );
    pBackBuffer->Release();
    g_dwBackBufferWidth  = d3dsd.Width;
    g_dwBackBufferHeight = d3dsd.Height;


	Mmain_log("Init[3.2.12]");
/*
		

	//
	// Set a directional light.
	//

	D3DLIGHT9 light;
	::ZeroMemory(&light, sizeof(light));
	light.Type      = D3DLIGHT_DIRECTIONAL;
	light.Ambient   = D3DXCOLOR(0.8f, 0.8f, 0.8f, 1.0f);
	light.Diffuse   = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
	light.Specular  = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.0f);
	light.Direction = D3DXVECTOR3(0.5f, -0.5f, -1.0f);
	g_pDevice->SetLight(0, &light);
	g_pDevice->LightEnable(0, true);
	
*/

	//
	// Set a omi light.
	//
/*
	D3DLIGHT9 light;
	::ZeroMemory(&light, sizeof(light));
	light.Type      = D3DLIGHT_POINT;
	light.Ambient   = D3DXCOLOR(0.4f, 0.4f, 0.4f, 1.0f);
	light.Diffuse   = D3DXCOLOR(0.4f, 0.4f, 0.4f, 1.0f);
	light.Specular  = D3DXCOLOR(0.4f, 0.4f, 0.4f, 1.0f);

	
	light.Attenuation0 = 0.3f; //0.9f;//0.0001f;
	light.Attenuation1 = 0.00006f; // 0.0f;//0.0002f;
	light.Attenuation2 = 0.00000008f; // 0.0000002f;
	light.Range = 4000.0f;
	

	light.Position.x = 0.0f;
	light.Position.y = 0.0f;
	light.Position.z = 800.0f;
	g_pDevice->SetLight(0, &light);

	light.Position.x = 1800.0f;
	light.Position.y = 0.0f;
	light.Position.z = 1000.0f;
	g_pDevice->SetLight(1, &light);
	
	light.Position.x = -1800.0f;
	light.Position.y = 0.0f;
	light.Position.z = 1000.0f;
	g_pDevice->SetLight(2, &light);

	g_pDevice->LightEnable(0, true);
	g_pDevice->LightEnable(1, true);
	g_pDevice->LightEnable(2, true);
*/
	g_pDevice->SetRenderState(D3DRS_NORMALIZENORMALS, true);
	g_pDevice->SetRenderState(D3DRS_SPECULARENABLE, true);
	g_pDevice->SetRenderState(D3DRS_LIGHTING, true);



	// g_pDevice->SetRenderState(D3DRS_CLIPPING, true);
/*
	//
	// Create texture.
	//
	D3DXCreateTextureFromFile(
		g_pDevice,
		"crate.jpg",
		&Tex);

*/

	//
	// Set texture filters.
	//

	// Don't use Filtering for iPool (since our textures aren't correct right now //
	//if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		g_pDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
		g_pDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
		// g_pDevice->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);
	}

	// Use Alpha  in Material's Diffuse Component for Alpha //
	//g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	//g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	//g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	
	//g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

	// Set blending factors so that alpha component determines transparancy //
	g_pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	

	// Position and aim the camera //
	D3DXMATRIX V;
	D3DXMatrixLookAtLH(&V, &g_pCamera->_pos, &g_pCamera->_look, &g_pCamera->_up);
	g_pDevice->SetTransform(D3DTS_VIEW, &V);


	Mmain_log("Init[3.2.13]");

	g_dwMainViewWidth = g_dwBackBufferWidth;
	g_dwMainViewHeight = g_dwBackBufferHeight - g_dwChatHeight;


	//
	// Set the projection matrix.
	//

	D3DVIEWPORT9 mainViewPort;

    mainViewPort.X      = 0;
    mainViewPort.Y      = 0;
    mainViewPort.Width  = g_dwMainViewWidth;
	mainViewPort.Height = g_dwMainViewHeight;
    mainViewPort.MinZ   = 0.0f;
    mainViewPort.MaxZ   = 1.0f;

	float aspect = (float)mainViewPort.Width / (float)mainViewPort.Height;


	D3DXMATRIX proj;
	D3DXMatrixPerspectiveFovLH(
			&proj,
			D3DX_PI * 0.20f, // 90 - degree
			aspect,
			100.0f,
			20000.0f);
	g_pDevice->SetTransform(D3DTS_PROJECTION, &proj);



	// Make sure our Camera knows what FOV and Aspect Ratio we are using //
	g_pCamera->_cameraFov = D3DX_PI * 0.20f;
	g_pCamera->_cameraAspect = aspect;
	g_pCameraFree->_cameraFov = D3DX_PI * 0.20f;
	g_pCameraFree->_cameraAspect = aspect;


	Mmain_log("Init[3.2.14]");


	BSphere._center = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	BSphere._radius = 100.0f;

	D3DXCreateSphere(g_pDevice, BSphere._radius, 20, 20, &Sphere, 0);

	Mmain_log("Init[3.2.15]");

	return true;

#endif
	return false;
}


bool CGameAppView::ResetDevice(void)
{
	HRESULT hr;

	// Fill Out D3DPRESENT_PARAMETERS //
	D3DPRESENT_PARAMETERS d3dpp;
	d3dpp.BackBufferWidth					= g_iMaxWidthWS;
	d3dpp.BackBufferHeight					= g_iMaxWidthWS/2;
	d3dpp.BackBufferFormat					= D3DFMT_A8R8G8B8; //D3DFMT_A8R8G8B8;
	d3dpp.BackBufferCount					= 1;
	d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
	d3dpp.MultiSampleQuality				= 0;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= g_hwndDX;
	d3dpp.Windowed							= true;
	d3dpp.EnableAutoDepthStencil			= true;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;	// Depth Format
	d3dpp.Flags								= 0;//D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	
	
	//d3dpp.PresentationInterval				= D3DPRESENT_INTERVAL_DEFAULT;
	//d3dpp.PresentationInterval				= D3DPRESENT_INTERVAL_IMMEDIATE;
	d3dpp.PresentationInterval				= D3DPRESENT_INTERVAL_ONE;
	
	hr = g_pFont->Release();
	hr = pRenderSurfaceMiniCam->Release();	
	hr = m_pBGSurf->Release();
	hr = pRenderSurface->Release();
	hr = g_pSwapChain->Release();

	hr = g_pDevice->Reset(&d3dpp);


	d3dpp.PresentationInterval				= D3DPRESENT_INTERVAL_IMMEDIATE;
	
	

	
	//d3dpp.BackBufferWidth					= 384;

	//d3dpp.BackBufferHeight					= 384;
	d3dpp.PresentationInterval				= D3DPRESENT_INTERVAL_IMMEDIATE;

	g_pDevice->CreateAdditionalSwapChain(&d3dpp, &g_pSwapChain);

	char buf[256];
	if( FAILED(hr) )
	{
		switch(hr)
		{
			case D3DERR_DEVICELOST: sprintf(buf, "Reset() - FAILED [D3DERR_DEVICELOST]");
				break;
			case D3DERR_INVALIDCALL: sprintf(buf, "Reset() - FAILED [D3DERR_INVALIDCALL]");
				break;
			case D3DERR_NOTAVAILABLE: sprintf(buf, "Reset() - FAILED [D3DERR_NOTAVAILABLE]");
				break;
			case D3DERR_OUTOFVIDEOMEMORY: sprintf(buf, "Reset() - FAILED [D3DERR_OUTOFVIDEOMEMORY]");
				break;
			default: 
				sprintf(buf, "Reset() - FAILED []");
				break;

		}
	}
	else
	{
			sprintf(buf, "Reset() - OK []");
	}

	// ::MessageBox(0, buf, 0, 0);

	if( FAILED(hr) ) return false;

	return true;
}

bool CGameAppView::InitD3D(CRect rect, CREATESTRUCT cs, bool type)
{
#ifndef MAIN_SERVER
	if(type == 0)
	{
		o_rect.left = rect.left;
		o_rect.right = rect.right;
		o_rect.top = rect.top;
		o_rect.bottom = rect.bottom;

		o_cs.hwndParent = cs.hwndParent;
		o_cs.hInstance = cs.hInstance;
	}
	
	Mmain_log("Init[3.1]");
	//g_hwndDX = NULL;
	g_hwndDX = CreateWindowPK(CString("DirectX View"), 0, 0, g_iMaxWidthWS, g_iMaxWidthWS/2/*590*/, cs.hwndParent, 0, cs.hInstance);
	::ShowWindow(g_hwndDX, SW_SHOW);
	Mmain_log("Init[3.2]");
	InitDevice();
	//ResetDevice();
	//InitDevice();

	Mmain_log("Init[3.3]");
	return true;

#endif

	return false;
}

// Create a Child Window with DirectX interface (for Ladder Stats Control)
bool CGameAppView::CreateStatsWindow(void)
{
	/*
	g_hwndDXStats = CreateWindowPK(CString("DirectX View"), 0, 0, 640, 480, this->m_hWnd, 0, NULL);
	::ShowWindow(g_hwndDXStats, SW_SHOW);
	*/

	int p;
	p = 0;

	/*
	HINSTANCE hThisInstance = GetModuleHandle(0);


	if (!CLASS_GOOD_STATS)
	{
		HBRUSH bgcol;
		bgcol = CreateSolidBrush(RGB(0, 17, 34));
		// Window class structure.
		WNDCLASSEX wcx;

		// Now we must fill in the members of WNDCLASSEX.
		wcx.hInstance = hThisInstance;
		wcx.lpszClassName = "stats";
		wcx.lpfnWndProc = (WNDPROC)WndProcStats;
		wcx.style = CS_DBLCLKS;
		wcx.hIcon = LoadIcon(NULL, IDI_APPLICATION);
		wcx.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
		wcx.hCursor = LoadCursor(NULL, IDC_ARROW);
		wcx.lpszMenuName = NULL;
		wcx.cbSize = sizeof (WNDCLASSEX);
		wcx.cbClsExtra = 0;
		wcx.cbWndExtra = 0;
		wcx.hbrBackground = bgcol;

		// Register our window class with the operating system.
		// If there is an error, exit program.
		if (!RegisterClassEx(&wcx))
		{
			// MessageBox(0, TEXT("Failed to register window class!"), T"Error!", MB_OK | MB_ICONERROR);
			return 0;
		}
	}

	CLASS_GOOD_STATS = true;

	int statsWidth = 600;
	int statsHeight = 400;
	

	//HWND hwnd = CreateWindowEx(WS_EX_CLIENTEDGE, "stats", "Stats View", WS_CHILD, 100, 100, 500, 300, wndDesktop->m_hWnd, 0, hThisInstance, 0);
	HWND hwnd = CreateWindowEx(WS_EX_TOPMOST, "stats", "Stats View", WS_POPUP | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 100, 100, statsWidth, statsHeight, g_hwnd, 0, hThisInstance, 0);
	//HWND hwnd = CreateWindowEx ( 0, szClassName, szWindowText, NULL, x, y, width, height, parent,  0, hThisInstance, 0 ); 

	
	if (!IsWindow(hwnd)) {
		return false;
	}

	g_hwndDXStats = hwnd;

	// Set up DirectX for our Stats Window
	m_statsWindow->InitD3D(g_hwndDXStats, 100, 100, statsWidth, statsHeight);
	*/

	
	return true;
	// return hwnd;


	// return true;
}

bool CGameAppView::DeinitD3D(void)
{
// Memir Lib deinit code
	// ------------------------------------------
	M3d_deinit(); 

	// ::DestroyWindow(g_hwndDX);
	

	

	
	d3d::Delete<Camera*>(g_pCamera);
	d3d::Delete<Camera*>(g_pCameraMiniCam);
	d3d::Delete<Camera*>(g_pCameraFree);

	
	d3d::Delete<Font*>(g_pFontSnk1);
	d3d::Delete<Font*>(g_pFontSnk2);
	// d3d::Delete<Font*>(g_pFont3);
	d3d::Delete<Font*>(g_pFont2);
	d3d::Delete<Font*>(g_pFont1);
	

	minicamSurfSprite->Release();
	
	return true;
}

HRESULT DisableNCRendering(HWND hwnd)
{
   HRESULT hr = S_OK;

   DWMNCRENDERINGPOLICY ncrp = DWMNCRP_DISABLED;

   // Disable non-client area rendering on window
   hr = DwmSetWindowAttribute(hwnd, DWMWA_TRANSITIONS_FORCEDISABLED, &ncrp, sizeof(ncrp));
   if (SUCCEEDED(hr))
   {
      //do more stuff
   }
   return hr;
}



BOOL CGameAppView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	Mmain_log("Initialization phase 2.0:");

	Mmain_log("Initialization phase 2.1:");

	FrameCnt = 0;
	TimeElapsed = 0.0f;
	FPS = 0.0f;

	// Copy Window Handle to global pointer //
	g_hwnd = cs.hwndParent;
	Mmain_log("Initialization phase 2.2:");
	// Get Desktop Window Dimensions
	CWnd *wndDesktop = GetDesktopWindow();
	CRect rect;
	wndDesktop->GetWindowRect(&rect);
	m_SizeDesktop = rect.Size();

	Mmain_log("Initialization phase 2.3:");

	Mmain_iDesktopWidth = rect.Width();
	Mmain_iDesktopHeight = rect.Height();
	

	Mmain_log("Init[1.0]");
	
	//if(rect.right > 1280) rect.right = 1280;
	//if(rect.top > 1024) rect.top = 1024;

	// The Maximum Dimension we will allow is 1280x1024 //

	float sWidth = rect.Width();
	Mmain_log("Init[1.0.1]");
	float sHeight = rect.Height();
	Mmain_log("Init[1.0.2]");

	if (sHeight < 1) sHeight = 1;
	Mmain_log("Init[1.0.3]");
	// If Our Width to Height Ratio is greater then 4:3, then force WideScreen Mode On //
	if( (sWidth / sHeight) > 1.40) 
	{
		Mmain_log("Init[1.1]");
		g_WideScreenEnabled = true;
		float tmp = (float)rect.Height();
		Mmain_log("Init[1.2]");
		rect.right = (int)(tmp * 1.33f);
		Mmain_log("Init[1.3]");
	}
	else 
	{
		Mmain_log("Init[1.4]");
		g_WideScreenEnabled = false;
	}

	Mmain_log("Init[1.5]");
	if(g_WideScreenEnabled) g_yBarOffset = 200;
		else g_yBarOffset = 40;

	Mmain_log("Init[1.6]");
	g_yBarOffset = 40;

	
#ifndef MAIN_SERVER

	// Get the Monitor Refresh Rate //
	Mmain_log("Init[2]");
	EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &g_pdevMode);
	Mmain_log("Init[3]");

	InitD3D(rect, cs, 0);
	Mmain_log("Init[4]");

	/*
	// Test Add To Registry //
	HKEY   hkey;
	DWORD  dwDisposition;

	DWORD dwType, dwSize;


	int ret = RegCreateKeyEx(HKEY_USERS, TEXT("Software\\Memir Games\\iSnooker"), 0, NULL, 0, 0, NULL, &hkey, &dwDisposition);


	if(RegCreateKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Memir Games\\iSnooker"), 0, NULL, 0, 0, NULL, &hkey, &dwDisposition)==ERROR_SUCCESS)
	{
		RegSetValueEx(hkey, TEXT("Trial Flag"), 0, REG_DWORD, 
		(PBYTE)1, sizeof(DWORD));
		
		RegSetValueEx(hkey, TEXT("iSnooker Installed"), 0, REG_SZ, 
		(PBYTE)1, 1024);

		RegCloseKey(hkey);
	}


	hkey = hkey;
	*/


#endif


	Mmain_log("Init[5]");
	CDC *pDC = wndDesktop->GetDC();
	Mmain_log("Init[6]");
	if(!pDC) MessageBox("[0] Failed on: -> wndDesktop->GetDC();", g_appName);
	else
	{
		Mmain_log("Init[6.1]");
		g_bpp = pDC->GetDeviceCaps(BITSPIXEL);
		Mmain_log("Init[6.2]");





		wndDesktop->ReleaseDC(pDC);
		Mmain_log("Init[6.3]");
	}

	Mmain_log("Init[7]");

#ifndef MAIN_SERVER
	// Memir Lib init code
	// ------------------------------------------
		Mmain_log("Memir Lib Init:");
	Mmain_hwndpass(g_hwnd);
	Mmain_hinstpass(g_hinst);
										
		Mmain_log("Mmain Init");
	Mmain_init(MMAIN_INIT_MEMIR);
		Mmain_log("Mdebug Init");
	Mdebug_init(MDEBUG_INIT_MEMIR);
		Mmain_log("Mfile Init");
	//Mfile_init(MFILE_INIT_MEMIR);
		Mmain_log("Mio Init");
	Mio_init(MIO_INIT_MEMIR);
	//Mio_keyinit();
	Mio_mouseinit();
	// Mio_joyinit(-16,16,-16,16);
		Mmain_log("Msfx Init");
	//Msfx_init(MSFX_INIT_MEMIR, g_hwnd);
	Msfx_init(MSFX_INIT_MEMIR);
		Mmain_log("Mgfx Init");
	
	
	Mgfx.max_mss = 1024;
	Mgfx.max_sprs = 2048;
	
	//Mgfx_init(MGFX_INIT_MEMIR);		

#ifdef SOFTWARE3D
		Mmain_log("Mgfx_modewin3d (software)");
	Mgfx_modewin3d(320,240,g_bpp,1); // should be 1 for software!
#else
		Mmain_log("Mgfx_modewin3d (hardware)");
	Mgfx_modewin3d(320,240,g_bpp,0); // should be 0 for hardware!
#endif //SOFTWARE3D

	//	Mmain_log("Mgfx_palette");
	// Mgfx_palette(MGFX_PALETTE_RGBW);
	//void Mgfx_modewin(DWORD w,DWORD h,DWORD bpp)
	//Mgfx_mode(w,h,bpp);
	//Mgfx_palette(MGFX_PALETTE_RGBW);
		Mmain_log("Mgame_init");
	Mgame_init(MGAME_INIT_MEMIR);
		//Mmain_log("Mdata_init");
	//Mdata_init(MDATA_INIT_MEMIR);
	//Mmus_init();

		Mmain_log("Mmain_fs");
	Mmain_fsrate(GAMEAPP_FPS*10);//*11);//*GAME_ITTR);//*11); // Set frame rate i.e. 60 Hz * 11 = 660Hz
	Mmain_fsreset();
	// ------------------------------------------				

	// SOUND FX //
		Mmain_log("Msfx_smp (sound effects loading)");
	Msfx_tag = TAG_MUSIC;
	// Msfx_smpload(&m_game_smp[SFX_INTRO],"Sound/intro.wav",1);
	Msfx_tag = TAG_SFX;
	Msfx_smpload(&m_game_smp[SFX_CUE2BALL],"sound/Cue2Ball1.wav",1);
	Msfx_smpload(&m_game_smp[SFX_BALL2BALL],"sound/Ball2Ball1.wav",4);
	Msfx_smpload(&m_game_smp[SFX_BALL2POCKET],"sound/Ball2Pocket1.wav",4);
	//Msfx_smpload(&m_game_smp[SFX_COUGH1],"sound/Cough1.wav",4);
	//Msfx_smpload(&m_game_smp[SFX_CUE2BALLSOFT],"sound/Cue2BallSoft.wav",1);
	//Msfx_smpload(&m_game_smp[SFX_BALL2BALLSOFT],"sound/Ball2BallSoft.wav",1);
	//Msfx_smpload(&m_game_smp[SFX_BALL2POCKETMIDDLE45],"sound/Ball2PocketMiddle45.wav",4);
	//Msfx_smpload(&m_game_smp[SFX_TAP],"sound/Tap.wav");
	Msfx_smpload(&m_game_smp[SFX_20PLUSBREAK],"sound/20PlusBk.wav");
	Msfx_smpload(&m_game_smp[SFX_CENTURY],"sound/Century.wav");
	Msfx_smpload(&m_game_smp[SFX_GOODSHOT],"sound/GoodShot.wav");
	Msfx_smpload(&m_game_smp[SFX_BALLAROUNDPOCKET],"sound/BallAroundPocket.wav",4);

	
	#ifndef THE_POOL_CLUB // isnooker
	

	g_build.addOnSfx = TRUE;
	FILE *fptr = NULL;
	fptr = fopen("voices/numbers/1.wav","rb");
	if(fptr == NULL)
	{
		g_build.addOnSfx = FALSE;
	}
	else
	{
		fclose(fptr);
	}

	if(g_build.addOnSfx)
	{
	
	// add voices sfx files
	Msfx_smpload(&m_game_smp[11],"voices/numbers/1.wav",2);
	Msfx_smpload(&m_game_smp[12],"voices/numbers/2.wav",2);
	Msfx_smpload(&m_game_smp[13],"voices/numbers/3.wav",2);
	Msfx_smpload(&m_game_smp[14],"voices/numbers/4.wav",2);
	Msfx_smpload(&m_game_smp[15],"voices/numbers/5.wav",2);
	Msfx_smpload(&m_game_smp[16],"voices/numbers/6.wav",2);
	Msfx_smpload(&m_game_smp[17],"voices/numbers/7.wav",2);
	Msfx_smpload(&m_game_smp[18],"voices/numbers/8.wav",2);
	Msfx_smpload(&m_game_smp[19],"voices/numbers/9.wav",2);
	Msfx_smpload(&m_game_smp[20],"voices/numbers/10.wav",2);
	Msfx_smpload(&m_game_smp[21],"voices/numbers/11.wav",2);
	Msfx_smpload(&m_game_smp[22],"voices/numbers/12.wav",2);
	Msfx_smpload(&m_game_smp[23],"voices/numbers/13.wav",2);
	Msfx_smpload(&m_game_smp[24],"voices/numbers/14.wav",2);
	Msfx_smpload(&m_game_smp[25],"voices/numbers/15.wav",2);
	Msfx_smpload(&m_game_smp[26],"voices/numbers/16.wav",2);
	Msfx_smpload(&m_game_smp[27],"voices/numbers/17.wav",2);
	Msfx_smpload(&m_game_smp[28],"voices/numbers/18.wav",2);
	Msfx_smpload(&m_game_smp[29],"voices/numbers/19.wav",2);
	Msfx_smpload(&m_game_smp[30],"voices/numbers/20.wav",2);
	Msfx_smpload(&m_game_smp[31],"voices/numbers/30.wav",2);
	Msfx_smpload(&m_game_smp[32],"voices/numbers/40.wav",2);
	Msfx_smpload(&m_game_smp[33],"voices/numbers/50.wav",2);
	Msfx_smpload(&m_game_smp[34],"voices/numbers/60.wav",2);
	Msfx_smpload(&m_game_smp[35],"voices/numbers/70.wav",2);
	Msfx_smpload(&m_game_smp[36],"voices/numbers/80.wav",2);
	Msfx_smpload(&m_game_smp[37],"voices/numbers/90.wav",2);
	Msfx_smpload(&m_game_smp[38],"voices/numbers/100.wav",2);
	Msfx_smpload(&m_game_smp[39],"voices/numbers/2x.wav",2);
	Msfx_smpload(&m_game_smp[40],"voices/numbers/3x.wav",2);
	Msfx_smpload(&m_game_smp[41],"voices/numbers/4x.wav",2);
	Msfx_smpload(&m_game_smp[42],"voices/numbers/5x.wav",2);
	Msfx_smpload(&m_game_smp[43],"voices/numbers/6x.wav",2);
	Msfx_smpload(&m_game_smp[44],"voices/numbers/7x.wav",2);
	Msfx_smpload(&m_game_smp[45],"voices/numbers/8x.wav",2);
	Msfx_smpload(&m_game_smp[46],"voices/numbers/9x.wav",2);
	Msfx_smpload(&m_game_smp[47],"voices/numbers/1xx.wav",2);

	// commands...
	Msfx_smpload(&m_game_smp[48],"voices/commands/yellow.wav",2);
	Msfx_smpload(&m_game_smp[49],"voices/commands/green.wav",2);
	Msfx_smpload(&m_game_smp[50],"voices/commands/brown.wav",2);
	Msfx_smpload(&m_game_smp[51],"voices/commands/blue.wav",2);
	Msfx_smpload(&m_game_smp[52],"voices/commands/pink.wav",2);
	Msfx_smpload(&m_game_smp[53],"voices/commands/black.wav",2);
	Msfx_smpload(&m_game_smp[54],"voices/commands/ball.wav",2); //
	Msfx_smpload(&m_game_smp[55],"voices/commands/pleaseNominate.wav",2);
	Msfx_smpload(&m_game_smp[56],"voices/commands/foul.wav",2);
	Msfx_smpload(&m_game_smp[57],"voices/commands/fourAway.wav",2); //
	Msfx_smpload(&m_game_smp[58],"voices/commands/fiveAway.wav",2); //
	Msfx_smpload(&m_game_smp[59],"voices/commands/sixAway.wav",2); //
	Msfx_smpload(&m_game_smp[60],"voices/commands/sevenAway.wav",2);//

	Msfx_smpload(&m_game_smp[61],"voices/commands/touchingBall.wav",2);
	Msfx_smpload(&m_game_smp[62],"voices/commands/foulAndAMiss.wav",2);
	Msfx_smpload(&m_game_smp[63],"voices/commands/freeBall.wav",2);
	Msfx_smpload(&m_game_smp[64],"voices/commands/frameConceded.wav",2);
	Msfx_smpload(&m_game_smp[65],"voices/commands/frame.wav",2);
	Msfx_smpload(&m_game_smp[66],"voices/commands/frameAndTheMatch.wav",2);
	Msfx_smpload(&m_game_smp[67],"voices/commands/player1ToBreak.wav",2);
	Msfx_smpload(&m_game_smp[68],"voices/commands/player2ToBreak.wav",2);
	
	m_game_smp_n = 69;
	
	}
	else
	{
		m_game_smp_n = SFX_MAX;
	}
	
	#else // ipool
	m_game_smp_n = SFX_MAX;
	#endif
 
	//Mgfx_software3d = 0;//1; // should be 0 for hardware! (note: can only run ONE of these in harware mode)
	
/*
		Mmain_log("Mgfx_sprinit (g_spr3dSurface)");
	// create a 3D surface based on the desktop dimensions
	Mgfx_sprinit(&g_spr3dSurface, m_SizeDesktop.cx, m_SizeDesktop.cy, MGFX_SPR_VRAM|MGFX_SPR_3DDEVICE);
		Mmain_log("Mgfx_sprinit (g_spr3dSurfaceTmp)");
	Mgfx_sprinit(&g_spr3dSurfaceTmp, m_SizeDesktop.cx, m_SizeDesktop.cy, MGFX_SPR_VRAM|MGFX_SPR_3DDEVICE);
	

	Mgfx_sprinit(&g_spr3dSurface2, m_SizeDesktop.cx, m_SizeDesktop.cy, MGFX_SPR_VRAM|MGFX_SPR_3DDEVICE);
	

		Mmain_log("M3d_init");
	lpdds1 = g_spr3dSurface.surf;
	//Mmain_errordump("error.txt");


	if(Mmain_fatalerror==MMAIN_FATALERROR_INVALIDMODE)
	{
	if(g_build.gameType == GAMETYPE_SNOOKER)
		MessageBox("Invalid Video Mode. Please Try changing your Bit Depth, then run iSnooker again. If this doesn't workunsuccessful, please contact brandon@thesnookerclub.com for help.", g_appName, MB_OK);
	else if(g_build.gameType == GAMETYPE_POOL)
		MessageBox("Invalid Video Mode. Please Try changing your Bit Depth, then run iPool again. If this doesn't work please contact brandon@thepoolclub.com for help.", g_appName, MB_OK);

	
	char buffer[120];
	sprintf(buffer,"Memir Lib Init failed: Invalid Mode (%dx%d %dbpp)", m_SizeDesktop.cx,m_SizeDesktop.cy,g_bpp);
	Mmain_log(buffer);
	MessageBox("Could not create the Direct3DDevice object.\r\nThe 3D hardware chipset may not support rendering in the current display mode.\r\n\r\nTry changing the color quality (depth) from 24/32bit to 16bit\r\nRight Click on your Desktop, click Properties->Settings, then change 'Color Quality' to (16 bit)", g_appName, MB_OK);


	PostQuitMessage(0);
	return 0;
	}

*/
	////Mmain_errordump("error.txt");
	Mmain_log("Memir Lib Init complete");

	Mmain_log("Creating CSnooker object");
	m_snooker = new CSnooker(this);
	m_snooker->SetWindowSize(320,240);
	m_snooker->SetTableViewWindowSize(320,240);
	Mmain_log("Creating CReplay object");
	m_replay = new CReplay(1024); // 256 steps max in a replay!
	m_replay->SetReplayDlg(&m_replayDlg);
	Mmain_log("Creating CBot object");
	m_bot = new CBot(this);
	Mmain_log("Creating CBot object [DONE]");
	m_snooker->m_cameraOn = 1;
	m_snooker->m_CameraMode = CAMERA_MODE_PLAYER_2D;
	
	Mmain_log("Render3DSetupCamera");
	Render3DSetupCamera();
	Mmain_log("Render3DSetupCamera [DONE]");

	Mmain_log("LoadAdvertisements");
	// LoadAdvertisements(); - Note this causes crashing on some people's computer. Investigating this with a player to determine the cause.
	Mmain_log("LoadAdvertisements [DONE]");

#endif //!MAIN_SERVER //BAP_FIX
	
	
	Mmain_log("Creating CLobby object");
	m_lobby = new CLobby(this);



	Mmain_log("Initialization phase 2 complete");
	return CView::PreCreateWindow(cs);
}


BOOL CGameAppView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{

	//return 0;
	// TODO: Add your specialized code here and/or call the base class
	
	
	//Mmain_log("Creating CLobby object");
	//m_lobby = new CLobby(this);
	return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	//else return 0;
	
	//return 1;



}

/////////////////////////////////////////////////////////////////////////////
// CGameAppView drawing

void CGameAppView::ResizeScreenToSaved(void)
{

	//////////////////////////////////////////////////////////////////
	// re-size screen to saved settings.
	#ifndef MAIN_SERVER
	static BOOL firstTime = TRUE;
	if(firstTime)
	{
		firstTime = FALSE;


		// no saved data for app. screen resize
		if(g_gfxDetails.x == -1 && g_gfxDetails.y == -1 &&
		   g_gfxDetails.cx == -1 && g_gfxDetails.cy == -1)
		{
			if(AfxGetMainWnd()->IsWindowVisible()) AfxGetMainWnd()->ShowWindow(SW_SHOWMAXIMIZED);
		}
		
		// have valid saved data for screen resize
		else
		{
			// must be a maximised app.
			if(g_gfxDetails.x < 0 && g_gfxDetails.y < 0)
			{
				//AfxGetMainWnd()->ShowWindow(SW_SHOWMAXIMIZED);
				//if(g_hWnd) ::
				if(AfxGetMainWnd()->IsWindowVisible()) AfxGetMainWnd()->ShowWindow(SW_SHOWMAXIMIZED);
			}
			// normal resize/pos app.
			else
			{
				
				// check if resize is too large for desktop size or too small //
				if( (g_gfxDetails.cx > m_SizeDesktop.cx) ||
					(g_gfxDetails.cy > m_SizeDesktop.cy) )
					{
					g_gfxDetails.x = 0;
					g_gfxDetails.y = 0;
					g_gfxDetails.cx = m_SizeDesktop.cx;
					g_gfxDetails.cy = m_SizeDesktop.cy;
					}

					
				// Window Size Constraints //
				if(g_gfxDetails.cx < MAINFRM_MINIMUM_WIDTH) g_gfxDetails.x = 0, g_gfxDetails.cx = MAINFRM_MINIMUM_WIDTH;
				if(g_gfxDetails.cy < MAINFRM_MINIMUM_HEIGHT) g_gfxDetails.y = 0, g_gfxDetails.cy = MAINFRM_MINIMUM_HEIGHT;
				if(g_gfxDetails.cx > Mmain_iDesktopWidth) g_gfxDetails.x = 0, g_gfxDetails.cx = Mmain_iDesktopWidth;
				if(g_gfxDetails.cy > Mmain_iDesktopHeight) g_gfxDetails.y = 0, g_gfxDetails.cy = Mmain_iDesktopHeight;
	//
				// resize the app's window


				AfxGetMainWnd()->MoveWindow(g_gfxDetails.x, g_gfxDetails.y, g_gfxDetails.cx, g_gfxDetails.cy);
			}
		}



	}
	#endif //!MAIN_SERVER
	//////////////////////////////////////////////////////////////////
}

void CGameAppView::OnDraw(CDC* pDC)
{

	static BOOL firstTime = TRUE;
	

	if(m_lobby->m_bInLobby)
	{// LOBBY //
		OnDrawLobby(pDC);
	}// LOBBY //
	else
	{// SNOOKER //
		OnDrawSnooker(pDC);

		
		
	//if(g_gameAppView) ErrorMessage(g_gameAppView, buffer);
	
	}// SNOOKER //


/*
	if(firstTime)
	{
		firstTime = FALSE;
		
		Mmain_log("OnDraw(...) - ResizeScreenToSaved()");
		// re-sizes screen to saved settings size (call this once only on app. startup
		ResizeScreenToSaved();
	}
*/


}

void CGameAppView::DrawBitmap(CDC* pDC,int aX, int aY,  HBITMAP hBitmap)
{
    BITMAP bm;
    CDC memDC;
    memDC.CreateCompatibleDC(NULL);
    ::GetObject( hBitmap, sizeof( bm ), &bm );
    HBITMAP hbmOld = (HBITMAP)memDC.SelectObject(hBitmap);
    pDC->BitBlt( aX,aY,bm.bmWidth,bm.bmHeight,&memDC,0,0,SRCCOPY);
    memDC.SelectObject( hbmOld );
    memDC.DeleteDC();
}

void CGameAppView::DrawBitmapRegion(CDC* pDC, int x1, int y1, int x2, int y2, HBITMAP hBitmap)
{
	
    BITMAP bm;
	
    CDC memDC;
    memDC.CreateCompatibleDC(NULL);
    ::GetObject( hBitmap, sizeof( bm ), &bm );
    HBITMAP hbmOld = (HBITMAP)memDC.SelectObject(hBitmap);
    
	if(x1 < 0 || (x2-x1) > bm.bmWidth) return;
	if(y1 < 0 || (y2-y1) > bm.bmHeight) return;
	
	pDC->BitBlt(x1, y1, (x2-x1), (y2-y1), &memDC, 0, 0, SRCCOPY);
    memDC.SelectObject( hbmOld );
    memDC.DeleteDC();
}

void CGameAppView::DrawBitmapScale(CDC* pDC, int x1, int y1, int width, int height, HBITMAP hBitmap)
{
    BITMAP bm;
    CDC memDC;
    memDC.CreateCompatibleDC(NULL);
    ::GetObject( hBitmap, sizeof( bm ), &bm );
    HBITMAP hbmOld = (HBITMAP)memDC.SelectObject(hBitmap);
	pDC->StretchBlt(x1, y1, width, height, &memDC, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
    memDC.SelectObject( hbmOld );
    memDC.DeleteDC();
}



HBITMAP	skin_buttonsbg;
HBITMAP BitmapSkin[54];


CBitmap tbmp;
CDC dcMemoryTemp;
CDC dcMemoryTemp2;

void CGameAppView::OnDrawSnooker(CDC* pDC)
{


#ifndef MAIN_SERVER

	// Don't Draw anything for first 60 frames

	
	if (g_pDevice == NULL) return;

	static BOOL firstTimeOnDS = TRUE;

	
	m_snooker->m_bRefreshScores = TRUE;
	
	if (g_pDevice != NULL)
	{

		// menu control code for drawing!
		if (g_menuNItemID != -1 || m_snooker->m_cueBallSelect != 2) // menu change, or if not in simulation mode //[NEW CP]
		//if(g_menuNItemID != -1)// || g_active)
		{
			// do 3D/2D drawing
			m_environment->Update(); // Update lighting etc.
			Draw3D(0);
			//DrawMini3D();
			Draw2D(0);
			if (m_snooker->m_cueBallSelect != 2); //[NEW CP]
			else return; //[NEW CP]
			//return;
		}

		if (g_bMenuSelect) return;
		if (m_bDisableOnDraw) return;

		if (firstTimeOnDS) Mmain_log("OnDrawSnooker(...) - menu control code for drawing!");

		// menu control code for drawing!
		if (m_bJustExitedLobby || m_bOnSize)
		{
			m_bJustExitedLobby = FALSE;
			m_bOnSize = FALSE;
			int offsetX = 788 - m_cx; // 800
			int offsetY = 542 - m_cy; // 600
			float fX = (float)(m_cx) / 1182;
			float fY = (float)(m_cx)*0.5f / 1182;
			CPen pen(PS_NULL, 0, RGB(0, 0, 0));
			CBrush brush(RGB(20, 20, 20));
			CBrush borderBrush(RGB(243, 246, 29));

			// do 3D/2D drawing
			m_environment->Update(); // Update lighting etc.
			//Draw3D();
			//DrawMini3D();
			Draw2D(0);

			if (g_menuNItemID != -1) goto drawChildWindow;
		}

		if (m_snooker->m_cueBallSelect == 2) // if in simulation mode (cueballselect = 2), just do for ondraws!
			Draw2D(0);

	}

drawChildWindow:

	if(firstTimeOnDS) 
		{
		// firstTimeOnDS = false;
		Mmain_log("OnDrawSnooker(...) - re-draw all child windows");
		
		
		// Create an in-memory DC compatible with the display DC we're using to paint
		dcMemoryTemp.CreateCompatibleDC(pDC);
		// Select the bitmap into the in-memory DC
		dcMemoryTemp.SelectObject(BitmapSkin[SKIN_CHATEDITRIGHTT]);

		// m_testSprite->Init(pDC);
		m_lobbyButtons->Init(pDC);
		m_findMatchCtrl->Init(pDC);

		

		}

	int xpos_start, ypos_start;
	int xpos1,ypos1;
	int xpos2,ypos2;
	int width, height;
	int border = 14;
	int t_width, t_height;

	
	CRect clientrect;
	::GetWindowRect(g_hwndDX, clientrect);
	ypos_start = clientrect.Height()+2;

	int chat_height = (int)m_cy - ypos_start;

	
	// - re-draw all child windows
	// - set the child windows pos/size based on parent pos/size
	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	int squareHeight = chat_height; //m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view
	int excess_w = m_cx - (squareHeight + (72*2 + 19));
	int initial_w = (300+40) + (100+g_FIX_shiftX-40);
	g_FIX_SpareW = excess_w - initial_w;
	if(g_FIX_SpareW < 0) g_FIX_SpareW = 0;
				
	CRect tmpRect;
	CSize tmpSize;
	CPoint tmpPoint;
	m_sendEdit.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	


	CRect r1;
	m_sliderRaiseButt.GetClientRect(&r1);




	xpos_start	= 163 + chat_height + 15;
	
	
	t_width		= 320+g_FIX_SpareW-30;
	t_height	= chat_height - 34; //(m_cy - (469-ceil(offsetX*0.5f)-g_yBarOffset));

	xpos1 = xpos_start+12;
	ypos1 = ypos_start+8;
	width = 220+g_FIX_SpareW-18-30;
	height = 22;


	CPen pen_blueborder(PS_SOLID, 1, RGB(23,33,52));
	
	CBrush brush_white(RGB(255,255,255));
	CBrush brush_skyblue(RGB(131,95,56));
	CPen pen_skyblue(PS_SOLID, 1, RGB(131,95,56));
	CPen pen_white(PS_SOLID, 1, RGB(255,255,255));
	CBrush *oldBrush = pDC->SelectObject(&brush_skyblue);
	pDC->SelectObject(&pen_skyblue);
	
	
	//pDC->Rectangle(xpos_start, ypos_start, xpos_start+t_width+border, ypos_start+22+border*2);		// BackGround Rectangle (TOP)


	//xpos1 = 163 + squareHeight + r1.Width() + 8;
	
	pDC->SelectObject(&pen_blueborder);
	m_sendEdit.SetWindowPos(&wndTop, xpos1, ypos1, width, height, SWP_SHOWWINDOW);


	// Smiley Button :D //
	width-=2;
	m_sayButton.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	xpos1 += width + 10;
	m_sayButton.SetWindowPos(&wndTop, xpos1, ypos1-4, tmpSize.cx, 27, SWP_SHOWWINDOW);


	xpos1 += tmpSize.cx;
	m_smileyselectButton.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	m_smileyselectButton.SetWindowPos(&wndTop, xpos1+3, ypos1-4, tmpSize.cx, 27, SWP_SHOWWINDOW);

	
	// Top-Left
	height = t_height-118;
	//BitmapSkinEx[SKIN_CHATEDITLEFTT].Draw(pDC, xpos_start, ypos_start);
	DrawBitmap(pDC, xpos_start, ypos_start, BitmapSkin[SKIN_CHATEDITLEFTT]);
	// Left (This is stretched to fit the height of the Chat Area //
	//BitmapSkinEx[SKIN_CHATEDITLEFTM].DrawScale(pDC, xpos_start, ypos_start+128,12,height);
	DrawBitmapScale(pDC, xpos_start, ypos_start+128,12,height, BitmapSkin[SKIN_CHATEDITLEFTM]);
	// Bottom-Left
	//BitmapSkinEx[SKIN_CHATEDITLEFTB].Draw(pDC, xpos_start, ypos_start+128+height);
	DrawBitmap(pDC, xpos_start, ypos_start+128+height, BitmapSkin[SKIN_CHATEDITLEFTB]);
	


	// Top Strip - Stretched to fit width of Chat Area //
	//BitmapSkinEx[SKIN_CHATEDITTOP1].DrawScale(pDC, xpos_start+12, ypos_start,(t_width-292+186)-12,8);
	DrawBitmapScale(pDC, xpos_start+12, ypos_start,(t_width-292+186)-10,8, BitmapSkin[SKIN_CHATEDITTOP1]);

	// Middle Strip - Stretched to fit width of Chat Area //
	//BitmapSkinEx[SKIN_CHATEDITMID1].DrawScale(pDC, xpos_start+12, ypos_start+22+8,(t_width-292+186)-12,8);
	DrawBitmapScale(pDC, xpos_start+12, ypos_start+22+8,(t_width-292+186)-10,8, BitmapSkin[SKIN_CHATEDITMID1]);

	// Horrizontal Bottom Strips - Stretched to fit width of Chat Area //
	//BitmapSkinEx[SKIN_CHATEDITBOT1].DrawScale(pDC, xpos_start+12, ypos_start+t_height+28,t_width-23,6);		// Left Part
	DrawBitmapScale(pDC, xpos_start+12, ypos_start+t_height+28,t_width-23,6, BitmapSkin[SKIN_CHATEDITBOT1]);
	//BitmapSkinEx[SKIN_CHATEDITBOT1].DrawScale(pDC, xpos_start+12+t_width-11, ypos_start+t_height+28,176,6);		// Right Part
	DrawBitmapScale(pDC, xpos_start+12+t_width-11, ypos_start+t_height+28,176+30,6, BitmapSkin[SKIN_CHATEDITBOT1]);

	//BitmapSkinEx[SKIN_CHATEDITBOT1].DrawScale(pDC, xpos_start+12, ypos_start+t_height+28,t_width+174,6);

	// Vertical Middle Strip (80 pixels) //
	//BitmapSkinEx[SKIN_CHATEDITMID2].Draw(pDC, xpos_start+12+t_width-23, ypos_start+48);
	DrawBitmap(pDC, xpos_start+12+t_width-23, ypos_start+48, BitmapSkin[SKIN_CHATEDITMID2]);
	// Vertical Middle Strip (Stretched to fit Height Chat Area)
	//BitmapSkinEx[SKIN_CHATEDITMID3].DrawScale(pDC, xpos_start+12+t_width-23, ypos_start+48+80, 12, height+18);
	DrawBitmapScale(pDC, xpos_start+12+t_width-23, ypos_start+48+80, 12, height+18, BitmapSkin[SKIN_CHATEDITMID3]);
	// Vertical Middle Strip (12x12 pixels height) - Base of Chat Area
	//BitmapSkinEx[SKIN_CHATEDITMID4].Draw(pDC, xpos_start+12+t_width-23, ypos_start+t_height+22);
	DrawBitmap(pDC, xpos_start+12+t_width-23, ypos_start+t_height+22, BitmapSkin[SKIN_CHATEDITMID4]);


	// Vertical Right Strip (80 pixels) Right of ListBox //
	DrawBitmap(pDC, xpos_start+12+t_width+193, ypos_start+48, BitmapSkin[SKIN_CHATEDITRIGHTM1]);
	// Vertical Right Strip (Stretched to fit Height List Box)
	DrawBitmapScale(pDC, xpos_start+12+t_width+193, ypos_start+48+80, 12, height+18, BitmapSkin[SKIN_CHATEDITRIGHTM2]);
	// Vertical Right Strip (12x12 pixels height) - Base of List Box
	DrawBitmap(pDC, xpos_start+12+t_width+193, ypos_start+t_height+22, BitmapSkin[SKIN_CHATEDITRIGHTM3]);
	
		
	
	// Exclude Smiley, Send Button and Top Part of Player List Regions //
	CRect cliprect;
	m_sayButton.GetWindowRect(&cliprect);
	
	
	cliprect.left= xpos_start+t_width-292+186 + 8;
	cliprect.top = ypos_start + 4;
	cliprect.right = xpos_start+t_width-292+186 + 36;
	cliprect.bottom = ypos_start + 30;
	pDC->ExcludeClipRect(&cliprect);


	cliprect.left= xpos_start+t_width-292+186 + 39;
	cliprect.top = ypos_start + 4;
	cliprect.right = xpos_start+t_width-292+186 + 67;
	cliprect.bottom = ypos_start + 30;
	pDC->ExcludeClipRect(&cliprect);


	
	cliprect.left= xpos_start+t_width-292+186 + -1;
	cliprect.top = ypos_start + 38;
	cliprect.right = xpos_start+t_width-292+186 + 95;
	cliprect.bottom = ypos_start + 48;
	pDC->ExcludeClipRect(&cliprect);
	
	cliprect.left= xpos_start+t_width-292+186 + 107;
	cliprect.top = ypos_start + 9;
	cliprect.right = xpos_start+t_width-292+186 + 281+30;
	cliprect.bottom = ypos_start + 48;
	pDC->ExcludeClipRect(&cliprect);
	
	
	pDC->BitBlt(xpos_start+t_width-292+186, ypos_start, 322, 48, &dcMemoryTemp, 0, 0, SRCCOPY);
	
	cliprect.left = 0;
	cliprect.top = 0;
	cliprect.right = 0;
	cliprect.bottom = 0;
	pDC->ExcludeClipRect(&cliprect);


	
	xpos1 = xpos_start + 12;
	//xpos1 = 163 + squareHeight + r1.Width() + 8;
	ypos1 = ypos_start + 50;
	width = t_width - (border*1.5);
	height = t_height - border;

	m_editExChat.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	m_editExChat.SetWindowPos(&wndTop, xpos1, ypos1-12, width-2, height+4, SWP_SHOWWINDOW);
	m_editExChat.ShowScrollBar(SB_VERT);


	int lp_x, lp_y;
	int lp_w, lp_h;
	lp_x = xpos_start+12+12+width-2;//688-offsetX-g_FIX_shiftX+34+1;
	lp_y = ypos_start;
	lp_w = 205;
	lp_h = height+33;



	m_listBox.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();

	m_listBox.SetWindowPos(&wndTop, lp_x, lp_y+9, lp_w, lp_h, SWP_SHOWWINDOW);
	//m_listBox.SetWindowPos(&wndTop, 0,0,0,0, SWP_HIDEWINDOW);
	m_listBox.ShowScrollBar(SB_VERT);


	//pDC->SelectObject(&brush_white);
	//pDC->SelectObject(&pen_white);
	//pDC->Rectangle(lp_x-1, lp_y+4, lp_x+lp_w+1, lp_y+10);		// BackGround Rectangle (TOP)
		
	
	//m_listPlayers.SetWindowPos(&wndTop, lp_x, lp_y+10, lp_w, lp_h, SWP_SHOWWINDOW);
	//m_listPlayers.ShowScrollBar(SB_VERT);

	
	// Lobby HTML Pages //
	
	// Hide - Inactivate LeaderBoardA //
	if(m_htmlViewLeaderBoardA.IsWindowVisible())
		{
		m_htmlViewLeaderBoardA.GetWindowRect(&tmpRect);
		tmpSize = tmpRect.Size();
		tmpPoint =  tmpRect.TopLeft();
		m_htmlViewLeaderBoardA.SetWindowPos(&wndTop, tmpPoint.x, tmpPoint.y, tmpSize.cx, tmpSize.cy, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		}
	
	// Hide - Inactivate Banner //
	if(m_htmlViewBanner.IsWindowVisible())
		{
		m_htmlViewBanner.GetWindowRect(&tmpRect);
		tmpSize = tmpRect.Size();
		tmpPoint =  tmpRect.TopLeft();
		m_htmlViewBanner.SetWindowPos(&wndTop, tmpPoint.x, tmpPoint.y, tmpSize.cx, tmpSize.cy, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		}
		
	// Hide - Inactivate LeaderBoardB //
	if(m_htmlViewLeaderBoardB.IsWindowVisible())
		{
		m_htmlViewLeaderBoardB.GetWindowRect(&tmpRect);
		tmpSize = tmpRect.Size();
		tmpPoint =  tmpRect.TopLeft();
		m_htmlViewLeaderBoardB.SetWindowPos(&wndTop, tmpPoint.x, tmpPoint.y, tmpSize.cx, tmpSize.cy, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		}
	
	// Hide - Inactivate TickerBoard //
	if(m_htmlViewTickerBoard.IsWindowVisible())
		{
		m_htmlViewTickerBoard.GetWindowRect(&tmpRect);
		tmpSize = tmpRect.Size();
		tmpPoint =  tmpRect.TopLeft();
		m_htmlViewTickerBoard.SetWindowPos(&wndTop, tmpPoint.x, tmpPoint.y, tmpSize.cx, tmpSize.cy, SWP_HIDEWINDOW);
		}
	
	
	// Hide - Inactivate MB //
	if(m_htmlViewMB.IsWindowVisible())
		{
		m_htmlViewMB.GetWindowRect(&tmpRect);
		tmpSize = tmpRect.Size();
		tmpPoint =  tmpRect.TopLeft();
		m_htmlViewMB.SetWindowPos(&wndTop, tmpPoint.x, tmpPoint.y, tmpSize.cx, tmpSize.cy, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		}




	// hide/inactivate refresh button
	m_exitlobbyButton.SetWindowPos(&wndTop, 0,0,80,24, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_changelobbyButton.SetWindowPos(&wndTop, 0,0,80,24, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_messageBoardFullButton.SetWindowPos(&wndTop, 0,0,80,24, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_homeButton.SetWindowPos(&wndTop, 0,0,80,24, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_registerButton.SetWindowPos(&wndTop, 0,0,80,24, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	// m_leaguesButton.SetWindowPos(&wndTop, 0,0,80,24, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_tourneysButton.SetWindowPos(&wndTop, 0,0,80,24, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_refreshButton.SetWindowPos(&wndTop, 0,0,80,24, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_viewtablesButton.SetWindowPos(&wndTop, 0,0,80,24, SWP_NOACTIVATE | SWP_HIDEWINDOW);

	// hide/inactivate enter lobby button
	m_EnterLobbyButton.SetWindowPos(&wndTop, 0,0,72,26, SWP_NOACTIVATE | SWP_HIDEWINDOW);

	// hide/inactivate this child window
	
	m_listPlayers.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	m_listPlayers.SetWindowPos(&wndTop, tmpPoint.x, tmpPoint.y, tmpSize.cx, tmpSize.cy, SWP_NOACTIVATE | SWP_HIDEWINDOW);

	// hide/inactivate this child window
	m_listTables.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	m_listTables.SetWindowPos(&wndTop,  tmpPoint.x, tmpPoint.y, tmpSize.cx, tmpSize.cy, SWP_NOACTIVATE | SWP_HIDEWINDOW);

	// hide/inactivate this child window
	m_tableTabCtrlDlg.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	m_tableTabCtrlDlg.SetWindowPos(&wndTop,  tmpPoint.x, tmpPoint.y, tmpSize.cx, tmpSize.cy, SWP_NOACTIVATE | SWP_HIDEWINDOW);

	// hide lobby's tabctrl child window
	m_tabLobbyCtrlEx.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	m_tabLobbyCtrlEx.SetWindowPos(&wndTop,  tmpPoint.x, tmpPoint.y, tmpSize.cx, tmpSize.cy, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	
	// hide lobby's tabctrl child window (only if online, else destroy on exit from lobby)
	
	if( m_lobby->GetPlayerIdx(m_playerSockIdx) !=-1 )
	{
		////////////
		if(m_lobbySelectDlg) 
		{
			m_lobbySelectDlg.GetWindowRect(&tmpRect);
			tmpSize = tmpRect.Size();
			tmpPoint =  tmpRect.TopLeft();
			m_lobbySelectDlg.SetWindowPos(&wndTop,  tmpPoint.x, tmpPoint.y, tmpSize.cx, tmpSize.cy, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		}
	}


	// redraw / update all child windows
	
	m_sendEdit.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_sayButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_smileyselectButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_editExChat.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	if(m_listBox.IsWindowVisible()) m_listBox.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	if(m_listPlayers.IsWindowVisible()) m_listPlayers.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

	//m_listTables.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	//m_tableTabCtrlDlg.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	//m_tabLobbyCtrlEx.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

	//if(m_SmileySelectDlg.IsWindowVisible()) m_SmileySelectDlg.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

	//int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view

	m_sliderRaiseButt.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	//m_sliderRaiseButt.SetWindowPos(&wndTop, 163+squareHeight, (int)(435-ceil(offsetX*0.5f)-g_yBarOffset), 15, (int)(m_cy - (435-ceil(offsetX*0.5f)-g_yBarOffset)), SWP_SHOWWINDOW);

	m_sliderRaiseButt.SetWindowPos(&wndTop, 163+chat_height, ypos_start, 15, chat_height, SWP_SHOWWINDOW);


	m_sliderRaiseButt.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);// | RDW_FRAME);
	if( m_lobby->GetPlayerIdx(m_playerSockIdx) !=-1 ) 
	{
		if(m_lobbySelectDlg) m_lobbySelectDlg.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	}
	
//	// redraw 'end practice session' button
//	if(m_snooker->m_bPracticeMode)
//	if(!m_snooker->m_bComputerMode)
//	{
//		m_EndPracticeButton.GetWindowRect(&tmpRect);
//		tmpSize = tmpRect.Size();
//		tmpPoint =  tmpRect.TopLeft();
//		m_EndPracticeButton.SetWindowPos(&wndTop, 0.5*m_cx+74, 0.5f*m_cx+5, 200+74, 30, SWP_SHOWWINDOW);
//		m_EndPracticeButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);// | RDW_FRAME);
//	}
	
	if(firstTimeOnDS) Mmain_log("OnDrawSnooker(...) - re-draw buttons");


	// Load the Button BackGround Texture into Memory - Quicker Rendering and allows us to draw pieces //
	if(firstTimeOnDS)
		{
		// Create an in-memory DC compatible with the display DC we're using to paint
		dcMemoryTemp2.CreateCompatibleDC(pDC);
		dcMemoryTemp2.SelectObject(BitmapSkin[SKIN_TABLEBUTTONS]);

		// Draw Rated and Miss-Rule / CallShots Text //
		//CBrush white = RGB(255,255,255);
		dcMemoryTemp2.SelectObject(&m_checkBoxFont);
		dcMemoryTemp2.SetBkMode(TRANSPARENT);
		dcMemoryTemp2.SetTextColor(RGB(255,255,255));
		dcMemoryTemp2.TextOut(103,94,"Rated");
		if(g_build.gameType == GAMETYPE_SNOOKER) dcMemoryTemp2.TextOut(84,116,"Miss Rule");
			else dcMemoryTemp2.TextOut(84,116,"Call Shots");

		//pDC->SelectObject(&m_checkBoxFont);
		}

	


	// Draw BackGround behind the Table Buttons /
	xpos1 = 0;
	ypos1 = ypos_start;
	xpos2 = xpos1+100;
	ypos2 = ypos1+chat_height;

	CBrush BrushBG(RGB(255,20,20));
	pDC->BitBlt(xpos1, ypos1, 200, chat_height, &dcMemoryTemp2, 0, 0, SRCCOPY);
	//DrawBitmapRegion(pDC, xpos1, ypos1, 160, ypos1+height+48, BitmapSkin[SKIN_TABLEBUTTONS]);


	xpos1 += 6;
	// redraw some buttons
	int x, y, w, h, n;
	n = 0;
	w = 70;
	h = 20;//30;
	int hoff = 2;


	for(x=0;x<2;x++)
	for(y=0;y<4;y++)
	{
		if(n==4) // Stand Up
		{
			if(!m_snooker->m_bPracticeMode)
			{
				m_standButton.SetWindowPos(&wndTop, xpos1 + (w+5)*x, ypos1+(h+hoff)*y+4, w, h, SWP_SHOWWINDOW);
				m_standButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
				m_button[n].SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
				m_button[n].RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
			}
			else
			{
				m_button[n].SetWindowPos(&wndTop, xpos1 + (w+5)*x, ypos1+(h+hoff)*y+4, w, h, SWP_SHOWWINDOW);
				m_button[n].RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
				m_standButton.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
				m_standButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
			}
		}
		else
		{
			m_button[n].SetWindowPos(&wndTop, xpos1 + (w+5)*x, ypos1+(h+hoff)*y+4, w, h, SWP_SHOWWINDOW);
			m_button[n].RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);		
		}
		n++;
		
		//if(g_build.gameType == GAMETYPE_SNOOKER)
		//{
		//	if(n == 7) goto endxy;
		//}
		//else if(g_build.gameType == GAMETYPE_POOL)
		{
			if(n == 8)
			{
				y--;
				goto endxy;
			}
		}
	}
	
endxy:;
	y++;
	x++;
	

	// Rated Button
	m_ratedButton.SetWindowPos(&wndTop, xpos1 + 130, ypos_start + 93,
												15, 15, SWP_SHOWWINDOW);
	m_ratedButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);


	// Table Type Combobox
	m_tableTypeBox.SetWindowPos(&wndTop, xpos1, ypos_start + 93,
											  0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
	m_tableTypeBox.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	// miss-rule Button
	//if(g_build.gameType == GAMETYPE_SNOOKER)

	y++;
	m_missRuleButton.SetWindowPos(&wndTop, xpos1 + 130, ypos_start + 93 + 20,
											15, 15, SWP_SHOWWINDOW);
	m_missRuleButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);





	
	if( m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 )
	{
			DrawSeatsOnly(m_cx, m_cy);
	}
	
	if(m_snooker->m_bComputerMode)
		ComputerPracticeOnDraw(pDC, m_cx, m_cy);
	
	if(firstTimeOnDS) Mmain_log("OnDrawSnooker(...) - DisplayFoulUpdate();");
	
	DisplayFoulUpdate();

	if (firstTimeOnDS)
	{
		firstTimeOnDS = FALSE;
	}
	
#endif //!MAIN_SERVER
}



void CGameAppView::OnDrawBanners(CDC* pDC)
{
/*
	BITMAP bm;
	m_bitmapBanner[m_bitmapBanner_idx].GetBitmap(&bm);
	m_bitmapBanner[m_bitmapBanner_idx].Draw(pDC,m_cx*0.5f - bm.bmWidth*0.5f,0);

	m_bitmapSubBanner[m_bitmapSubBanner_idx].GetBitmap(&bm);
	m_bitmapSubBanner[m_bitmapSubBanner_idx].Draw(pDC,m_cx*0.5f - bm.bmWidth*0.5f,73);
*/
}


int tv_timer;
CDC dcMemoryTempL;
CDC dcMemoryTempR;


void CGameAppView::OnDrawLobby(CDC* pDC)
{

	// menu control code for drawing!
	CRect tmpRect;
	CRect tmpRect2;
	CSize tmpSize;
	CPoint tmpPoint;

	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	float fX = (float)(m_cx) / 1182;
	float fY = (float)(m_cx)*0.5f / 1182;
	int widthMixedMode = 4+(70 + 50 + 100 + 100)+::GetSystemMetrics(SM_CXVSCROLL);
	int tv_x, tv_y, tv_w, tv_h;
	tv_x = 0;
	tv_y = 107;
	tv_w = (float)(m_cx) * 0.33f;
	tv_h = (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-2;

	int gap = (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100 - tv_h;
	gap /= 2;
	tv_y += gap;
	static char first_time = 1;
	
#ifndef MAIN_SERVER	
	

	if(first_time == 1)
	{
	// Create an in-memory DC compatible with the display DC we're using to paint
	dcMemoryTempL.CreateCompatibleDC(pDC);
	// Select the bitmap into the in-memory DC
	dcMemoryTempL.SelectObject(BitmapSkin[SKIN_LOBBYCHATEDITRIGHTT]);

	// Same for Ranks Image, we need this in Memory so we can draw the portion we want //
	dcMemoryTempR.CreateCompatibleDC(pDC);	
	dcMemoryTempR.SelectObject(BitmapSkin[SKIN_RANKS]);
	}

	//CPen pen_skyblue(PS_NULL, 0, RGB(0,85,229));
	CPen pen_skyblue(PS_NULL, 0, RGB(255,85,85));
	CPen pen_white(PS_NULL, 0, RGB(255,255,255));
		
	CBrush brush_blueborder(RGB(118,169,255));
	
	//CBrush brush_lobbybg(RGB(143,127,107));	// BG1
	CBrush brush_lobbybg(RGB(59,19,0));		// BG2
	

	
	CBrush brush_chatbg(RGB(0,55,179));
	CBrush brush_blue(RGB(0,95,246));
	CBrush brush_black(RGB(0,0,0));
	CBrush brush_white(RGB(255,255,255));
	//CBrush borderBrush(RGB(107,172,96));

	CBrush bannerBrushGreen(RGB(0,128,0));
	CBrush bannerBrushBlack(RGB(0,0,0));
	CBrush bannerBrushBlue(RGB(0,0,128));

	// Debug fill background blue
	// pDC->FillRect(CRect(0, 0, 1480, 1024), &bannerBrushBlue);
	
	int border = 4;
	int xpos1, xpos2;
	int ypos1, ypos2;

	int t_height	= (m_cy - (469-ceil(offsetX*0.5f)-g_yBarOffset));
	CRect cliprect;
	int xpos_start, ypos_start, height, width;


	
	// Create Cliping Areas //

	// Exclude Smiley and Send Button Regions //
	

	
	//cliprect.left= 9;
	//cliprect.top = 18;
	//cliprect.right = 185;
	//cliprect.bottom = 78;
	//pDC->ExcludeClipRect(&cliprect);

	//BitmapSkinEx[SEMIPROHIGHBREAKSBG_LEFT].Draw(pDC, 0, 0);
	DrawBitmap(pDC, 0, 0, BitmapSkin[SEMIPROHIGHBREAKSBG_LEFT]);


	//cliprect.left= m_cx-192+10;
	//cliprect.top = 18;
	//cliprect.right = m_cx-192+9+176;
	//cliprect.bottom = 78;
	//pDC->ExcludeClipRect(&cliprect);
	
	//BitmapSkinEx[PROHIGHBREAKSBG_LEFT].Draw(pDC, m_cx-192, 0);
	DrawBitmap(pDC, m_cx-192, 0, BitmapSkin[PROHIGHBREAKSBG_LEFT]);



	// Send Area Skinning

	xpos1 = 145;
	xpos2 = xpos1 + 519-offsetX-g_FIX_shiftX-50-20;
	ypos1 = m_cy-100-87 + offsetY*0.5f-1;
	ypos2 = ypos1+22;

	
	xpos_start = xpos1;
	ypos_start = ypos1;
	height = 100;

	
	// Top-Left
	height = m_cy-g_yBarOffset-560;

	t_height	= (m_cy - (469-ceil(offsetX*0.5f)-g_yBarOffset));


	// Vertical Middle Strip (Stretched to fit Height Chat Area)
	//BitmapSkinEx[SKIN_CHATEDITMID3].DrawScale(pDC, xpos_start+12+t_width-23, ypos_start+48+80, 12, height+18);
	//DrawBitmapScale(pDC, xpos_start+12+t_width-23, ypos_start+48+80, 12, height+18, BitmapSkin[SKIN_CHATEDITMID3]);
	// Vertical Middle Strip (12x12 pixels height) - Base of Chat Area
	//BitmapSkinEx[SKIN_CHATEDITMID4].Draw(pDC, xpos_start+12+t_width-23, ypos_start+t_height+22);
	//DrawBitmap(pDC, xpos_start+12+t_width-23, ypos_start+t_height+22, BitmapSkin[SKIN_CHATEDITMID4]);



	//BitmapSkinEx[SKIN_LOBBYCHATEDITLEFTT].Draw(pDC, xpos_start, ypos_start);
	DrawBitmap(pDC, xpos_start, ypos_start, BitmapSkin[SKIN_LOBBYCHATEDITLEFTT]);
	// Left (This is stretched to fit the height of the Chat Area //
	//BitmapSkinEx[SKIN_LOBBYCHATEDITLEFTM].DrawScale(pDC, xpos_start, ypos_start+128,12,ypos1-310);
	DrawBitmapScale(pDC, xpos_start, ypos_start+128, 12, ypos1-310, BitmapSkin[SKIN_LOBBYCHATEDITLEFTM]);
	// Bottom-Left
	//BitmapSkinEx[SKIN_LOBBYCHATEDITLEFTB].Draw(pDC, xpos_start, m_cy-24);
	DrawBitmap(pDC, xpos_start, m_cy-24, BitmapSkin[SKIN_LOBBYCHATEDITLEFTB]);


	width = 430-offsetX-g_FIX_shiftX-30;
	// Horrizontal strips above and below SendEdit //
	//BitmapSkinEx[SKIN_LOBBYCHATTOP1].DrawScale(pDC, xpos_start+12, ypos_start, width, 8);
	//BitmapSkinEx[SKIN_LOBBYCHATMID1].DrawScale(pDC, xpos_start+12, ypos_start+22+8, width, 8);
	DrawBitmapScale(pDC, xpos_start+12, ypos_start, width+2-160, 8, BitmapSkin[SKIN_LOBBYCHATTOP1]);
	DrawBitmapScale(pDC, xpos_start+12, ypos_start+22+8, width+2-160, 8, BitmapSkin[SKIN_LOBBYCHATMID1]);
	// Horrizontal strips under ChatEdit //
	//BitmapSkinEx[SKIN_LOBBYCHATBOT1].DrawScale(pDC, xpos_start+12, m_cy-6, width+95,6);
	//BitmapSkinEx[SKIN_LOBBYCHATBOT1].DrawScale(pDC, xpos_start+12+width+95+12, m_cy-6, 204,6);
	DrawBitmapScale(pDC, xpos_start + 12, m_cy - 6, width + 95 + 204 + 30+12, 6, BitmapSkin[SKIN_LOBBYCHATBOT1]);
	// DrawBitmapScale(pDC, xpos_start+12+width+95, m_cy-6, 204+30, 6, BitmapSkin[SKIN_LOBBYCHATBOT1]);


	// Vertical strips right of Send & Chat Edit //
	xpos2 = 688+100-offsetX-g_FIX_shiftX+20-190-23-8-30;
	
	// Left of Find Match Ctrl
	DrawBitmap(pDC, xpos2+95-160, ypos_start+48, BitmapSkin[SKIN_LOBBYCHATMIDL2]);
	DrawBitmapScale(pDC, xpos2+95-160, ypos_start+48+80, 8, 50-offsetY*0.5f-1, BitmapSkin[SKIN_LOBBYCHATMIDL3]);
	DrawBitmap(pDC, xpos2 + 95 - 160, m_cy - 12, BitmapSkin[SKIN_LOBBYCHATMIDL4]);
	
	// Find Match Ctrl (Finally some new content!)
	m_findMatchCtrl->SetPosition(xpos2 + 95 - 160 + 8, ypos_start, 160, (m_cy-ypos_start-6));
	


	// Right of Find Match Ctrl
	DrawBitmap(pDC, xpos2 + 103, ypos_start, BitmapSkin[SKIN_LOBBYCHATMIDR2]);
	DrawBitmapScale(pDC, xpos2 + 103, ypos_start + 80, 4, 50 - offsetY*0.5f - 1 + 48, BitmapSkin[SKIN_LOBBYCHATMIDR3]);
	DrawBitmap(pDC, xpos2 + 103, m_cy - 12, BitmapSkin[SKIN_LOBBYCHATMIDR4]);

	
	
	if(ypos_start > 84+355-48) DrawBitmapScale(pDC, xpos2+95+215+30, 84+355, 12, ypos_start-(84+355)+50, BitmapSkin[SKIN_LOBBYCHATRIGHTM0]);
	DrawBitmap(pDC, xpos2+95+215+30, ypos_start+48, BitmapSkin[SKIN_LOBBYCHATRIGHTM1]);
	DrawBitmapScale(pDC, xpos2+95+215+30, ypos_start+48+80, 12, 50-offsetY*0.5f-1, BitmapSkin[SKIN_LOBBYCHATRIGHTM2]);
	DrawBitmap(pDC, xpos2+95+215+30, m_cy-12, BitmapSkin[SKIN_LOBBYCHATRIGHTM3]);
	
	

	
	//if(ypos_start > 84+355) BitmapSkinEx[SKIN_LOBBYPLAYERLISTTOPLB].DrawScale(pDC, xpos2+103, 84+355, 4, ypos_start-(84+355));
	//BitmapSkinEx[SKIN_LOBBYPLAYERLISTTOPL].Draw(pDC, xpos2+103, 84);
	//BitmapSkinEx[SKIN_LOBBYPLAYERLISTTOPM].Draw(pDC, xpos2+107, 84);
	//BitmapSkinEx[SKIN_LOBBYPLAYERLISTTOPR].Draw(pDC, xpos2+95+215, 84);
	
	
	if(ypos_start > 84+355) DrawBitmapScale(pDC, xpos2+103, 84+355, 4, ypos_start-(84+355), BitmapSkin[SKIN_LOBBYPLAYERLISTTOPLB]);
	DrawBitmap(pDC, xpos2+103, 84, BitmapSkin[SKIN_LOBBYPLAYERLISTTOPL]);
	
	DrawBitmap(pDC, xpos2+95+215+30, 84, BitmapSkin[SKIN_LOBBYPLAYERLISTTOPM]);
	DrawBitmap(pDC, xpos2+95+215+30, 84, BitmapSkin[SKIN_LOBBYPLAYERLISTTOPR]);
	

	
	CPen pen_blueborder(PS_SOLID, 1, RGB(23,33,52));
	CPen *oldPen = pDC->SelectObject(&pen_blueborder);
	CBrush *oldBrush = pDC->SelectObject(&brush_lobbybg);


	ypos1 = ypos1 - 8;
	ypos2 = ypos1 + 10;

	


	// Draw BackGround Pieces //
	// LobbyTV BackGround //
	// Two strips above and below rendered image of table //
	// This is only visible when the screen is greater than 768 pixels high //
	tv_x = 0;
	tv_y = 107;
	tv_w = (float)(m_cx) * 0.43f;
	
	// Make sure our Table and Player List has at least 
	if( (m_cx - tv_w) < 620 )
	{
		tv_w = m_cx - 620;
	}

	if(m_bFullMode)
	{
		tv_w = m_cx - 249;
	}

	tv_h = (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-2;
	
	
	
	
	// Draw a Black Rectangle behind where Lobby TV will be if first time here //
	if(m_first_time) 
		{
		pDC->SelectObject(&brush_black);
		pDC->Rectangle( 0, 107,tv_w,107+tv_h);
		m_first_time = 0;
		}

	
	if(g_menuNItemID != -1) goto drawChildWindow;
	

	if(g_bMenuSelect) return;
	if(m_bDisableOnDraw) return;





drawChildWindow:	


	// - re-draw all child windows
	// - set the child windows pos/size based on parent pos/size
	int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view
	int excess_w = m_cx - (squareHeight + (72*2 + 19));
	int initial_w = (300+40) + (100+g_FIX_shiftX-40);
	g_FIX_SpareW = excess_w - initial_w;
	if(g_FIX_SpareW < 0) g_FIX_SpareW = 0;

	
	m_sendEdit.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	int xpos = 150+border+519-offsetX-g_FIX_shiftX-50-20+2;
	
	xpos_start = 688+100-offsetX-g_FIX_shiftX+20-190-23-8-30-160;
		

	//CRect r1;
	//m_sliderRaiseButt.GetWindowRect(&r1);

	int sendEditWidth = 519 - offsetX - g_FIX_shiftX - 88 - 30 - 160;
	m_sendEdit.SetWindowPos(&wndTop, 145 + 12, m_cy - 180 + offsetY*0.5f, sendEditWidth, 22, SWP_SHOWWINDOW);

	// Lobby Smiley Button :D //
	m_sayButton.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	m_sayButton.SetWindowPos(&wndTop, xpos_start+8, ypos_start+4, tmpSize.cx, 27, SWP_SHOWWINDOW);
	xpos+=tmpSize.cx;


	m_smileyselectButton.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	m_smileyselectButton.SetWindowPos(&wndTop, xpos_start+28+11, ypos_start+4, tmpSize.cx, 27, SWP_SHOWWINDOW);
	

	int lp_x, lp_y;
	int lp_w, lp_h;
	

	m_editExChat.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();

	lp_x = 145 + 12;
	lp_y =  m_cy - 94 - 30 - 10 - 21 + offsetY*0.5f + 5;
	lp_w = 552 - offsetX - g_FIX_shiftX - (border * 2) - 19 - 30 - 160;
	lp_h = 146 - offsetY*0.5f - (border * 2) + 6;
	
	m_editExChat.SetWindowPos(&wndTop, lp_x, lp_y, lp_w, lp_h, SWP_SHOWWINDOW);
	m_editExChat.ShowScrollBar(SB_VERT);





	
	
	lp_x = 688+175+4-offsetX-g_FIX_shiftX+20-190-3-30;
	lp_y = 84+10;
	lp_w = 203+30;
	
	//if(g_WideScreenEnabled) lp_h = m_cy-g_yBarOffset+100;
	//	else lp_h = m_cy-g_yBarOffset-60;
	
	CPen p1(PS_NULL, 0, RGB(79,72,76));
	CBrush b1 = RGB(79,72,76);
	pDC->SelectObject(&b1);
	pDC->SelectObject(&p1);
	pDC->Rectangle( lp_x, 84, lp_x+lp_w+1, 84+10+1);


	lp_h = m_cy-g_yBarOffset-60;

	m_listPlayers.SetWindowPos(&wndTop, lp_x, lp_y, lp_w, lp_h, SWP_SHOWWINDOW);
	//m_listPlayers.SetWindowPos(&wndTop, lp_x, lp_y, lp_w, lp_h, SWP_HIDEWINDOW);
	m_listPlayers.ShowScrollBar(SB_VERT);



#else
	// We are the Server Program, So the only things we want showing are, Table List and Player List //
	// We also want any buttons to be displayed (i.e. Lobby Stats, Config).
	m_editExChat.SetWindowPos(&wndTop,0, 0, 0 ,0, SWP_HIDEWINDOW);
	m_sendEdit.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
	m_sayButton.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);

	int lp_x, lp_y;
	int lp_w, lp_h;
	
	lp_x = 703-offsetX-g_FIX_shiftX;
	lp_y = 24;
	lp_w = 204-30;
	lp_h = m_cy - 24;//d-g_yBarOffset + 17;
		
	

	m_listPlayers.SetWindowPos(&wndTop, lp_x, lp_y, lp_w, lp_h, SWP_SHOWWINDOW);
	m_listPlayers.ShowScrollBar(SB_VERT);


#endif	

	m_listBox.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	

	
	m_sit1PButton.SetWindowPos(&wndTop,0, 0, 0 ,0, SWP_HIDEWINDOW);
	m_sit2PButton.SetWindowPos(&wndTop,0, 0, 0 ,0, SWP_HIDEWINDOW);
	m_sit1PButtonB.SetWindowPos(&wndTop,0, 0, 0 ,0, SWP_HIDEWINDOW);
	m_sit2PButtonB.SetWindowPos(&wndTop,0, 0, 0 ,0, SWP_HIDEWINDOW);
	m_missRuleButton.SetWindowPos(&wndTop,0, 0, 0 ,0, SWP_HIDEWINDOW);
	m_ratedButton.SetWindowPos(&wndTop,0, 0, 0 ,0, SWP_HIDEWINDOW);
	
	// Get tableTypeBox size, so we don't lose this data when hiding the window //
	CRect Rect1;
	m_tableTypeBox.GetWindowRect(&Rect1);
	m_tableTypeBox.SetWindowPos(&wndTop,0, 0,Rect1.Width(), Rect1.Height(), SWP_HIDEWINDOW);

	int i;
	for(i=0;i<8;i++) m_button[i].SetWindowPos(&wndTop,0, 0, 0 ,0, SWP_HIDEWINDOW);
	
	m_standButton.SetWindowPos(&wndTop,0, 0, 0 ,0, SWP_HIDEWINDOW);
	m_sliderRaiseButt.SetWindowPos(&wndTop,0, 0, 0 ,0, SWP_HIDEWINDOW);




#ifndef MAIN_SERVER

	


	// Draw Ranks Image //
	pDC->BitBlt(0, ypos_start, 146, lp_h, &dcMemoryTempR, 0, 0, SRCCOPY);




	// Exclude Smiley and Send Button Regions //
	//CRect cliprect;


	cliprect.left= xpos_start + 8;
	cliprect.top = ypos_start + 4;
	cliprect.right = xpos_start + 36;
	cliprect.bottom = ypos_start + 31;
	pDC->ExcludeClipRect(&cliprect);

	cliprect.left= xpos_start + 39;
	cliprect.top = ypos_start + 4;
	cliprect.right = xpos_start + 67;
	cliprect.bottom = ypos_start + 31;
	pDC->ExcludeClipRect(&cliprect);


	cliprect.left= xpos_start - 0;
	cliprect.top = ypos_start + 38;
	cliprect.right = xpos_start+95;
	cliprect.bottom = ypos_start + 48;
	pDC->ExcludeClipRect(&cliprect);
	
	
	pDC->BitBlt(xpos_start, ypos_start, 103, 48, &dcMemoryTempL, 0, 0, SRCCOPY);


	GetWindowRect(&tmpRect);

	if(m_htmlViewLeaderBoardA) m_htmlViewLeaderBoardA.SetWindowPos(&wndTop, 0, 64, 192, 20, SWP_SHOWWINDOW);
	if(m_htmlViewBanner) m_htmlViewBanner.SetWindowPos(&wndTop, 192, 0, m_cx-192-192, 84, SWP_SHOWWINDOW);
	
	if(m_htmlViewLeaderBoardB) m_htmlViewLeaderBoardB.SetWindowPos(&wndTop, m_cx-192, 64, 192, 20, SWP_SHOWWINDOW);
	if(m_htmlViewTickerBoard) m_htmlViewTickerBoard.SetWindowPos(&wndTop, 0, (int)(m_cy - 230+50 + offsetY*0.5f)-39, (703-offsetX-g_FIX_shiftX)-13-30, 31, SWP_SHOWWINDOW);
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Handle Tab control redraw

	//int tabSelected = m_tabLobbyCtrlEx.GetCurSel();

	
	if(g_tabSelected == 0) // [ScreenShot Board / Msg Board]
	{
		// hide/inactivate
		//m_lobbySelectDlg.m_listLobbies.SetWindowPos(&wndTop, 0,0,0,0, SWP_HIDEWINDOW);
		// m_lobbySelectDlg.SetWindowPos(&wndTop,  0,0,0,0, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	

		// lp_y = (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100;
		// If we're in Default Mode 0, then Display the Message-Board //
		// It's good to show this defaultly, since it contains news and updates //
		if(m_bLobbyMode == 0) 
		{
			
			if(m_listTables) m_listTables.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
			if(m_tableTabCtrlDlg) m_tableTabCtrlDlg.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
			//m_lobbySelectDlg.SetWindowPos(&wndTop, 0 ,0 ,0 ,0, SWP_HIDEWINDOW);
			if(m_tabLobbyCtrlEx) m_tabLobbyCtrlEx.SetWindowPos(&wndTop, 0 ,0 ,0 ,0, SWP_HIDEWINDOW);
			
			//m_htmlViewMB.SetWindowPos(&wndTop, tv_w, 107, (703-offsetX-g_FIX_shiftX)-tv_w-13-30, (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-2, SWP_SHOWWINDOW);
			m_htmlViewMB.SetWindowPos(&wndTop, 0, 107, tv_w, (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-2, SWP_SHOWWINDOW);

		}
		else if(m_bLobbyMode == 1)
		{
			/* 
			 * Show Message-Board, Hide LobbyTV
			 */
			
			

			if(m_lobbySelectDlg) m_lobbySelectDlg.SetWindowPos(&wndTop, 0 ,0 ,0 ,0, SWP_HIDEWINDOW);
			
			
			// if(m_htmlViewMB) m_htmlViewMB.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
			m_htmlViewMB.SetWindowPos(&wndTop, 0, 107, tv_w, (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-2, SWP_SHOWWINDOW);


			if(m_bFullMode == false)
			{
				m_listTables.SetWindowPos(&wndTop, 2,4, (703-offsetX-g_FIX_shiftX)-tv_w-21+4-30, (int)(m_cy-200+ceil(offsetY*0.5f)-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-116+13, SWP_SHOWWINDOW);
				m_listTables.ShowScrollBar(SB_VERT);
				m_tableTabCtrlDlg.SetWindowPos(&wndTop, 0, 0, (703-offsetX-g_FIX_shiftX)+150-30, (int)(m_cy-200+ceil(offsetY*0.5f)-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-112+13, SWP_SHOWWINDOW);
			}
			else
			{
				if(m_listTables) m_listTables.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
				if(m_tableTabCtrlDlg) m_tableTabCtrlDlg.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
				if(m_tabLobbyCtrlEx) m_tabLobbyCtrlEx.SetWindowPos(&wndTop, 0 ,0 ,0 ,0, SWP_HIDEWINDOW);
			}
		}
		else if(m_bLobbyMode == 2)
		{
			// Hide Message Board, so we're showing Lobby TV
			if(m_htmlViewMB) m_htmlViewMB.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);

			// Hi8de Lobby Select if open
			if(m_lobbySelectDlg) m_lobbySelectDlg.SetWindowPos(&wndTop, 0 ,0 ,0 ,0, SWP_HIDEWINDOW);
		}
	}
	else if(g_tabSelected == 1)// [Lobby Select]
	{

		// show
		if( m_lobby->GetPlayerIdx(m_playerSockIdx) !=-1 )
		{
			// if(m_listTables) m_listTables.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
			// if(m_tableTabCtrlDlg) m_tableTabCtrlDlg.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
			if(m_htmlViewMB) m_htmlViewMB.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);

			if(m_bFullMode)
			{
				if(m_listTables) m_listTables.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
				if(m_tableTabCtrlDlg) m_tableTabCtrlDlg.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
				if(m_tabLobbyCtrlEx) m_tabLobbyCtrlEx.SetWindowPos(&wndTop, 0 ,0 ,0 ,0, SWP_HIDEWINDOW);
			}
			else
			{
				m_listTables.SetWindowPos(&wndTop, 2,4, (703-offsetX-g_FIX_shiftX)-tv_w-21+4-30, (int)(m_cy-200+ceil(offsetY*0.5f)-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-116+13, SWP_SHOWWINDOW);
				m_listTables.ShowScrollBar(SB_VERT);
				m_tableTabCtrlDlg.SetWindowPos(&wndTop, 0, 0, (703-offsetX-g_FIX_shiftX)+150-30, (int)(m_cy-200+ceil(offsetY*0.5f)-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-112+13, SWP_SHOWWINDOW);
			}

			m_lobbySelectDlg.m_listLobbies.SetWindowPos(&wndTop,  0, 0, tv_w, (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-2, SWP_SHOWWINDOW);
			m_lobbySelectDlg.SetWindowPos(&wndTop,  0, 107+2, tv_w, (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-4, SWP_SHOWWINDOW);
		}
	
		//m_tableTabCtrlDlg.SetWindowPos(&wndTop, widthMixedMode + 2, 108, (703-offsetX-g_FIX_shiftX)-widthMixedMode-13, (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-2, SWP_SHOWWINDOW);
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Draw the Lobby Table Buttons if we're in LobbyMode 1 //
	if(m_bLobbyMode) m_tabLobbyCtrlEx.SetWindowPos(&wndTop, tv_w, 105, (703-offsetX-g_FIX_shiftX)-tv_w-13-30, (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-98, SWP_SHOWWINDOW);
	//if(m_bLobbyMode)
	
	//	m_listTables.SetWindowPos(&wndTop, 0, 0, (703-offsetX-g_FIX_shiftX), m_cy - 124, SWP_SHOWWINDOW);
	//m_listTables.ShowScrollBar(SB_VERT);
	
	
#else // MAIN_SERVER
	m_lobbySelectDlg.m_listLobbies.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
	
	//m_listTables.ShowScrollBar(SB_VERT);
	m_tabLobbyCtrlEx.SetWindowPos(&wndTop, 0, 22, (703-offsetX-g_FIX_shiftX)-30, m_cy, SWP_SHOWWINDOW);	
	m_tableTabCtrlDlg.SetWindowPos(&wndTop, 0, m_tabLobbyCtrlEx.m_cornerPtTabs.y - 22-30, (703-offsetX-g_FIX_shiftX) - 1, m_cy, SWP_SHOWWINDOW);
	m_listTables.SetWindowPos(&wndTop, 0, 0, (703-offsetX-g_FIX_shiftX)-30, m_cy-6, SWP_SHOWWINDOW);
	//m_tableTabCtrlDlg.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
	//m_tabLobbyCtrlEx.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
	
#endif
	
	



#ifndef MAIN_SERVER
			


		// Draw Lobby Buttons
		int xbtnoffset = 0;
		m_exitlobbyButton.SetWindowPos(&wndTop, xbtnoffset, 84, 70, 23, SWP_SHOWWINDOW);	
		xbtnoffset += 70;
		m_changelobbyButton.SetWindowPos(&wndTop, xbtnoffset, 84, 90, 23, SWP_SHOWWINDOW);	
		xbtnoffset += 90;

		

		int old_xbtnoffset = xbtnoffset;

		m_listPlayers.GetWindowRect(&tmpRect);
		tmpSize = tmpRect.Size();
		
		
		pDC->SelectObject(&pen_skyblue);
		pDC->SelectObject(&brush_lobbybg);
		 
		xbtnoffset = -84 + 688-tmpSize.cx+175+4-offsetX-g_FIX_shiftX+40; //270;
		xbtnoffset -= (51+73+76+70);
		if(xbtnoffset > tv_x+tv_w) xbtnoffset = tv_x+tv_w;

		// Refresh MessageBoard Button
		// Render Sprites
		// m_testSprite->Draw(pDC, xbtnoffset-40-24, 84);
		m_lobbyButtons->UpdateOffset(xbtnoffset, (703 - offsetX - g_FIX_shiftX) - tv_w - 21 + 8 - 30);
				
		// Full MessageBoard Toggle Button
		m_messageBoardFullButton.SetWindowPos(&wndTop, xbtnoffset-40, 84, 40, 23, SWP_SHOWWINDOW);



		// BackGround (Between 'Change Lobby' & 'Refresh MsgBoard' Button) //
		if (old_xbtnoffset < (xbtnoffset - 40))
		{
			pDC->FillRect(CRect(old_xbtnoffset, 84, xbtnoffset-40-24, 84 + 23), &brush_lobbybg);
		}

		// Draw Message Board Buttons //		
		m_homeButton.SetWindowPos(&wndTop, xbtnoffset, 84, 51, 23, SWP_SHOWWINDOW);	
		xbtnoffset += 51;
		m_registerButton.SetWindowPos(&wndTop, xbtnoffset , 84, 73, 23, SWP_SHOWWINDOW);	
		xbtnoffset += 73;
		m_tourneysButton.SetWindowPos(&wndTop, xbtnoffset , 84, 76, 23, SWP_SHOWWINDOW);	
		xbtnoffset += 76;
		// m_leaguesButton.SetWindowPos(&wndTop, xbtnoffset , 84, 70, 23, SWP_SHOWWINDOW);	
		//xbtnoffset += 70;

		// BackGround (Between 'Leagues' & 'Reresh' Button, if there's any gap) //
		lp_x = 688-tmpSize.cx+175+8-offsetX-g_FIX_shiftX+40-18;
		if(lp_x > xbtnoffset)
		
		pDC->FillRect(CRect(xbtnoffset, 84, lp_x, 84+23), &brush_lobbybg);


		
		m_lobbyButtons->Draw(pDC);
		m_findMatchCtrl->Draw(pDC);



		// Display the View Tables Button, if we are in MessageBoard Mode //
		//int offset = (tv_w - 200) >> 1;
		//m_viewtablesButton.SetWindowPos(&wndTop, tv_x+offset, tv_y+16, 200, 20, SWP_SHOWWINDOW);
		m_viewtablesButton.SetWindowPos(&wndTop, 0,0,80,24, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		// hide/inactivate enter lobby button
		m_EnterLobbyButton.SetWindowPos(&wndTop, 0,0,72,26, SWP_NOACTIVATE | SWP_HIDEWINDOW);

#else
		// hide/inactivate refreh button
		m_refreshButton.SetWindowPos(&wndTop, 0,0,72,20, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		// hide/inactivate enter lobby button
		m_EnterLobbyButton.SetWindowPos(&wndTop, 0,0,72,26, SWP_NOACTIVATE | SWP_HIDEWINDOW);
#endif
	

	//pDC->SelectObject(oldBrush);
	//pDC->SelectObject(oldPen);

	// Redraw all child windows

#ifndef MAIN_SERVER

	


	m_tabLobbyCtrlEx.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
	m_sendEdit.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_sayButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_smileyselectButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_editExChat.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

	m_htmlViewBanner.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_htmlViewLeaderBoardA.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_htmlViewLeaderBoardB.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_htmlViewTickerBoard.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_htmlViewMB.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_listTables.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);// | RDW_ALLCHILDREN);	
	
	m_listPlayers.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_tableTabCtrlDlg.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
	m_exitlobbyButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_changelobbyButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_messageBoardFullButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_homeButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_registerButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_tourneysButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	// m_leaguesButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	// m_refreshButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_viewtablesButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_EnterLobbyButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	if( m_lobby->GetPlayerIdx(m_playerSockIdx) !=-1 ) 
	{
		if(m_lobbySelectDlg)
		if(m_lobbySelectDlg.IsWindowVisible())
		{
			m_lobbySelectDlg.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);	
		}
	}
#else
	m_tabLobbyCtrlEx.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
	m_listTables.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);// | RDW_ALLCHILDREN);	
	m_listPlayers.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_tableTabCtrlDlg.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
#endif

	// hide some child windows
	if(m_sliderRaiseButt)
	if(m_sliderRaiseButt.IsWindowVisible())
	{
		// m_sliderRaiseButt.GetWindowRect(&tmpRect);
		// tmpSize = tmpRect.Size();
		//tmpPoint =  tmpRect.TopLeft();
		// m_sliderRaiseButt.SetWindowPos(&wndTop, 0,0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	}

	
	// Hide all Table Button when inside Lobby //
	if(m_standButton)
	{
		m_standButton.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		m_standButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);	
	}
	
	int x, y, w, h, n;
	n = 0;
	w = 70;
	h = 20;//30;
	int hoff = 3;
	for(x=0;x<2;x++)
	for(y=0;y<4;y++)
	{
		if(m_button[n])
		{
			m_button[n].SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
			m_button[n].RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
		}
		n++;
		if(n == 8) goto endxy;
	}

endxy:;
	y++;
	x++;
	
	//// cue-error button
	//m_cueErrorButton.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	//m_cueErrorButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	//
	//// cue-error combobox
	//m_cueErrorBox.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_HIDEWINDOW | SWP_NOSIZE);
	//m_cueErrorBox.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
		
	// rated button
	m_ratedButton.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_ratedButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	//if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		// miss-rule button
		m_missRuleButton.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		m_missRuleButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	}

	// table type combobox
	//m_tableTypeBox.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_HIDEWINDOW | SWP_NOSIZE);
	//m_tableTypeBox.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	


	// seat buttons
	m_sit1PButton.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_HIDEWINDOW | SWP_NOSIZE);
	m_sit1PButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	m_sit2PButton.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_HIDEWINDOW | SWP_NOSIZE);
	m_sit2PButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	m_sit1PButtonB.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_HIDEWINDOW | SWP_NOSIZE);
	m_sit1PButtonB.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	m_sit2PButtonB.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_HIDEWINDOW | SWP_NOSIZE);
	m_sit2PButtonB.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);





#ifdef MAIN_SERVER
	// Lobby (Server) Buttons //
	m_serverConfigButton.SetWindowPos(&wndTop, m_cx-384,0,128,24, SWP_SHOWWINDOW);
	m_serverConfigButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

	m_accountConfigButton.SetWindowPos(&wndTop, m_cx-256,0,128,24, SWP_SHOWWINDOW);
	m_accountConfigButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	
	m_lobbyStatButton.SetWindowPos(&wndTop, m_cx-128,0,128,24, SWP_SHOWWINDOW);
	m_lobbyStatButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);


	// Draw Black Rectangle where needed //
	CBrush brush1 = RGB(0,0,0);

	m_serverConfigButton.GetWindowRect(&tmpRect);
	pDC->FillRect(CRect(0,0,m_cx-384,24), &brush1);


#endif //MAIN_SERVER

	first_time = 0;

}

void CGameAppView::Init(void)
{
	/*
	int sx,sy;
		
	// create new double buffer surface
	//Mgfx_sprdeinit(&g_spr3dSurface);
		
	sx = m_cx, sy = m_cy;
	if(sx<16) sx = 16;
	if(sy<16) sy = 16;
	*/

#ifndef MAIN_SERVER
	//Mgfx_sprinit(&g_spr3dSurface, sx, sx*0.5f, MGFX_SPR_VRAM|MGFX_SPR_3DDEVICE);
	
	m_snooker->SetWindowSize(g_dwMainViewWidth, g_dwMainViewWidth/2);
	m_snooker->SetTableViewWindowSize(g_dwMainViewWidth, 560);


	//m_snooker->SetWindowSize(sx,sx*0.5f);
	//m_snooker->SetTableViewWindowSize(sx, 560);


	//lpdds1 = g_spr3dSurface.surf;
	//M3d_surfmap(); // remap surface to recreated/resized surface.
#endif //!MAIN_SERVER

	///////////////////////////////////////////////
/*
	CDC *pDC = GetDC();
	if(pDC)
	{
		// Create Back Buffer
		BOOL bResult;
		dblBitmap = new CBitmap;
		bResult = dblBitmap->CreateCompatibleBitmap(pDC, m_cx, m_cy);
		if(!bResult)
		{
			ErrorMessage(this, "[4] Failed on: -> CreateCompatibleBitmap(...)");

			// destroy back buffer
			if(dblBitmap) delete dblBitmap;
			dblBitmap = 0;
			ReleaseDC(pDC);
			return;
		}
		
		dblDC = new CDC;
		bResult = dblDC->CreateCompatibleDC(pDC);
		if(!bResult)
		{
			ErrorMessage(this, "[5] Failed on: -> CreateCompatibleDC(...)");

			// destroy back buffer
			if(dblBitmap) delete dblBitmap;
			dblBitmap = 0;

			if(dblDC) delete dblDC;
			m_dblDC = dblDC = 0;
			ReleaseDC(pDC);
			return;
		}
		
		pBitmap = dblDC->SelectObject(dblBitmap);
		if(pBitmap) 
		{
			m_dblDC = dblDC;
			
			// do special rendering to backbuffer
			//Draw2DRender(pDC);
		}
		else 
		{
			ErrorMessage(this, "[6] Failed on: -> dblDC->SelectObject(...)");
			// destroy back buffer
			if(dblBitmap) delete dblBitmap;
			dblBitmap = 0;

			if(dblDC) delete dblDC;
			m_dblDC = dblDC = 0;
			ReleaseDC(pDC);
			return;
		}

	ReleaseDC(pDC);
	}
*/

}

void CGameAppView::Deinit(void)
{
/*
	// destroy back buffer
	if(dblBitmap) delete dblBitmap;
	dblBitmap = 0;

	if(dblDC) delete dblDC;
	m_dblDC = dblDC = 0;	
*/

//	CDC *pDC = GetDC();
//	if(pDC)
//	{
	

	/*
		if(pBitmap)
		if(dblDC)
		if(dblDC->m_hDC != NULL)
		dblDC->SelectObject(pBitmap);
	*/
		// destroy back buffer
		if(dblBitmap) delete dblBitmap;
		dblBitmap = 0;

		if(dblDC) delete dblDC;
		m_dblDC = dblDC = 0;	

//	ReleaseDC(pDC);
//	}
}

void CGameAppView::OnConnect(CAsyncSocketEx *pSocket, int nErrorCode)
{
	/*
	char buffer[80];
	sprintf(buffer,"OnConnect, Error Code:%d (Type: %d)", nErrorCode, pSocket->m_type);
	ErrorMessage(this, buffer);
	AfxMessageBox(buffer);
	*/
	switch(pSocket->m_type)
		{
		case ASYNCSOCK_TYPE_MAINSERVER:
			{	
				#ifdef MAIN_SERVER

				if(!nErrorCode) // Success
				{
					mainShell->m_clientSocketIdx = mainShell->Client->AttachSocket(pSocket);
					pSocket->OnOpen(); // Generate Open Message

					m_lobby->m_bInLobby = TRUE;
					g_bMenuSelect = 0;
					m_bDisableOnDraw = 0;
					RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

					///////////////////////////////////////////////////////////////////////
					// go to the lobby & post the server's internet IP address to website!!
					///////////////////////////////////////////////////////////////////////
					
					m_lobby->m_bInLobby = TRUE; // override this variable

					CString str;
				}
				else 
				{
					delete pSocket;
					MessageBox("Couldn't connect to server!! [4]", g_appName);
				}

				#endif //MAIN_SERVER
			}
			break;		
		case ASYNCSOCK_TYPE_MAIN:{
								 	Mmain_log("(Lobby) OnConnect - 1");
									if(!nErrorCode) // Success
									{
									Mmain_log("(Lobby) OnConnect - 2a");
									mainShell->m_clientSocketIdx = mainShell->Client->AttachSocket(pSocket);
									
									Mmain_log("(Lobby) OnConnect - 2b");
									pSocket->OnOpen(); // Generate Open Message

									Mmain_log("(Lobby) OnConnect - 2c");
									m_lobby->m_bInLobby = TRUE;

									g_playerIdleTime = 0; // reset player's idle time counter

									///////////////////////////////////////////////////////////////
									// recreate lobby select dialogue for lobby tabctrl
									m_lobbySelectDlg.DestroyWindow();
						
									m_lobbySelectDlg.Create(IDD_LOBBYSELECTTABCTRL);//, &m_tabLobbyCtrlEx);
									m_lobbySelectDlg.SetEraseBkgnd(FALSE);
									/*
									m_tabLobbyCtrlEx.DeleteItem(4);
									m_tabLobbyCtrlEx.CreateItem(4, "Lobby Select", (CWnd *)&m_lobbySelectDlg);
									m_tabLobbyCtrlEx.GetTabTotalRect();
									m_tabLobbyCtrlEx.SetCurSel(0); // always select first tab #0					
									*/
									///////////////////////////////////////////////////////////////
									
									if(m_snooker->m_bComputerMode)
										ComputerPracticeDeinit();
									else if(m_snooker->m_bPracticeMode)
									{
										OnButtonEndPractice();
										m_snooker->m_bComputerMode = FALSE; // override this var. (cos it gets modified in above fn.)
									}
									
									g_bMenuSelect = 0;
									m_bDisableOnDraw = 0;
									RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

									Mmain_log("(Lobby) OnConnect - 2d");
									////////////////////////////////////////////////////////////////////////////////
									// entered lobby now, so receive the server's internet IP address from website!!
									////////////////////////////////////////////////////////////////////////////////
									//ErrorMessage(this, "OnConnect!");
									// change window title
									CString title;
									title.Format("  Lobby");
									ChangeTitle(title);
									}
								 else 
									{
									Mmain_log("(Lobby) OnConnect - 3a");
									delete pSocket;
									Mmain_log("(Lobby) OnConnect - 3b");
									
									// show & refresh lobby select dialogue
									m_connectStyle = CONNECTSTYLE_NORMAL;
									ShowTerms(); // This Function Calls up ConnectToLobby if User Agrees with Terms - ConnectToLobby(TRUE);
									
									
									//MessageBox("Couldn't connect to lobby!!!\r\nLobby Possibly down.\r\nTry an alternative lobby or try again later. [4]", g_appName);
									AlertLoginMessage("Couldn't connect to lobby!!!\r\nLobby Possibly down.\r\nTry an alternative lobby or try again later. [4]");
									}
								 }
								break;
		case ASYNCSOCK_TYPE_CHECK:{
								 if(!nErrorCode) // Success - server has connected to client's listencheck socket
									{
									pSocket->Close(); // close socket - Test complete!
									delete pSocket;
									// HIGH ID'd
									// [+] Tell player he's high I'd, update player idx table, {tell other players?}
									SetCheckID(1);
									}
								 else	{ // Timed out! - hence. LowID
										delete pSocket;
										SetCheckID(0);
										}
								  }
								break;

		case ASYNCSOCK_TYPE_GAMESERVER:
			{
				OnConnectGAMESERVER(pSocket, nErrorCode);
			}
			break;
		case ASYNCSOCK_TYPE_GAMESERVER_REJOIN:
			{
				OnConnectGAMESERVER_REJOIN(pSocket, nErrorCode);
			}
			break;
		case ASYNCSOCK_TYPE_GAME:
			{
				OnConnectGAME(pSocket, nErrorCode); 				
			}
			break;
		case ASYNCSOCK_TYPE_GAME_REJOIN:
			{
				OnConnectGAME_REJOIN(pSocket, nErrorCode); 				
			}
			break;
		}
}

void CGameAppView::OnConnectGAMESERVER(CAsyncSocketEx *pSocket, int nErrorCode)
{
	//char buffer[80];

	#ifndef MAIN_SERVER

	if(!nErrorCode) // Success
	{
		gameShell->m_clientSocketIdx = gameShell->Client->AttachSocket(pSocket);
		pSocket->OnOpen(); // Generate Open Message
		
		CreateGamePost();
	}
	else // Failed
	{
		delete pSocket;
		if(m_createGamePlayerIdx!=-1)
			FailedGameShell(m_createGamePlayerIdx);
		else
			ErrorMessage(this, "ASYNCSOCK_TYPE_GAMESERVER -> m_createGamePlayerIdx = -1");
		// ---- //
		ErrorMessage(this, OnConnectErrorString(nErrorCode));
		CreateGamePost();
		return;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////

	// Success! - so continue with joining this table...
	
	// enable table type for host of table
	m_tableTypeBox.EnableWindow(TRUE);
	
	//*TODO - what if this is someone rehosting a table, then we don't want to clear chat window
	// if successful:
	//if(m_lobby->m_bInLobby)
	//{
	// clear out all the text in the chat window
	DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
	m_editExChat.SetSel(ss,FALSE);
	m_editExChat.ReplaceSel(_T(""));
	//m_editExChat.Clear(); // Beep
	m_sendEdit.SetSel(ss,FALSE);
	m_sendEdit.ReplaceSel(_T(""));
	//m_sendEdit.Clear();  // Beep
	g_active = 1;
	//}

	// change window title
	if(m_createGamePlayerIdx!=-1)
	{
		CString title;
		title.Format(" Table: %d -  Host: %s", m_player[m_createGamePlayerIdx].table+1, m_player[m_createGamePlayerIdx].name);
		ChangeTitle(title);
	}
	else
		ErrorMessage(this, "ASYNCSOCK_TYPE_GAMESERVER -> m_createGamePlayerIdx = -1");
	
	if(gameShell)
	{
		// set and broadcast player profile (nick for chat msgs)
		int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
		if(plrIdx !=-1) gameShell->SetNick(m_player[plrIdx].name); // note: if can't find name, uses 'Guest' use this for error message
		gameShell->SendProfile();
	
		int tblIdx = m_player[plrIdx].table;
		int enterType = 0;
		
		if(m_table[tblIdx].player1SockIdx == m_player[plrIdx].playerSocketIdx) enterType = 1;
		else if(m_table[tblIdx].player2SockIdx == m_player[plrIdx].playerSocketIdx) enterType = 2;
		
		if(enterType == 1) gameShell->SitRequest(0); // Seat #1
		else if(enterType == 2) gameShell->SitRequest(1); // Seat #2

		// Tell server that the hosting phase is complete
		SendTableHostComplete(tblIdx);
	}
	else
	{
		ErrorMessage(this, "Host: Unable to create GameShell!");
		//MessageBox(0,"ReJoiner: Unable to create GameShell!","",MB_OK);
	}		

	#endif //!MAIN_SERVER
}


void CGameAppView::OnConnectGAMESERVER_REJOIN(CAsyncSocketEx *pSocket, int nErrorCode)
{
	//char buffer[80];

	#ifndef MAIN_SERVER

	if(!nErrorCode) // Success
	{
		gameShell->m_clientSocketIdx = gameShell->Client->AttachSocket(pSocket);
		pSocket->OnOpen(); // Generate Open Message
		
		//CreateGamePost();
	}
	else // Failed
	{
		delete pSocket;
		//ErrorMessage(this, "AAAA-2");
		if(m_createGamePlayerIdx!=-1)
			FailedGameShell(m_createGamePlayerIdx);
		else
			ErrorMessage(this, "ASYNCSOCK_TYPE_GAMESERVER -> m_createGamePlayerIdx = -1");

		CreateGamePost();
		return;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////

	// Success! - so continue with joining this table...
	
	// enable table type for host of table
	m_tableTypeBox.EnableWindow(TRUE);
	
	//*TODO - what if this is someone rehosting a table, then we don't want to clear chat window
	// if successful:
	//if(m_lobby->m_bInLobby)
	//{
	/*
	// clear out all the text in the chat window
	DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
	m_editExChat.SetSel(ss,FALSE);
	m_editExChat.ReplaceSel(_T(""));
	//m_editExChat.Clear(); // Beep
	m_sendEdit.SetSel(ss,FALSE);
	m_sendEdit.ReplaceSel(_T(""));
	//m_sendEdit.Clear();  // Beep
	g_active = 1;
	*/
	//}

	// change window title
	if(m_createGamePlayerIdx!=-1)
	{
		CString title;
		title.Format(" Table: %d -  Host: %s", m_player[m_createGamePlayerIdx].table+1, m_player[m_createGamePlayerIdx].name);
		ChangeTitle(title);
	}
	else
		ErrorMessage(this, "ASYNCSOCK_TYPE_GAMESERVER -> m_createGamePlayerIdx = -1");
	
	if(gameShell)
	{
		// set and broadcast player profile (nick for chat msgs)
		int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
		if(plrIdx !=-1) gameShell->SetNick(m_player[plrIdx].name); // note: if can't find name, uses 'Guest' use this for error message
		gameShell->SendProfile();
	
		int tblIdx = m_player[plrIdx].table;
		int enterType = 0;
		
		if(m_table[tblIdx].player1SockIdx == m_player[plrIdx].playerSocketIdx) enterType = 1;
		else if(m_table[tblIdx].player2SockIdx == m_player[plrIdx].playerSocketIdx) enterType = 2;
		
		if(enterType == 1) gameShell->SitRequest(0); // Seat #1
		else if(enterType == 2) gameShell->SitRequest(1); // Seat #2

		// Tell server that the hosting phase is complete
		SendTableHostComplete(tblIdx);

		// if all is well, then notify others
		SendPlayerReJoin(FALSE, tblIdx);
	}
	else
	{
		ErrorMessage(this, "ReHost: Unable to create GameShell!");
		//MessageBox(0,"ReJoiner: Unable to create GameShell!","",MB_OK);
	}		

	#endif //!MAIN_SERVER
}


void CGameAppView::OnConnectGAME(CAsyncSocketEx *pSocket, int nErrorCode)
{
	//char buffer[80];
	
	#ifndef MAIN_SERVER

	if(!nErrorCode) // Success
	{
		gameShell->m_clientSocketIdx = gameShell->Client->AttachSocket(pSocket);

		pSocket->OnOpen(); // Generate Open Message
	
		CreateGamePost();
	}
	else
	{
		delete pSocket;
		//ErrorMessage(this, "AAAA-3");
		if(m_createGamePlayerIdx!=-1)
			FailedGameShell(m_createGamePlayerIdx);
		else
			ErrorMessage(this, "ASYNCSOCK_TYPE_GAMESERVER -> m_createGamePlayerIdx = -1");
		
		CreateGamePost();
		return;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////

	//*TODO - what if this is someone rehosting a table, then we don't want to clear chat window
	// if successful:
	//if(m_lobby->m_bInLobby)
	//{
	// clear out all the text in the chat window
	DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
	m_editExChat.SetSel(ss,FALSE);
	m_editExChat.ReplaceSel(_T(""));
	//m_editExChat.Clear(); // Beep
	m_sendEdit.SetSel(ss,FALSE);
	m_sendEdit.ReplaceSel(_T(""));
	//m_sendEdit.Clear();  // Beep
	g_active = 1;
	//}

	// change window title
	if(m_createGamePlayerIdx!=-1)
	{
	CString title;
	title.Format(" Table: %d -  Host: %s", m_player[m_createGamePlayerIdx].table+1, m_player[m_createGamePlayerIdx].name);
	ChangeTitle(title);
	}
	else
		ErrorMessage(this, "ASYNCSOCK_TYPE_GAMESERVER -> m_createGamePlayerIdx = -1");

	if(gameShell)
	{
		// set and broadcast player profile (nick for chat msgs)
		int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
		if(plrIdx !=-1) gameShell->SetNick(m_player[plrIdx].name); // note: if can't find name, uses 'Guest' use this for error message
		gameShell->SendProfile();
	
		int tblIdx = m_player[plrIdx].table;
		int enterType = 0;
		
		if(m_table[tblIdx].player1SockIdx == m_player[plrIdx].playerSocketIdx) enterType = 1;
		else if(m_table[tblIdx].player2SockIdx == m_player[plrIdx].playerSocketIdx) enterType = 2;
		
		if(enterType == 1) gameShell->SitRequest(0); // Seat #1
		else if(enterType == 2) gameShell->SitRequest(1); // Seat #2				
	}
	else
	{
		ErrorMessage(this, "Join: Unable to create GameShell!");
		//MessageBox(0,"ReJoiner: Unable to create GameShell!","",MB_OK);
	}		

	#endif //!MAIN_SERVER
}

void CGameAppView::OnConnectGAME_REJOIN(CAsyncSocketEx *pSocket, int nErrorCode)
{
	//char buffer[80];
	
	#ifndef MAIN_SERVER

	if(!nErrorCode) // Success
	{
		gameShell->m_clientSocketIdx = gameShell->Client->AttachSocket(pSocket);

		pSocket->OnOpen(); // Generate Open Message

		CreateGamePost();
	}
	else
	{
		delete pSocket;
		//ErrorMessage(this, "AAAA-4");
		if(m_createGamePlayerIdx!=-1)
			FailedGameShell(m_createGamePlayerIdx);
		else
			ErrorMessage(this, "ASYNCSOCK_TYPE_GAMESERVER -> m_createGamePlayerIdx = -1");

		CreateGamePost();
		return;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////

	//*TODO - what if this is someone rehosting a table, then we don't want to clear chat window
	// if successful:
	//if(m_lobby->m_bInLobby)
	//{
	// clear out all the text in the chat window
	/*
	DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
	m_editExChat.SetSel(ss,FALSE);
	m_editExChat.ReplaceSel(_T(""));
	//m_editExChat.Clear(); // Beep
	m_sendEdit.SetSel(ss,FALSE);
	m_sendEdit.ReplaceSel(_T(""));
	//m_sendEdit.Clear();  // Beep
	g_active = 1;
	*/
	//}

	// change window title
	if(m_createGamePlayerIdx!=-1)
	{
	CString title;
	title.Format(" Table: %d -  Host: %s", m_player[m_createGamePlayerIdx].table+1, m_player[m_createGamePlayerIdx].name);
	ChangeTitle(title);
	}
	else
		ErrorMessage(this, "ASYNCSOCK_TYPE_GAMESERVER -> m_createGamePlayerIdx = -1");

	if(gameShell)
	{
		// set and broadcast player profile (nick for chat msgs)
		int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
		if(plrIdx !=-1) gameShell->SetNick(m_player[plrIdx].name); // note: if can't find name, uses 'Guest' use this for error message
		gameShell->SendProfile();
	
		int tblIdx = m_player[plrIdx].table;
		int enterType = 0;
		
		if(m_table[tblIdx].player1SockIdx == m_player[plrIdx].playerSocketIdx) enterType = 1;
		else if(m_table[tblIdx].player2SockIdx == m_player[plrIdx].playerSocketIdx) enterType = 2;
		
		if(enterType == 1) gameShell->SitRequest(0); // Seat #1
		else if(enterType == 2) gameShell->SitRequest(1); // Seat #2				
	}
	else
	{
		ErrorMessage(this, "ReJoin: Unable to create GameShell!");
		//MessageBox(0,"ReJoiner: Unable to create GameShell!","",MB_OK);
	}		

	#endif //!MAIN_SERVER
}


void CGameAppView::SendListenCheckListening(int port, int i)
{
	char buffer[8];
	int *v;

	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 71;		// MSGGAME_HOSTCHECKLISTENING
	buffer[2] = 0;
	buffer[3] = 0;

	v = (int *) &buffer[4];
	*v = port;

	if(mainShell)
	{
		mainShell->Client->SendToQueue(buffer, 8, i);
	}
}

void CGameAppView::SetCheckSockIdx(int plrSockIdx)
{
	m_checkPlrSockIdx = plrSockIdx;
}

void CGameAppView::SetCheckID(BOOL id)
{// Tell player his/her id.
	unsigned char buffer[256];
	int plrIdx;
	int i;
	i = m_checkPlrSockIdx;
	plrIdx = m_lobby->GetPlayerIdx(m_checkPlrSockIdx);
	if(plrIdx==-1) return;
	m_player[plrIdx].bCanHost = id;
	m_player[plrIdx].bCanHostKnown = TRUE;
	
	if(id)
	sprintf((char *)&buffer[2],"You have a High ID Connection (can host)");
	else sprintf((char *)&buffer[2],"You have a Low ID Connection (can't host)");
		
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

	buffer[0] = 0x7f;
	buffer[1] = 72;		// MSGGAME_HOSTCHECKBROADCAST
	buffer[2] = 0;
	buffer[3] = id;
	int *v = (int *)&buffer[4];
	*v = m_checkPlrSockIdx;
	if(mainShell) mainShell->Server->SendToQueue(buffer, 8);
	//ErrorMessage(this, "MSGGAME_HOSTCHECKBROADCAST- sends...");
	m_hostcheckactive = -1;
}

void CGameAppView::SendServerMessage(char *str, int sockIdx)
{
	unsigned char buffer[1024];
	sprintf((char *)&buffer[2],"%s",str);
		
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, sockIdx); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
}


/////////////////////////////////////////////////////////////////////////////
// CGameAppView diagnostics

#ifdef _DEBUG
void CGameAppView::AssertValid() const
{
	CView::AssertValid();
}

void CGameAppView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CGameAppDoc* CGameAppView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CGameAppDoc)));
	return (CGameAppDoc*)m_pDocument;
}
#endif //_DEBUG

extern void CALLBACK EXPORT TimerProc(
    HWND hWnd,      //handle of CWnd that called SetTimer
    UINT nMsg,      //WM_TIMER
    UINT nIDEvent,  //timer identification
    DWORD dwTime);    //system time)





int CGameAppView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;
	if(Mmain_fatalerror==MMAIN_FATALERROR_INVALIDMODE) 
	{
	Mmain_log("Skipping OnCreate");
	return 0;
	}
	


	// TODO: Add your specialized creation code here
	Mmain_log("OnCreate");


	

	#ifndef MAIN_SERVER
	//Game_TimerProc_ID = 
		::SetTimer(NULL, 0,  20,(TIMERPROC) Game_TimerProc);
	#endif // !MAIN_SERVER
	


	// call specific creation code (Windows specific mainly)
	#ifndef MAIN_SERVER
	Mmain_log("m_snooker->Create()");
	m_snooker->Create();
	#endif // !MAIN_SERVER

	// Set frame rate i.e. 60 Hz - this call the ontimer fn. based on this frame rate
	#ifdef MAIN_SERVER
	//SetTimer(0, 1000.0f / 50.0f, NULL);
	//SetTimer(0, (1000.0f / 100.0f/*GAMEAPP_FPS*/), NULL);
	//SetTimer(0, (1000.0f / m_lobbySettings->m_fps), NULL);
	//KillTimer(0);
	SetTimer(0, (1000.0f / m_lobbySettings->m_fps), NULL);
	#else
	//SetTimer(0, (1000.0f/GAMEAPPCLIENT_FPS), NULL);
	SetTimer(0, (1000.0f/16.0f), NULL);
	//SetTimer(1, 2, NULL);		// 2ms (EVENT 1)
	#endif // MAIN_SERVER


	

	Mmain_log("Init Double Buffer Surface");
	// create a double buffer surface
	Init();
	
	InitEventTimer();



	
	// Game App child windows
	//////////////////////////////
	
	Mmain_log("Game App Child Windows");
	CRect rect;
	int n;
	int w,h;
	int x, y, offX, offY;
	x = 800-400-100-32-20-5;
	y = 600-175;
	offX = 10;
	offY = 10;
	
	
	Mmain_log("[1]");
	// Create child send window
	rect.SetRect(0,0,300,20);
	rect.OffsetRect(x+100+45,y+10);
	//m_sendEdit.Create(ES_AUTOHSCROLL | ES_AUTOVSCROLL | WS_CHILD | WS_VISIBLE | WS_BORDER, rect, this, IDC_WINDOWSENDVIEW);
	//m_sendEdit.SetBackgroundColor(FALSE, RGB(245,245,245));
	m_sendEdit.Create(ES_AUTOHSCROLL | ES_AUTOVSCROLL | WS_CHILD | WS_VISIBLE, rect, this, IDC_WINDOWSENDVIEW);
	m_sendEdit.LimitText(MAX_SENDEDITCHARS-4);
	m_sendEdit.SetEventMask(m_sendEdit.GetEventMask() | ENM_MOUSEEVENTS | ENM_LINK);
	m_sendEdit.AutoURLDetect(TRUE);

	// Default Color Scheme uses Red BackGround //
	if(g_gfxDetails.bDefaultColorScheme) m_sendEdit.SetBackgroundColor(FALSE, RGB(59,19,0));
		else m_sendEdit.SetBackgroundColor(FALSE, RGB(255,255,255));

	//m_sendEdit.TextAdjust();
	//m_sendEdit.SetFont(&m_listCtrlFont);//m_pFntData->font);
	//m_sendEdit.SetBackgroundColor(FALSE, RGB(25,25,115-40));
		
	Mmain_log("[2]");
	// Create child chat window
	
	
	rect.SetRect(0,0,300,75+10);
	rect.OffsetRect(x+100+45,y+20+10);
	m_editExChat.Create(ES_MULTILINE | ES_AUTOVSCROLL | WS_CHILD | WS_VISIBLE | WS_VSCROLL, rect, this, IDC_WINDOWCHATVIEW);
	//m_editExChat.Create(ES_MULTILINE | WS_CHILD | WS_VISIBLE, rect, this, 87654);
	m_editExChat.ShowScrollBar(SB_VERT);
	m_editExChat.SetScrollRange(SB_VERT,0, INT_MAX);
	m_editExChat.SetReadOnly();
	//::SendMessage( m_editExChat.m_hWnd, EM_AUTOURLDETECT, TRUE, 0 );
	m_editExChat.SetEventMask(m_editExChat.GetEventMask() | ENM_MOUSEEVENTS | ENM_LINK);
	m_editExChat.AutoURLDetect(TRUE);
		

	//m_editExChat.SetFont(m_pFntData->font);
	//m_editExChat.SetBackgroundColor(FALSE, RGB(20,20,20));
	
	// Default Color Scheme uses Red BackGround //
	if(g_gfxDetails.bDefaultColorScheme) m_editExChat.SetBackgroundColor(FALSE, RGB(59,19,0));
		else m_editExChat.SetBackgroundColor(FALSE, RGB(255,255,255));

	Mmain_log("[3]");
	// Create child listbox window
	rect.SetRect(0,0,100,100+15);
	rect.OffsetRect(x+400/*+20+offX*/+45,y+10);
//	m_listBox.Create(LBS_NOINTEGRALHEIGHT | LBS_DISABLENOSCROLL | WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_BORDER, rect, this, IDC_WINDOWLISTBOX);
//	m_listBox.InitStorage(MAX_TABLE_PLAYERS/*gameShell->Server->m_socketList_n*//*10*/, 32);
	//m_listBox.Create(LVS_NOCOLUMNHEADER | LVS_OWNERDRAWFIXED | LVS_REPORT | LVS_SINGLESEL | WS_CHILD | /*WS_VISIBLE |*/ WS_VSCROLL /*| WS_HSCROLL*/ /*| WS_CLIPCHILDREN*/ | WS_BORDER, rect, this, IDC_WINDOWLISTBOX);
	m_listBox.Create(LVS_OWNERDRAWFIXED | LVS_REPORT | LVS_SINGLESEL | WS_CHILD | /*WS_VISIBLE |*/ WS_VSCROLL /*| WS_HSCROLL*/ /*| WS_CLIPCHILDREN*/ | WS_BORDER, rect, this, IDC_WINDOWLISTBOX);
	m_listBox.PassParent(this);

	
	m_listBox.SetColumnFontHeight(1.6f);
	m_listBox.TriggerOnMeasureItem(IDC_WINDOWLISTBOX); // calls this to set the item height, based on font height
	
	//BAP_FIX //
	m_lobbySelectDlg.Create(IDD_LOBBYSELECTTABCTRL);//, &m_tabLobbyCtrlEx);
	m_lobbySelectDlg.SetEraseBkgnd(FALSE);



//	m_listBox.SetColumnFontHeight(1.3f);
	m_listBox.SetGridFlags(CListCtrlEx::GRIDVERT | CListCtrlEx::TEXTCOLOR);
	m_listBox.CreateColumn(0, "Name", 100);
	m_listBox.CreateColumn(1, "Rating", 57);
	m_listBox.CreateColumn(2, "lvl", 30);
	m_listBox.SetBkColor(RGB(20,20,20));
	m_listBox.SetGridColor(0, RGB(255,255,255));
	m_listBox.SetGridColor(1, RGB(200,200,200));
	m_listBox.m_crTextColor = RGB(255,255,255);//255,255,255);
	m_listBox.m_crTextBkColor = RGB(0,0,0);
	m_listBox.m_bBackground = TRUE;




	//SetEventMask(m_listBox.GetEventMask() | ENM_MOUSEEVENTS);


	//m_listBox.InitStorage(MAX_TABLE_PLAYERS/*gameShell->Server->m_socketList_n*//*10*/, 32);	

	Mmain_log("[4]");
	// Create child listctrl players window
	rect.SetRect(0,0,165+20+20,100+15);
	rect.OffsetRect(100+45,600-175+10-300);
	m_listPlayers.Create(LVS_OWNERDRAWFIXED | LVS_REPORT | LVS_SINGLESEL | WS_CHILD | WS_VISIBLE | WS_VSCROLL, rect, this, IDC_LISTCTRLPLAYERS);
	m_listPlayers.PassParent(this);


	m_listPlayers.SetColumnFontHeight(1.6f);
	m_listPlayers.TriggerOnMeasureItem(IDC_LISTCTRLPLAYERS); // calls this to set the item height, based on font height

//	m_listPlayers.SetColumnFontHeight(1.3f);
	m_listPlayers.AllowColumnSizing(FALSE);
	m_listPlayers.SetGridFlags(CListCtrlEx::GRIDVERT | CListCtrlEx::TEXTCOLOR);
	m_listPlayers.CreateColumn(0, "Name", 80+20);
	m_listPlayers.CreateColumn(1, "Rating", 45);
	m_listPlayers.CreateColumn(2, "TableA", 40);
	m_listPlayers.CreateColumn(3, "lvl", 30);
	//m_listPlayers.CreateButtons(MAX_TABLEBUTTONS, TRUE);//--
	m_listPlayers.EnableItemButton(0, TRUE);//--
	m_listPlayers.EnableItemButton(1, TRUE);//--
	m_listPlayers.SetBkColor(RGB(182,160,95));
	m_listPlayers.SetGridColor(0, RGB(155,155,155));
	m_listPlayers.SetGridColor(1, RGB(66,28,19));
	m_listPlayers.m_crTextColor = RGB(255,255,255);
	m_listPlayers.m_crTextBkColor = RGB(222,200,135);
	m_listPlayers.m_bBackground = TRUE;

//	{
//	m_listPlayers.CreateButtons(5, TRUE);
//	int n=0;
//	m_listPlayers.EnableItemButton(n, TRUE);
//	m_listPlayers.DrawItemButton(n, "Join", n/3, 2, TRUE);			
//	}

	// Create child tabctrl for lobby selection of [Tbls / Msg] [Tables] [Msg-Board] [Lobby Select]
	rect.SetRect(0,0,165+20+100+15+20,100+15+100);
	rect.OffsetRect(100,100);
//	m_tabLobbyCtrlEx.SetPaddingSize( CSize(5, 5) );
	m_tabLobbyCtrlEx.Create(TCS_OWNERDRAWFIXED | TCS_SINGLELINE | WS_CHILD /*| WS_VISIBLE*/ /*| WS_BORDER*/, rect, this, IDC_TABCTRLLOBBY);
	m_tabLobbyCtrlEx.PassParent(this);
	
	m_tableTabCtrlDlg.GetParent(this);
	m_tableTabCtrlDlg.Create(IDD_TABLETABCTRL, &m_tabLobbyCtrlEx);


	m_bootDlg.GetParent(this);
	m_bootDlg.Create(IDD_BOOT);

	
	m_tabLobbyCtrlEx.SetCornerPointTabs(CPoint(0,28-3));
	m_tabLobbyCtrlEx.SetNormalColor(RGB(75, 75 ,75));
	m_tabLobbyCtrlEx.SetSelectedColor(RGB(0, 0, 0));
	m_tabLobbyCtrlEx.SetTabColor(RGB(160,160,160));
	m_tabLobbyCtrlEx.SetTabSelectedColor(RGB(255,60,60));

	#ifndef MAIN_SERVER
	/*
	m_tabLobbyCtrlEx.CreateItem(0, "Tbls / Msg", (CWnd *)&m_tableTabCtrlDlg);
	m_tabLobbyCtrlEx.CreateItem(1, "Tables", (CWnd *)&m_tableTabCtrlDlg);
	m_tabLobbyCtrlEx.CreateItem(2, "Leagues", (CWnd *)&m_tableTabCtrlDlg);//m_tabLobbyCtrlEx.CreateItem(2, "Msg-Board", (CWnd *)&m_tableTabCtrlDlg);	
	m_tabLobbyCtrlEx.CreateItem(3, "Tournaments", (CWnd *)&m_tableTabCtrlDlg);
	m_tabLobbyCtrlEx.CreateItem(4, "Lobby Select", (CWnd *)&m_lobbySelectDlg);
	*/
	 #else // MAIN_SERVER
	//m_tabLobbyCtrlEx.CreateItem(0, "Tables", (CWnd *)&m_tableTabCtrlDlg);
	#endif

	m_tabLobbyCtrlEx.GetTabTotalRect();

	m_lobbySelectTabCtrlDlg.GetParent(this);
	m_lobbySelectTabCtrlDlg.Create(IDD_LOBBYSELECT, &m_tabLobbyCtrlEx);

	#ifndef MAIN_SERVER
		m_SmileySelectDlg.GetParent(this);
		m_SmileySelectDlg.Create(IDD_SMILEYSELECT);
		m_SmileySelectDlg.Init(TRUE);

		
		m_TextColorChangerDlg.GetParent(this);
		m_TextColorChangerDlg.Create(IDD_TEXTCOLORCHANGER);
		m_TextColorChangerDlg.Init(TRUE);
		

	#endif

	// Create ViewTables Button //
	rect.SetRect(0,0,70,24);
	m_viewtablesButton.Create("View Tables", BS_PUSHBUTTON | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONVIEWTABLES);		// Exit Lobby IDC
	m_viewtablesButton.SetBitmap(Skin_ButtonViewTables[0]);		// 'Click Here To View Tables' button //
	
		

	// Create Exit Lobby Button //
	rect.SetRect(0,0,70,24);
	m_exitlobbyButton.Create("Exit Lobby", BS_PUSHBUTTON | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONDROP4);		// Exit Lobby IDC
	m_exitlobbyButton.SetBitmap(Skin_ButtonExitLobby);
	// Create Change Lobby Button //
	rect.SetRect(0,0,90,24);
	m_changelobbyButton.Create("Change Lobby", BS_PUSHBUTTON | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONCHANGELOBBY);
	m_changelobbyButton.SetBitmap(Skin_ButtonChangeLobby);
	
	// Create Toggle Full MSB Lobby Button //
	rect.SetRect(0,0,40,24);
	m_messageBoardFullButton.Create("MB Full", BS_PUSHBUTTON | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONFULLTOGGLE);
	m_messageBoardFullButton.SetBitmap(Skin_ButtonMBFullLobby);
	


	// Create Home Button (Defaultly On) //
	rect.SetRect(0,0,51,24);
	m_homeButton.Create("Home", BS_PUSHBUTTON | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONHOME);
	m_homeButton.SetBitmap(Skin_ButtonMsgBoardTabOn[0]);
	// Create Register Button (Defaultly Off) //
	rect.SetRect(0,0,73,24);
	m_registerButton.Create("Register", BS_PUSHBUTTON | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONREGISTER);
	m_registerButton.SetBitmap(Skin_ButtonMsgBoardTabOn[1]);
	// Create Tourneys Button (Defaultly Off) //
	rect.SetRect(0,0,76,24);
	m_tourneysButton.Create("Tourneys", BS_PUSHBUTTON | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONTOURNEYS);
	m_tourneysButton.SetBitmap(Skin_ButtonMsgBoardTabOn[2]);
	// Create Leagues Button (Defaultly Off) //
	// rect.SetRect(0,0,70,24);
	// m_leaguesButton.Create("Refresh", BS_PUSHBUTTON | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONLEAGUES);
	// m_leaguesButton.SetBitmap(Skin_ButtonMsgBoardTabOn[3]);

	// Create Refresh Button (Defaultly Off) //
	rect.SetRect(0,0,70,24);
	m_refreshButton.Create("Refresh", BS_PUSHBUTTON | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONREFRESH);
	m_refreshButton.SetBitmap(Skin_ButtonRefresh);
	m_refreshButtonEnabled = TRUE;


	// create "Enter Lobby" button
	rect.SetRect(0,0,72,26);
	m_EnterLobbyButton.Create("Enter Lobby", BS_PUSHBUTTON || WS_CHILD | WS_BORDER, rect, this, IDC_BUTTONENTERLOBBY);	
	m_EnterLobbyButton.EnableWindow(FALSE);
		
	// create some buttons
	n = 0;
	w = 70;
	h = 20;//32;
	int hoff = 10;

	Mmain_log("[6]");
	for(x=0;x<2;x++)
	for(y=0;y<4;y++)
	{
		
		if(n==4) // Stand Up
		{
			
			rect.SetRect(0,0,w,h);
			rect.OffsetRect(0 + (w+32)*x, 0 + (h+hoff)*y);
			sprintf(buffer,"%s", g_button_name[BUTTON_STANDUP]);
			m_standButton.Create(buffer, BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | WS_BORDER | BS_BITMAP, rect, this, IDC_BUTTONDROP1+n);
			m_standButton.GetParent(this);
			m_standButton.SetId(100);
			m_standButton.SetBitmap(Skin_ButtonG[8]); 
		}
		
		//else
		{
			rect.SetRect(0,0,w,h);
			rect.OffsetRect(0 + (w+32)*x, 0 + (h+hoff)*y);
			sprintf(buffer,"%s", g_button_name[n]);
			if(n == 7)
				m_button[n].Create(buffer, BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONSETUP);
			else
				m_button[n].Create(buffer, BS_BITMAP, rect, this, IDC_BUTTONDROP1+n);


		m_button[n].SetBitmap(Skin_ButtonG[n]); 

			
			
			//m_button[n].SetFont(m_pFntData->font);
		}
		n++;
	if(n == 8)
		{
		y--;
		goto endxy;
		}
	}

endxy:;
		
	x++;
	y++;
	Mmain_log("[7]");


	//m_standButton.SetFont(m_pFntData->font);

	// rated button
	rect.SetRect(0,0,15,15);
	rect.OffsetRect(0 + (w+32)*x - 20, 0 + (h+hoff)*(y+1));
	sprintf(buffer,"");//Rated");
	m_ratedButton.Create(buffer, BS_3STATE  | WS_VISIBLE | WS_CHILD | WS_BORDER, rect, this, IDC_BUTTONRATED);
	m_ratedButton.SetCheck(1);

	// miss-Rule button
	//if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		y++;
		rect.SetRect(0,0,15,15);
		rect.OffsetRect(0 + (w+32)*x - 20, 0 + (h+hoff)*(y+1));
		sprintf(buffer,"");//Rated");
		m_missRuleButton.Create(buffer, BS_3STATE  | WS_VISIBLE | WS_CHILD | WS_BORDER, rect, this, IDC_BUTTONMISSRULE);
		m_missRuleButton.SetCheck(0);
	}
	
	
	// create sit buttons
	rect.SetRect(0,0,40,24);
	rect.OffsetRect(0+4,200);
	m_sit1PButton.Create("Sit", BS_PUSHBUTTON | /*WS_VISIBLE |*/ WS_CHILD | WS_BORDER, rect, this, 65000);
	m_sit1PButton.SetWindowPos(&wndTop, 0,0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_sit1PButton.GetParent(this);
	m_sit1PButton.SetId(0);

	rect.SetRect(0,0,40,24);
	rect.OffsetRect(400+4,400);
	m_sit2PButton.Create("Sit", BS_PUSHBUTTON | /*WS_VISIBLE |*/ WS_CHILD | WS_BORDER, rect, this, 65000);
	m_sit2PButton.SetWindowPos(&wndTop, 0,0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_sit2PButton.GetParent(this);
	m_sit2PButton.SetId(1);


	rect.SetRect(0,0,40,24);
	rect.OffsetRect(400+4,400);
	m_sit1PButtonB.Create("Sit", BS_PUSHBUTTON | /*WS_VISIBLE |*/ WS_CHILD | WS_BORDER, rect, this, 65000);
	m_sit1PButtonB.SetWindowPos(&wndTop, 0,0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_sit1PButtonB.GetParent(this);
	m_sit1PButtonB.SetId(2);	


	rect.SetRect(0,0,40,24);
	rect.OffsetRect(400+4,400);
	m_sit2PButtonB.Create("Sit", BS_PUSHBUTTON | /*WS_VISIBLE |*/ WS_CHILD | WS_BORDER, rect, this, 65000);
	m_sit2PButtonB.SetWindowPos(&wndTop, 0,0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_sit2PButtonB.GetParent(this);
	m_sit2PButtonB.SetId(3);

	Mmain_log("[8]");
	// "Say:" button
	rect.SetRect(0,0,28,22);
	sprintf(buffer,"Say:");
	#ifndef MAIN_SERVER
		m_sayButton.Create(buffer, BS_FLAT | WS_VISIBLE | WS_CHILD | BS_BITMAP, rect, this, IDC_BUTTONSAY);
		m_sayButton.SetBitmap(Skin_ButtonSayOn); // Defaultly Off, until we get some text in SendEdit 

		
	#else
		m_sayButton.Create(buffer, BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | WS_BORDER, rect, this, IDC_BUTTONSAY);
	#endif
	m_sendEdit.m_buttonstate = FALSE;
	//m_sayButton.EnableWindow(FALSE);
	
	
	#ifndef MAIN_SERVER
		// "SmileySelect" button
		rect.SetRect(0,0,28,22);
		sprintf(buffer,"(S)");
		m_smileyselectButton.Create(buffer, BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | WS_BORDER | BS_BITMAP, rect, this, IDC_SMILEYSELECT);
		m_smileyselectButton.SetBitmap(Skin_ButtonSmiley);
	#endif

	

	// Table Type ComboBox
	rect.SetRect(0,0,96 - 6,96/*24*/);
	sprintf(buffer,"Say:");
	m_tableTypeBox.Create(CBS_DROPDOWNLIST | WS_VISIBLE | WS_CHILD /*| WS_BORDER*/, rect, this, IDC_BOXTABLETYPE);
	m_tableTypeBox.InitStorage(3, 32);
	m_tableTypeBox.AddString("Public Table");
	m_tableTypeBox.AddString("Protected Table");
	m_tableTypeBox.AddString("Private Table");
	m_tableTypeBox.SetCurSel(0);
	m_tableTypeBox.SetFont(&m_listCtrlFontSmall);//m_listCtrlFont);
	m_tableTypeBox.EnableWindow(FALSE);
	
	Mmain_log("[9]");
	// create child sliderctrl window
	rect.SetRect(0,0,10,100+15);
	rect.OffsetRect(x+400/*+20+offX*/+45,y+10);
	m_sliderRaiseButt.Create(TBS_VERT | TBS_LEFT | TBS_NOTICKS/*| TBS_ENABLESELRANGE*/ | WS_CHILD | WS_VISIBLE /*| WS_BORDER*/, rect, this, IDC_WINDOWSLIDERRAISEBUTT);
	m_sliderRaiseButt.SetRange(0,90);
	m_sliderRaiseButt.SetPos(90);
	m_sliderRaiseButt.SetPageSize(15);
	
		
	Mmain_log("[10]");
	// create 'End Practice Session' button
	rect.SetRect(0,0,w,h);
	rect.OffsetRect(0 + (w+32)*x, 0 + (h+10)*y);
	sprintf(buffer,"End Practice Session");
	m_EndPracticeButton.Create(buffer, BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | WS_BORDER, rect, this, 
							   IDC_BUTTONENDPRACTICE);
	m_EndPracticeButton.EnableWindow(FALSE);
	m_EndPracticeButton.ShowWindow(SW_HIDE);


	//BAP_FIX//
	Mmain_log("[11]");
	// Create child CHtmlView window - Tournament Tourney
	



#ifndef MAIN_SERVER
	rect.SetRect(0,0,m_cx, 200+1);
	m_htmlViewBanner.Create(NULL, "HtmlViewBanner", WS_CHILD | WS_VISIBLE, rect, this, 20);
	m_htmlViewLeaderBoardA.Create(NULL, "HtmlViewLeaderBoardA", WS_CHILD | WS_VISIBLE, rect, this, 21);
	m_htmlViewLeaderBoardB.Create(NULL, "HtmlViewLeaderBoardB", WS_CHILD | WS_VISIBLE, rect, this, 22);
	m_htmlViewTickerBoard.Create(NULL, "TickerBoard", WS_CHILD | WS_VISIBLE, rect, this, 23);
	m_htmlViewMB.Create(NULL, "HtmlViewMB", WS_BORDER | WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL, rect, this, 24);

	//m_htmltest = new CHtmlViewEx;
	//m_htmltest->Create(NULL, "HtmlTest", WS_BORDER | WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL, CRect(100,100,400,300), this, 25);
#else
	Mmain_log("Server Config");
	// "Server Configure" button
	rect.SetRect(0,0,128,24);
	sprintf(buffer,"Server Config");
	m_serverConfigButton.Create(buffer, BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | WS_BORDER, rect, this, IDC_BUTTONSERVERCONFIG);
	Mmain_log("Account Config");
	sprintf(buffer,"Account Config");
	m_accountConfigButton.Create(buffer, BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | WS_BORDER, rect, this, IDC_BUTTONACCOUNTCONFIG);
	Mmain_log("Account Config");
	sprintf(buffer,"Lobby Stat.");
	m_lobbyStatButton.Create(buffer, BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | WS_BORDER, rect, this, IDC_BUTTONLOBBYSTAT);
#endif //MAIN_SERVER

	m_inviteDlg.GetParent(this);
	m_inviteDlg.DestroyWindow();
	m_inviteDlg.Create(IDD_INVITE);
	m_playerListDlg.GetParent(this);
	m_playerListDlg.DestroyWindow();
	m_playerListDlg.Create(IDD_PLAYERLIST);


	Mmain_log("GetParents");
	m_statsDlg.GetParent(this);
	m_statsTabCtrlDlg.GetParent(this);
	m_statsChatDlg.GetParent(this);
	m_statsDlg2.GetParent(this);
	m_personalDetailsDlg.GetParent(this);
	m_tournamentsDlg.GetParent(this);
	// m_shopDlg.GetParent(this);
	m_concedeDlg.GetParent(this);
	m_rerackDlg.GetParent(this);
	m_rerackAccept2Dlg.GetParent(this);
	m_inviteDlg.GetParent(this);
	m_playerListDlg.GetParent(this);
	m_practiceEditDlg.GetParent(this);
	for(n=0;n<MAX_INVITATIONDLGS;n++)
		m_invitationDlg[n].GetParent(this);
	m_invitationN = 0;
	if(g_build.gameType == GAMETYPE_POOL) m_tableSetupDlg.GetParent(this);
	else if(g_build.gameType == GAMETYPE_SNOOKER) m_tableSetupDlg2.GetParent(this);
	m_bootDlg.GetParent(this);
	m_replayDlg.GetParent(this);
	m_exitDlg.GetParent(this);
	m_alertDlg.GetParent(this);
	m_loginWizardDlg.GetParent(this);
	m_forfeitDlg.GetParent(this);
	m_notePadDlg.GetParent(this);

	m_lobbySelectDlg.GetParent(this);
	
	#ifndef MAIN_SERVER
		m_SmileySelectDlg.GetParent(this);
		
		// Load CLevel Images / Content
		m_cueChanger->Init(this);
		m_fineTuner->Init(this, 12, 370);
		m_chalkChanger->Init(this);
	#endif



	


	
	//m_tableTabCtrlDlg.ShowWindow(SW_SHOW);

	
//	// create Mgfx Sprite
//	Mgfx_sprload(&m_sprite,"Graphics/Balls/redNext.bmp",MGFX_SPR_NORMAL|MGFX_SPR_TRANS);
//	Mgfx_sprcolorkey(&m_sprite, Mgfx_rgbcolor(255,255,255));
//	
//	// create a CBitmap object - Test
//	BOOL bResult;
//	bResult = m_bitmap.CreateBitmap(16, 16, 1, 16, m_sprite.buf->c16/*const void* lpBits*/);
	
	Mmain_log("mainShell->Init");
	// init main shell network module
	mainShell->Init(this,2); // pass over hwnd




	//mainShell->CreateSeat(0,0+4,200);
	//mainShell->CreateSeat(1,400+4,400);
	//mainShell->CreateStand(100, &m_standButton); 
	//mainShell->AttachNameList(&m_listBox);
	//mainShell->DisplayConnection();

	Mmain_log("m_lobby->Init");
	// initialise lobby object
	m_lobby->Init();

#ifdef MAIN_SERVER

	Mmain_log("mainShell->ConnectionASYNC");
	// setup main server connection
	mainShell->ConnectionASYNC(TRUE, NULL, m_lobbySettings->m_lobbyPort, ASYNCSOCK_TYPE_MAINSERVER);

	
	

//	InitRankings(); // Redudant now - get rid of this shit later
//	SetRankingsFreq(g_config.m_postRankings);
	
#endif //MAIN_SERVER

#ifndef MAIN_SERVER
	// initialise snooker object
	Mmain_log("m_snooker->Init");
	m_snooker->Init();
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = TRUE;	
#endif //!MAIN_SERVER

	
	Mmain_log("OnCreate Complete");
	g_oncreatecomplete = TRUE;



	return 0;
}
/*
void  CGameAppView::OnDoAsyncGetServByName()
{
	if( m_hGetServByName = WSAAsyncGetServByName( m_hWnd, 
	WM_USER_ASYNCGETSERVBYNAME, "time", "udp", m_lpszServEntryBuf, 
	MAXGETHOSTSTRUCT) ) == 0 )
	{
		Cstring tempstr;
		wsprintf(m_lpszMessage,  "WSAAsyncGetServByName().. %d", WSAGetlastError() );
		MessageBox(m_lpszMessage, "Info");
	}
}
*/
void CGameAppView::ButtonPressedSend(char *str)
{
	#ifndef MAIN_SERVER

	//CGameAppDoc* pDoc = GetDocument();
	//ASSERT_VALID(pDoc);

	char buffer[2];
	sprintf(buffer,"%s",str);
	CString strText = buffer;
	//if(gameShell) gameShell->ChatSend(strText);
	if(mainShell) mainShell->ChatSend(strText);

	#endif //!MAIN_SERVER
}


void CGameAppView::SendServerData(int i)
{
	ServerSendData serverData;

	serverData.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	serverData.buffer[1] = 94;			// MSGGAME_SERVERDATA
	serverData.buffer[2] = 0;
	serverData.buffer[3] = 0;

	serverData.m_bOriginalVersion = g_bOriginalVersion;
	serverData.m_bTournament = g_bTournamentLobby;
	strcpy(serverData.m_handle, g_serverHandle.GetBuffer(0));

	if(mainShell)
	{
		if(i != -1)
			mainShell->Server->SendToQueue((void *)&serverData, sizeof(ServerSendData_typ), i);
	}
}

void CGameAppView::SendServerConfig(int i)
{// Server sends out it's config to client.
	if(mainShell)
	{
		if(i != -1)
			mainShell->Server->SendToQueue((void *)&g_serverConfig, sizeof(ServerSendConfig_typ), i);
	}
}

void CGameAppView::ServerConfigReceive(ServerSendConfig_typ *sd)
{// Client gets a copy of the server's config.
	#ifndef MAIN_SERVER
	memcpy(&g_serverConfig, sd, sizeof(ServerSendConfig_typ));
	#endif
}

// Main client-to-server sends
void CGameAppView::SendLobbyReady(BOOL bIsHost, int i)
{
	char buffer[4+(60*4)+180];

	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 57;		// MSGGAME_LOBBYREADY
	buffer[2] = 0;
	buffer[3] = 0;
	
	strcpy(&buffer[4], g_lobbyMessageBoard.GetBuffer(0));
	strcpy(&buffer[4+60], g_lobbyTournament.GetBuffer(0));
	strcpy(&buffer[4+60*2], g_lobbyLeague.GetBuffer(0));
	strcpy(&buffer[4+60*3], g_lobbyRegister.GetBuffer(0));
	strcpy(&buffer[4+60*4], g_URLlobbyLeaderBoardA.GetBuffer(0));
	strcpy(&buffer[4+60*4+90], g_URLlobbyLeaderBoardB.GetBuffer(0));
	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue(buffer, 4+(60*4)+180, i);
		else 
			mainShell->Client->SendToQueue(buffer, 4+(60*4)+180, i);
	}
}

void CGameAppView::SendLoginFailed(BOOL bIsHost, char type, int i)
{
	char buffer[4];

	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 59;		// MSGGAME_LOGINFAILED
	buffer[2] = 0;
	buffer[3] = type;
	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue(buffer, 4, i);
		else 
			mainShell->Client->SendToQueue(buffer, 4, i);
	}
}

void CGameAppView::SendLoginNewAccount(BOOL bIsHost, int i, int timetoexp)
{//timetoexp: 1 = Account hasn't expired, just a new (unique name) - 0 or less is expired.

	

	char buffer[8];
	int *v;
	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 66;		// MSGGAME_LOGINNEWACCOUNT
	buffer[2] = g_config.m_freeaccounts;//g_freeaccounts;		// 0 = membership code field, 1 = no membership code field required!
	buffer[3] = 0;
	v = (int *) &buffer[4];
	*v = timetoexp;
	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue(buffer, 8, i);
		else 
			mainShell->Client->SendToQueue(buffer, 8, i);
	}
}

void CGameAppView::SendAccountCreated(BOOL bIsHost, int type, int i)
{
	char buffer[4];

	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 68;		// MSGGAME_ACCOUNTCREATED
	buffer[2] = 0;
	buffer[3] = type;
	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue(buffer, 4, i);
		else 
			mainShell->Client->SendToQueue(buffer, 4, i);
	}
}



void CGameAppView::SendUpdateHistory(char *myself_name, char *opponent_name, int gameinfo, int time)
{
	HistoryReportData m_HistoryReportData;

	m_HistoryReportData.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	m_HistoryReportData.buffer[1] = 106;	// MSGGAME_UPDATEHISTORY
	m_HistoryReportData.buffer[2] = 0;
	m_HistoryReportData.buffer[3] = 0;
	
	strcpy(m_HistoryReportData.myself, myself_name);
	strcpy(m_HistoryReportData.opponent, opponent_name);
	m_HistoryReportData.gameinfo = gameinfo;
	m_HistoryReportData.time = time;
	
	
	// Get count for total history //
	int total_history = 0;
	for(int n=0;n<10;n++)
	if(g_history_data.time[n]) total_history++;


	// If we have 10 Items in our history_data, then we need to find the oldest entry, which will be then updated //
	int history_time = 2147483647;	// A large value sometime in the distant future //
	int history_id = -1;
	int idx = -1;
	if(total_history >= 10)
		{
		// Find Oldest History Result - This will be replaced by our new History Result //
		for(int n=0;n<10;n++)
		if(g_history_data.time[n])
		if(g_history_data.time[n] <= history_time) 
			{
			history_time = g_history_data.time[n];
			history_id = g_history_data.history_id[n];
			idx = n;
			}
		}

	m_HistoryReportData.update_hid = history_id;	

	
	// Update Local Variables //
	if(idx != -1)
		{
		g_history_data.time[idx] = time;
		g_history_data.history_id[idx] = history_id;
		}
	else{
		g_history_data.time[total_history] = time;
		g_history_data.history_id[total_history] = history_id;
		
		}

	




	if(mainShell)
	{
		mainShell->Client->SendToQueue((void *)&m_HistoryReportData, sizeof(HistoryReportData_typ));
	}
}


void CGameAppView::SendPlayerDetailsConnect2(BOOL bIsHost, Player *pPlr, int i, int blank_pass)
{
	playerDetailsSendDataConnect2 playerDetailsData;

	playerDetailsData.buffer[0] = 0x7f;	 // MSGCODE_GAME Game message.
	playerDetailsData.buffer[1] = 50;	 // MSGGAME_PLAYERDETAILS
	playerDetailsData.buffer[2] = 1;	 // 1 - New Server handshaking revision
	playerDetailsData.buffer[3] = 0;	 // MUST BE 1 otherwise invalid version!!!!

	//memcpy(&playerDetailsData.m_player, pPlr, sizeof(Player_typ));

	playerDetailsData.m_crc = g_crc;
	strcpy(playerDetailsData.m_versionstr, g_build.version);

	Player2 *plr;
	plr = &playerDetailsData.m_player2;

	strcpy(plr->name, pPlr->name);
	strcpy(plr->password, pPlr->password);
	plr->playerPort = pPlr->playerPort;
	//plr->playerIP[0] = 0;
	strcpy(plr->playerLocalIP, pPlr->playerLocalIP);
	//plr->playerSocketIdx = pPlr->playerSocketIdx;
	playerDetailsData.m_sysID = g_sysID;
	playerDetailsData.m_cpuID = g_cpuID;
	playerDetailsData.m_macID_U = g_macID_U;
	playerDetailsData.m_macID_L = g_macID_L;




	if(blank_pass) // defaultly the password is blanked out during sending. however the client must keep the password there upon initial connection
	memset(plr->password, 0, 20); // stop other players receiving this private info.
	
	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue((void *)&playerDetailsData, sizeof(playerDetailsSendDataConnect2_typ), i);
		else 
			mainShell->Client->SendToQueue((void *)&playerDetailsData, sizeof(playerDetailsSendDataConnect2_typ), i);
	}
}


void CGameAppView::SendPlayerDetailsCompact(BOOL bIsHost, Player *pPlr, int i, int blank_pass)
{
	int len, x, y, z;
	playerDetailsSendDataC playerDetailsDataC;

	playerDetailsDataC.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	playerDetailsDataC.buffer[1] = 87;		// MSGGAME_PLAYERDETAILSC

	playerDetailsDataC.playerSocketIdx = pPlr->playerSocketIdx;
	playerDetailsDataC.rating = pPlr->rating;
	////////////
	playerDetailsDataC.Max147s = pPlr->Max147s;
	playerDetailsDataC.pMax147s = pPlr->pMax147s;
	playerDetailsDataC._100s = pPlr->_100s;
	playerDetailsDataC._p100s = pPlr->_p100s;
	
	playerDetailsDataC._50s = pPlr->_50s; // 8-Ball Runouts (STD)
	playerDetailsDataC._60s = pPlr->_60s; // 9-Ball RunOuts (STD)
	playerDetailsDataC._70s = pPlr->_70s; // UK Pool RunOuts (STD)
	
	playerDetailsDataC._80s = pPlr->_80s; // 8-Ball Runouts (PRO)
	playerDetailsDataC._90s = pPlr->_90s; // 9-Ball RunOuts (PRO)
	playerDetailsDataC._p50s = pPlr->_p50s; // UK Pool RunOuts (PRO)

	playerDetailsDataC._p60s = pPlr->_p60s; // 8-Ball Runouts (UK)
	playerDetailsDataC._p70s = pPlr->_p70s; // 9-Ball RunOuts (UK)
	playerDetailsDataC._p80s = pPlr->_p80s; // English Pool RunOuts (UK)

	playerDetailsDataC.pBioAverageBreak = pPlr->pBioAverageBreak;
	playerDetailsDataC.BioAverageBreak = pPlr->bioAverageBreak;


	playerDetailsDataC.cuetype = pPlr->cuetype; 
	playerDetailsDataC.chalktype = pPlr->chalktype; 
	////////////
	playerDetailsDataC.table = pPlr->table;
	playerDetailsDataC.buffer[2] = pPlr->state;
	playerDetailsDataC.state2 = pPlr->state2;
	playerDetailsDataC.playertype = pPlr->playertype;
	playerDetailsDataC.bandata = pPlr->bandata;

	playerDetailsDataC.level = pPlr->level;
	playerDetailsDataC.level_progress = pPlr->level_progress;
	playerDetailsDataC.textColor = pPlr->textColor;
	playerDetailsDataC.cash = pPlr->cash;
	playerDetailsDataC.ladderPoints = pPlr->ladderPoints;
	playerDetailsDataC.ladderWinsLosses = pPlr->ladderWinsLosses;
	playerDetailsDataC.ladderHighBreak = pPlr->ladderHighBreak;



	//playerDetailsDataC.state = pPlr->state;
	playerDetailsDataC.id = pPlr->id;
	BYTE flag;
	flag = 0;
	if(pPlr->bInvited) flag|=1;
	if(pPlr->bIsGuest) flag|=2;
	playerDetailsDataC.buffer[3] = flag;
	//playerDetailsDataC.bInvited = pPlr->bInvited;
	//playerDetailsDataC.bIsGuest = pPlr->bIsGuest;
	strcpy(playerDetailsDataC.name, pPlr->name);
	playerDetailsDataC.textFormat = pPlr->textFormat;
	
	// Optimum: get exact size of packet (name is var. length (excludes stuff after terminator))
	//len = strlen(playerDetailsDataC.name);
	//len = (int)&playerDetailsDataC.name[len+1] - (int)&playerDetailsDataC;
	// Safety Slower way //
	len = sizeof(playerDetailsSendDataC_typ);


	//y = sizeof(playerDetailsSendDataC);
	//z = (int)playerDetailsDataC.name - (int)&playerDetailsDataC;
	//char buffer[80];
	//sprintf(buffer, "len = %d, x = %d, y = %d, z = %d", len, x, y, z);
	//ErrorMessage(this, buffer);

	/*
	OLD WAY:
	memcpy(&playerDetailsData.m_player, pPlr, sizeof(Player_typ));

	if(blank_pass) // defaultly the password is blanked out during sending. however the client must keep the password there upon initial connection
	memset(playerDetailsData.m_player.password, 0, 20); // stop other players receiving this private info.
	*/
	
	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue((void *)&playerDetailsDataC, len/*sizeof(playerDetailsSendDataC_typ)*/, i);
		else 
			mainShell->Client->SendToQueue((void *)&playerDetailsDataC, len/*sizeof(playerDetailsSendDataC_typ)*/, i);
	}	
}

// GenericRequests //////////////////////////////////////////////////////////////////

#define MSGGR_PLAYERDETAILS		0
#define MSGGR_IDLEAWAY			1

typedef struct genericrequestDetailsSendData_typ {
	BYTE buffer[4];
	BOOL bShowDialog;
} genericrequestDetailsSendData, *genericrequestDetailsSendData_ptr;

void CGameAppView::SendRequestPlayerDetails(int plrIdx, BOOL bShowDialog) // SEND //
{
	int sockIdx;
	if(!m_player[plrIdx].status) return; // status doesn't exist.

	sockIdx = m_player[plrIdx].playerSocketIdx;

	genericrequestDetailsSendData grDetailsData;

	grDetailsData.buffer[0] = 0x7f;	 // MSGCODE_GAME Game message.
	grDetailsData.buffer[1] = 89;	 // MSGGAME_GENERICREQUEST
	grDetailsData.buffer[2] = MSGGR_PLAYERDETAILS;
	grDetailsData.buffer[3] = sockIdx;	
	grDetailsData.bShowDialog = bShowDialog;
	
	mainShell->Client->SendToQueue((void *)&grDetailsData, sizeof(genericrequestDetailsSendData_typ), 0);
}

void CGameAppView::SendRequestIdleAway(BOOL bIdleAway) // SEND //
{
	genericrequestDetailsSendData grDetailsData;

	grDetailsData.buffer[0] = 0x7f;	 // MSGCODE_GAME Game message.
	grDetailsData.buffer[1] = 89;	 // MSGGAME_GENERICREQUEST
	grDetailsData.buffer[2] = MSGGR_IDLEAWAY;
	grDetailsData.buffer[3] = bIdleAway;

	mainShell->Client->SendToQueue((void *)&grDetailsData, sizeof(genericrequestDetailsSendData_typ), 0);
}

void CGameAppView::ReceiveRequest(BYTE *sd, int plrSockIdx) // LINK //
{
	switch(sd[2])
		{
		case MSGGR_PLAYERDETAILS:ReceiveRequestPlayerDetails(sd, plrSockIdx);
								break;
		case MSGGR_IDLEAWAY:
								{					
									int plrIdx = m_lobby->GetPlayerIdx(plrSockIdx);
									if(plrIdx!=-1){ //#
									if(sd[3]) // set to away state - after 5 mins
									{
										if((m_player[plrIdx].state&PLRSTATE_STATUSMASK) == PLRSTATE_AVAILABLE)
										{	
											m_player[plrIdx].state&=PLRSTATE_STATUSMASK^PLRSTATE_MASK; // destroy status bits
											m_player[plrIdx].state|= PLRSTATE_AWAY2;
											SendPlayerChangeData(plrIdx, PLAYERCHANGE_STATUS);
										}
									
									}
									else // set to available state - i.e. move mouse
									{
										if((m_player[plrIdx].state&PLRSTATE_STATUSMASK) == PLRSTATE_AWAY2)
										{	
											m_player[plrIdx].state&=PLRSTATE_STATUSMASK^PLRSTATE_MASK; // destroy status bits
											//m_player[plrIdx].state|= PLRSTATE_AVAILABLE;
											SendPlayerChangeData(plrIdx, PLAYERCHANGE_STATUS);
										}
									}
									} //#
								break;
								}
		}
}

void CGameAppView::ReceiveRequestPlayerDetails(void *sd_temp, int plrSockIdx) // RECEIVER
{ // Server receives this request.
#ifdef MAIN_SERVER	
	int RplrSockIdx;
	genericrequestDetailsSendData *sd;
	sd = (genericrequestDetailsSendData *) sd_temp;
	
	RplrSockIdx = sd->buffer[3];
	int RplrIdx = m_lobby->GetPlayerIdx(RplrSockIdx);
	if(RplrIdx==-1) return; // can't find this player forget it.
	if(!m_player[RplrIdx].status) return; // status doesn't exist.

	// Send player Details struct over. //
	playerDetailsSendData playerDetailsData;

	playerDetailsData.buffer[0] = 0x7f;	 // MSGCODE_GAME Game message.
	playerDetailsData.buffer[1] = 50;	 // MSGGAME_PLAYERDETAILS

	if(!sd->bShowDialog) playerDetailsData.buffer[2] = 0; // don't bring up dialogue - special case!!
	else playerDetailsData.buffer[2] = 1;	 // 1 = Special player details message (brings up dialog box)

	playerDetailsData.buffer[3] = RplrSockIdx;	// Socket index of the requested player.

	memcpy(&playerDetailsData.m_player, &m_player[RplrIdx], sizeof(Player_typ));

	// Send Over History Information Also //
	HistoryData *history_data;
	history_data = (HistoryData_typ *) db_getgamehistory(m_player[RplrIdx].name);
	memcpy(&playerDetailsData.m_history, (HistoryData_typ *) history_data, sizeof(HistoryData_typ));
	

	// blank out password when sending it over.
	memset(playerDetailsData.m_player.password, 0, 20); // stop other players receiving this private info.
	mainShell->Server->SendToQueue((void *)&playerDetailsData, sizeof(playerDetailsSendData_typ), plrSockIdx);
#endif MAIN_SERVER
}

void CGameAppView::SendTableDetails(BOOL bIsHost, Table *pTbl, int i)
{
	tableDetailsSendData tableDetailsData;

	tableDetailsData.buffer[0] = 0x7f;	 // MSGCODE_GAME Game message.
	tableDetailsData.buffer[1] = 53;	 // MSGGAME_TABLEDETAILS
	tableDetailsData.buffer[2] = 0;
	tableDetailsData.buffer[3] = 0;

	// memcpy over the fixed data //
	memcpy(&tableDetailsData.m_table, pTbl, sizeof(Table_typ));


	tableDetailsData.m_table.playersSockIdxN = 0;
	for(int n=0;n<MAX_TABLE_PLAYERS;n++)
	if(pTbl->playersSockIdx[n] != -1) tableDetailsData.m_table.playersSockIdxN++;

	// Find out how much of playersSockIdx we need to send over //
	int packetsize =  sizeof(tableDetailsSendData_typ);
	packetsize -= ((MAX_TABLE_PLAYERS-tableDetailsData.m_table.playersSockIdxN) * 4);


	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue((void *)&tableDetailsData, packetsize, i);
		else 
			mainShell->Client->SendToQueue((void *)&tableDetailsData, packetsize, i);
	}
}


void CGameAppView::SendPlayerJoin(BOOL bIsHost, int tableIdx, int enterType, int playerSockIdx, BOOL bIsTableHost, int i, DWORD tableseatsA, DWORD tableseatsB)
{

	/*
	 * Add to our TableJoinLog (local file)
	 */

	playerJoinSendData playerJoinData;

	playerJoinData.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	playerJoinData.buffer[1] = 51;		// MSGGAME_PLAYERJOIN
	playerJoinData.buffer[2] = 0;
	playerJoinData.buffer[3] = 0;

	playerJoinData.m_tableIdx = tableIdx;
	playerJoinData.m_enterType = enterType;
	playerJoinData.m_playerSockIdx = playerSockIdx;
	playerJoinData.m_bIsTableHost = bIsTableHost;

	playerJoinData.m_tableseatsA = tableseatsA;
	playerJoinData.m_tableseatsB = tableseatsB;

	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue((void *)&playerJoinData, sizeof(playerJoinSendData_typ), i);
		else
			mainShell->Client->SendToQueue((void *)&playerJoinData, sizeof(playerJoinSendData_typ), i);

	}


}


void CGameAppView::SendPlayerReJoin(BOOL bIsHost, int tableIdx, int i)
{
	playerReJoinSendData playerReJoinData;

	playerReJoinData.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	playerReJoinData.buffer[1] = 56;	//MSGGAME_PLAYERREJOIN
	playerReJoinData.buffer[2] = 0;
	playerReJoinData.buffer[3] = 0;

	playerReJoinData.m_tableIdx = tableIdx;
	
	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue((void *)&playerReJoinData, sizeof(playerReJoinSendData_typ), i);
		else
			mainShell->Client->SendToQueue((void *)&playerReJoinData, sizeof(playerReJoinSendData_typ), i);
	}
}


void CGameAppView::SendPlayerJoinFailed(BOOL bIsHost, int joinerSockIdx, int hostSockIdx, int i)
{
	playerJoinFailedSendData playerJoinFailedData;

	playerJoinFailedData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	playerJoinFailedData.buffer[1] = 58;   // MSGGAME_PLAYERJOINFAILED
	playerJoinFailedData.buffer[2] = sizeof(playerJoinFailedSendData_typ);
	playerJoinFailedData.buffer[3] = 0;

	playerJoinFailedData.m_joinerSockIdx = joinerSockIdx;
	playerJoinFailedData.m_hostSockIdx = hostSockIdx;

	if(bIsHost)
		mainShell->Server->SendToQueue((void *)&playerJoinFailedData, sizeof(playerJoinFailedSendData_typ), i);
	else
		mainShell->Client->SendToQueue((void *)&playerJoinFailedData, sizeof(playerJoinFailedSendData_typ), i);
}


void CGameAppView::SendPlayerExit(BOOL bIsHost, int playerSockIdx, BOOL bTimedOutBoot, BOOL bPLC)
{
	playerExitSendData playerExitData;

	playerExitData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	playerExitData.buffer[1] = 52;	 // MSGGAME_PLAYEREXIT
	playerExitData.buffer[2] = sizeof(playerExitSendData_typ);
	playerExitData.buffer[3] = 0;

	playerExitData.m_playerSockIdx = playerSockIdx;
	playerExitData.m_bTimedOutBoot = bTimedOutBoot;
	playerExitData.m_bPLC = bPLC;

	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue((void *)&playerExitData, sizeof(playerExitSendData_typ));
		else
			mainShell->Client->SendToQueue((void *)&playerExitData, sizeof(playerExitSendData_typ));
	}
}

void CGameAppView::SendPlayerSit(BOOL bIsHost, int seat1SockIdx, int seat2SockIdx, int tableIdx, int seat1bSockIdx, int seat2bSockIdx)
{
	playerSitSendData playerSitData;

	playerSitData.buffer[0] = 0x7f;	 // MSGCODE_GAME Game message.
	playerSitData.buffer[1] = 54;	 // MSGGAME_PLAYERSIT
	playerSitData.buffer[2] = sizeof(playerSitSendData_typ);
	playerSitData.buffer[3] = 0;

	playerSitData.m_seat1SockIdx = seat1SockIdx;
	playerSitData.m_seat2SockIdx = seat2SockIdx;
	playerSitData.m_tableIdx = tableIdx;
	playerSitData.m_seat1bSockIdx = seat1bSockIdx;
	playerSitData.m_seat2bSockIdx = seat2bSockIdx;

	
	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue((void *)&playerSitData, sizeof(playerSitSendData_typ));
		else
			mainShell->Client->SendToQueue((void *)&playerSitData, sizeof(playerSitSendData_typ));
	}
}

void CGameAppView::SendTableHostDetails(BOOL bIsHost, int cueError, BOOL bRated, char type, BOOL bmissRule, int playerSockIdx,
										BYTE shotTime, BYTE tableColour, BYTE gameType, BYTE addTimer, BYTE doubles,
										BYTE raceTo, BYTE whoBreaks,
										BYTE ballSize, BYTE rackType, BYTE tableType, BYTE proTable,
										int tournamentTable, int fp1, int fp2, int score1, int score2, bool bLadderMatch)
{
	tableHostDetailsSendData tableHostDetailsData;

	tableHostDetailsData.buffer[0] = 0x7f;	 // MSGCODE_GAME Game message.
	tableHostDetailsData.buffer[1] = 55;	 // MSGGAME_TABLEHOSTDETAILS
	tableHostDetailsData.buffer[2] = sizeof(tableHostDetailsSendData_typ);
	tableHostDetailsData.buffer[3] = 0;
	
	tableHostDetailsData.m_cueError = cueError;
	tableHostDetailsData.m_bRated = bRated;
	tableHostDetailsData.m_type = type;
	tableHostDetailsData.m_bMissRule = bmissRule;

	tableHostDetailsData.m_shotTime = shotTime;
	tableHostDetailsData.m_tableColour = tableColour;
	tableHostDetailsData.m_gameType = gameType;
	tableHostDetailsData.m_addTimer = addTimer;
	tableHostDetailsData.m_raceTo = raceTo;
	tableHostDetailsData.m_whoBreaks = whoBreaks;
	tableHostDetailsData.m_ballSize = ballSize;
	tableHostDetailsData.m_rackType = rackType;
	tableHostDetailsData.m_tableType = tableType;
	tableHostDetailsData.m_proTable = proTable;
	tableHostDetailsData.m_doubles = doubles;
				
	tableHostDetailsData.m_playerSockIdx = playerSockIdx;
	tableHostDetailsData.m_tournamentTable = tournamentTable;
	tableHostDetailsData.m_fp1 = fp1;
	tableHostDetailsData.m_fp2 = fp2;
	tableHostDetailsData.m_score1 = score1;
	tableHostDetailsData.m_score2 = score2;
	tableHostDetailsData.m_bLadderMatch = bLadderMatch;

	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue((void *)&tableHostDetailsData, sizeof(tableHostDetailsSendData_typ));
		else
			mainShell->Client->SendToQueue((void *)&tableHostDetailsData, sizeof(tableHostDetailsSendData_typ));
	}
}

// Game client-to-Server sends
void CGameAppView::SendPlayerShot(float sx,float sy,float sz, float ex,float ey,float ez, M3d_vtx cuetip, int m_selectBall, float m_strikeRnd, float m_strikeMaxRnd,
								  BOOL m_ballMouseOn, M3d_vtx m_ballMousePos, int m_nominateBall, int m_testBallColour, DWORD crc)
{
	#ifndef MAIN_SERVER
	
	strikeBallSendData strikeBallData;
	
	strikeBallData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	strikeBallData.buffer[1] = 0;	 // MSGGAME_SHOT
	strikeBallData.buffer[2] = sizeof(strikeBallSendData_typ);
	strikeBallData.buffer[3] = 0;
	
	strikeBallData.m_sPoint[0] = sx;
	strikeBallData.m_sPoint[1] = sy;
	strikeBallData.m_sPoint[2] = sz;
	strikeBallData.m_tableMousePos[0] = ex;
	strikeBallData.m_tableMousePos[1] = ey;
	strikeBallData.m_tableMousePos[2] = ez;
	strikeBallData.m_cuetip[0] = cuetip[0];
	strikeBallData.m_cuetip[1] = cuetip[1];
	strikeBallData.m_cuetip[2] = cuetip[2];
	strikeBallData.m_selectBall = m_selectBall;
	strikeBallData.m_strikeRnd = m_strikeRnd;
	strikeBallData.m_strikeMaxRnd = m_strikeMaxRnd;

	strikeBallData.m_ballMouseOn = m_ballMouseOn;
	strikeBallData.m_ballMousePos[0] = m_ballMousePos[0];
	strikeBallData.m_ballMousePos[1] = m_ballMousePos[1];
	strikeBallData.m_ballMousePos[2] = m_ballMousePos[2];
	strikeBallData.m_nominateBall = m_nominateBall;

	strikeBallData.m_testBallColour = m_testBallColour;

	//strikeBallData.m_nSimEndMsgBalls <--- this var is set on the server rec. side 

	strikeBallData.m_crc = crc;

	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue((void *)&strikeBallData, sizeof(strikeBallSendData_typ));
	
	#endif //!MAIN_SERVER
}

void CGameAppView::SendPlayerBallPos(CVector pos, int m_selectBall)
{
	#ifndef MAIN_SERVER
	
	ballPosSendData ballPosData;
	
	ballPosData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	ballPosData.buffer[1] = 3;	  // MSGGAME_BALL_POS
	ballPosData.buffer[2] = sizeof(ballPosSendData_typ);
	ballPosData.buffer[3] = 0;
	
	ballPosData.m_P = pos;
	ballPosData.m_selectBall = m_selectBall;

	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue((void *)&ballPosData, sizeof(ballPosSendData_typ));
	
	#endif //!MAIN_SERVER	
}

void CGameAppView::SendPlayerSelectBall(int select, CPoint point, int w, int h, int selectBall)
{
	#ifndef MAIN_SERVER
	
	selectBallSendData selectBallData;
	
	selectBallData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	selectBallData.buffer[1] = 4;	 // MSGGAME_SELECT_BALL
	selectBallData.buffer[2] = sizeof(selectBallSendData_typ);
	selectBallData.buffer[3] = 0;
	
	selectBallData.m_cueBallSelect = select;// specific send data
	selectBallData.m_point = point;
	selectBallData.w = w;
	selectBallData.h = h;

	selectBallData.m_selectBall = selectBall;
	
	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue((void *)&selectBallData, sizeof(selectBallSendData_typ));
	
	#endif //!MAIN_SERVER
}														

void CGameAppView::SendPlayerMouseMove(float x, float y, int w, int h, float strikeLine, float strikeDist)
{
	#ifndef MAIN_SERVER
	
	mouseMoveSendData mouseMoveData;
	
	mouseMoveData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	mouseMoveData.buffer[1] = 5;	// MSGGAME_MOUSE_MOVE
	mouseMoveData.buffer[2] = sizeof(mouseMoveSendData_typ);
	mouseMoveData.buffer[3] = 0;
	
	mouseMoveData.x = x;
	mouseMoveData.y = y;
	mouseMoveData.w = w;
	mouseMoveData.h = h;
	mouseMoveData.strikeLine = strikeLine;
	mouseMoveData.strikeDist = strikeDist;
	
	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue((void *)&mouseMoveData, sizeof(mouseMoveSendData_typ));
	
	#endif //!MAIN_SERVER
}

void CGameAppView::SendPlayerCueBallTip(float sx, float sy, float sz, float ex, float ey, float ez,
										BOOL ballMouseOn, M3d_vtx ballMousePos, M3d_vtx cueTip,
										int nominateBall,
										int RaiseButt, int RaiseButtOld,
										float cueAngle)
{
	#ifndef MAIN_SERVER
	
	CueBallTipSendData CueBallTipData;
	
	CueBallTipData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	CueBallTipData.buffer[1] = 6;	 // MSGGAME_CUE_BALL_TIP
	CueBallTipData.buffer[2] = sizeof(CueBallTipSendData_typ);
	CueBallTipData.buffer[3] = 0;
	
	CueBallTipData.m_sx = sx;
	CueBallTipData.m_sy = sy;
	CueBallTipData.m_sz = sz;
	CueBallTipData.m_ex = ex;
	CueBallTipData.m_ex = ey;
	CueBallTipData.m_ex = ez;
	CueBallTipData.m_ballMouseOn = ballMouseOn;
	CueBallTipData.m_ballMousePos[0] = ballMousePos[0];
	CueBallTipData.m_ballMousePos[1] = ballMousePos[1];
	CueBallTipData.m_ballMousePos[2] = ballMousePos[2];
	CueBallTipData.m_cueTip[0] = cueTip[0];
	CueBallTipData.m_cueTip[1] = cueTip[1];
	CueBallTipData.m_cueTip[2] = cueTip[2];
	CueBallTipData.m_nominateBall = nominateBall;
	CueBallTipData.m_RaiseButt = RaiseButt;
	CueBallTipData.m_RaiseButtOld = RaiseButtOld;
	CueBallTipData.m_cueAngle = cueAngle;
	
	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue((void *)&CueBallTipData, sizeof(CueBallTipSendData_typ));
	
	#endif //!MAIN_SERVER
}

void CGameAppView::SendPlayerCueBallTipCompact(float sx, float sy, float sz, float ex, float ey, float ez,
										BOOL ballMouseOn, M3d_vtx ballMousePos, M3d_vtx cueTip,
										int nominateBall,
										int RaiseButt, int RaiseButtOld,
										float cueAngle)
{
	#ifndef MAIN_SERVER

	float x,y;
	float m;
	//BYTE angleFF;
	WORD angleFF;
	BYTE powerFF;
	BYTE selectBall;
	BYTE raiseButt;
	BYTE nomBall;
	BYTE cueTipMash;
	int cueTipMash_x,cueTipMash_y;

	x = ex-sx; // position of cue relative to selected ball
	y = ey-sy;
	m = sqrt(x*x + y*y);	// 0 -2000 ish - rescale to 0-200 (that'll do)
	//angleFF = Mgame_avect(x,y);
	angleFF = cueAngle * RAD2FF * 256.0f;
	powerFF = m/10;	// 0 - 2000 => 0-200
	selectBall = m_snooker->m_selectBall; // 0 to 20ish
	raiseButt = RaiseButt;
	nomBall = nominateBall; // 0 to 20ish (but only color balls)
	cueTipMash_x = (cueTip[0]+1)*8; // 0.5 to 1.5 unreq'd
	cueTipMash_y = (cueTip[1]+1)*8; // 0.5 to 1.5 unreq'd
	cueTipMash = (cueTipMash_y<<4) | cueTipMash_x;
			
	/*{
	int a,b,c;
	a = angleFF;
	b = powerFF;
	c = selectBall;
	char buffer[256];
	sprintf(buffer,"[%d, %d, %d, [%f]]",a, b, c, cueAngle);
	ErrorMessage(this, buffer);
	//sprintf(buffer,"[%d: %.2f (%d) (%d)]",a, m,ballMouseOn,m_snooker->m_selectBall);
	//ErrorMessage(this, buffer);
	}*/
	
	CueBallTipSendDataC CueBallTipDataC;
	
	CueBallTipDataC.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	CueBallTipDataC.buffer[1] = 88;	 // MSGGAME_CUE_BALL_TIPC
	CueBallTipDataC.buffer[2] = nomBall;	// nominate
	CueBallTipDataC.buffer[3] = cueTipMash;	// 4:4 mash [cx,cy] cue x cue y
	CueBallTipDataC.selectBall = selectBall; // -1 = no ball, n = ball selected
	CueBallTipDataC.power = powerFF;		// 0 - 255 = 0 - 100%
	CueBallTipDataC.angle = angleFF;		// (0 - 255)*256 = 0 - 360           // 0 - 255 = 0 - 360
	CueBallTipDataC.raise = raiseButt;		// 0 - 90 = 0 - 90'

	if(mainShell)
		mainShell->Client->SendToQueue((void *)&CueBallTipDataC, sizeof(CueBallTipSendDataC_typ));
	
	#endif //!MAIN_SERVER
}

void CGameAppView::SendPlayerPlayAgain(void)
{
	#ifndef MAIN_SERVER

	char buffer[4];
	buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	buffer[1] = 7;	  // MSGGAME_PLAYAGAIN
	buffer[2] = 0;
	buffer[3] = 0;

	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue(buffer, 4);

	#endif //!MAIN_SERVER
}

void CGameAppView::SendUpdateGame(void)
{
	#ifndef MAIN_SERVER

	char buffer[4];
	buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	buffer[1] = 14;	  // MSGGAME_UPDATEGAME
	buffer[2] = 0;
	buffer[3] = 0;

	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue(buffer, 4);

	#endif //!MAIN_SERVER
}


void CGameAppView::SendPlayerFoulAlert(char n)
{
	#ifndef MAIN_SERVER

	char buffer[4];
	buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	buffer[1] = 10;	  // MSGGAME_FOULALERT
	buffer[2] = 0;
	buffer[3] = n;

	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue(buffer, 4);

	#endif //!MAIN_SERVER
}

//SendPlayerFoulAlertReceive();

void CGameAppView::SendPlayerMissReset(void)
{
	#ifndef MAIN_SERVER

	char buffer[4];
	buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	buffer[1] = 11;	  // MSGGAME_MISSRESET
	buffer[2] = 0;
	buffer[3] = 0;

	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue(buffer, 4);

	#endif //!MAIN_SERVER
}


void CGameAppView::SendPot8BallOnBreakRerack(char type)
{
	#ifndef MAIN_SERVER

	char buffer[4];
	buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	buffer[1] = 12;	  // MSGGAME_POT8BALLONBREAKRERACK
	buffer[2] = 0;
	buffer[3] = type;

	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue(buffer, 4);

	#endif //!MAIN_SERVER
}


void CGameAppView::SendBadBreakRerack(BOOL bOpponentToBreak)
{
	#ifndef MAIN_SERVER

	char buffer[4];
	buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	buffer[1] = 13;	  // MSGGAME_BADBREAKRERACK
	buffer[2] = 0;
	buffer[3] = 0;

	if(bOpponentToBreak)
		buffer[3] = 1;

	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue(buffer, 4);

	#endif //!MAIN_SERVER
}


void CGameAppView::SendReset(char playerTurn)
{
	#ifndef MAIN_SERVER

	char buffer[16];
	buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	buffer[1] = 1;	  // MSGGAME_RESET
	buffer[2] = 0;
	buffer[3] = playerTurn;

	int *v = (int *)&buffer[4];
	*v = rand();

	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue(buffer, 16);

	#endif //!MAIN_SERVER
}

void CGameAppView::SendSimEnd(int plrSockIdx, BOOL bShotEnd)
{
	#ifndef MAIN_SERVER
	
	SimEndSendData SimEndData;
	
	SimEndData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	SimEndData.buffer[1] = 2;	  // MSGGAME_SIM_END				
	SimEndData.buffer[2] = plrSockIdx; // -1 to 127
	SimEndData.buffer[3] = bShotEnd; // 0 or 1
	
	//SimEndData.m_plrSockIdx = plrSockIdx;
	//SimEndData.m_bShotEnd = bShotEnd;
	
	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue((void *)&SimEndData, sizeof(SimEndSendData_typ));

	#endif //!MAIN_SERVER
}


void CGameAppView::SendSimStart(int plrSockIdx)
{
	#ifndef MAIN_SERVER
	
	SimStartSendData SimStartData;
	
	SimStartData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	SimStartData.buffer[1] = 9;	   // MSGGAME_SIM_START				
	SimStartData.buffer[2] = 0;
	SimStartData.buffer[3] = 0;
	
	SimStartData.m_plrSockIdx = plrSockIdx;
	
	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue((void *)&SimStartData, sizeof(SimStartSendData_typ));

	#endif //!MAIN_SERVER
}


void CGameAppView::SendBalls(BOOL bIsHost, BOOL bSimEnd, int i, BOOL bForceReceive)
{
	#ifndef MAIN_SERVER
	
			
	BallsSendData ballsData;

	ballsData.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	ballsData.buffer[1] = 8;		// MSGGAME_BALLS
	ballsData.buffer[2] = 0;	// Use this to store the table Number - required for Lobby TV //
	ballsData.buffer[3] = i;
	
	
	int m;
	for(m=0;m<MAX_TOTALBALLS;m++)
	{
		if(TestFlag(m_snooker->m_ball[m]->m_flags, Flg_BALL_ACTIVE))
		{
			ballsData.m_ballx[m] = m_snooker->m_ball[m]->m_P.x;
			ballsData.m_bally[m] = m_snooker->m_ball[m]->m_P.y;
		}
		else
		{
			#ifdef THE_POOL_CLUB			
			ballsData.m_ballx[m] = m_snooker->m_ball[m]->m_P.x;
			ballsData.m_bally[m] = m_snooker->m_ball[m]->m_P.y;

			// override possibly for Bowls
			if(m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
			if(TestFlag(m_snooker->m_ball[m]->m_flags, Flg_BALL_POTTED))
			{
				ballsData.m_ballx[m] = 20000;
				ballsData.m_bally[m] = 20000;
			}

			#else
			ballsData.m_ballx[m] = 10000;
			ballsData.m_bally[m] = 10000;
			#endif //THE_POOL_CLUB
		}
	}


	// Make sure data is decoded when it's sent //
	m_snooker->m_customTable->Decode();
	
	ballsData.m_score1P = m_snooker->m_score1P;
	ballsData.m_score2P = m_snooker->m_score2P;
	ballsData.m_break1P = m_snooker->m_break1P;
	ballsData.m_break2P = m_snooker->m_break2P;
	ballsData.m_bTurn1P = m_snooker->m_bTurn1P;
	ballsData.m_bestScore = m_snooker->m_bestScore;
	ballsData.m_gameOver = m_snooker->m_gameOver;
	ballsData.m_bConcededGame = m_snooker->m_bConcededGame;

	if(m_snooker->m_bTurn1P != g_bLastTurn) ballsData.m_bTurnChanged = TRUE;
		else ballsData.m_bTurnChanged = FALSE;

	g_bLastTurn = m_snooker->m_bTurn1P;


	/*
	// DBBUG //
	char buf[256];
	sprintf(buf, "[S] m_bMiss:%d, m_redNext:%d, m_colorseq:%d, m_bTurn1P:%d", m_snooker->m_bMiss, m_snooker->m_rednext, m_snooker->m_colourseq, m_snooker->m_bTurn1P);
	Message(buf, 20);
	*/


	// Encode data again after we've finished sending it //
	m_snooker->m_customTable->Encode();

	ballsData.m_foul = m_snooker->m_foul;
	ballsData.m_bMiss = m_snooker->m_bMiss;
	ballsData.m_rednext = m_snooker->m_rednext;
	ballsData.m_colourseq = m_snooker->m_colourseq;
	ballsData.m_bBallInHand = m_snooker->m_bBallInHand;
	ballsData.m_nominateBall = m_snooker->m_nominateBall;

	ballsData.m_dominoHitLast = m_snooker->m_dominoHitLast;
	ballsData.m_dominoHit1st = m_snooker->m_dominoHit1st;

	ballsData.m_testBallColour = m_snooker->m_testBall->m_colour;

	ballsData.m_bSimEnd = bSimEnd;

	ballsData.m_bForceReceive = bForceReceive;

	
	ballsData.m_reRackRndVal = m_snooker->m_reRackRndVal;
	ballsData.m_foul3Times1P = m_snooker->m_foul3Times1P;
	ballsData.m_foul3Times2P = m_snooker->m_foul3Times2P;

	for(int t=0; t<MAX_TOUCHING_BALLS; t++)
		ballsData.m_touchBall[t] = m_snooker->m_touchingBall[t];

	// 29/3/2004(*was below before)
	ballsData.m_shotTime = m_snooker->m_shotTime;

	ballsData.m_poolPots1P = m_snooker->m_poolPots1P;
	ballsData.m_poolPots2P = m_snooker->m_poolPots2P;

	ballsData.m_nSimEndMsgBalls = 0;

	
	if(bSimEnd)
	{
		// *NEW - tell server this sendballs msg is associated with strike no. idx n
		int tbl = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tbl!=-1)
			ballsData.m_nSimEndMsgBalls =  m_table[tbl].nSimEndMsgBalls;			
	}

	if(mainShell)
	{
		mainShell->Client->SendToQueue((void *)&ballsData, sizeof(BallsSendData_typ));
	}



	#endif //!MAIN_SERVER
}


void CGameAppView::SendBallsReceive(BallsSendData *sd)
{
	#ifndef MAIN_SERVER
	// ErrorMessage(g_wnd, "SendBallsReceive");

	// If we have reset buffer data, then reset and don't need to do sendballs receive
	if (g_ResetbufferBk[0])
	{
		// ErrorMessage(g_wnd, "[Reset]");
		char playerTurn = g_ResetbufferBk[3];
		int *rndval = (int *)&g_ResetbufferBk[4];
		m_snooker->Init(m_snooker->m_reRackType, *rndval, playerTurn);
		memset(&g_ResetbufferBk, 0, sizeof(char)* 16);
		return;
	}

	
	// check if i am still in sim. mode (i.e. lagging host)
	if(sd->m_bSimEnd) // *new - line to fix the join-shot in progress bug!
	if(m_snooker->m_cueBallSelect == 2 || m_snooker->m_cueBallSelect >= 20)
	{
		// save BallsSendData for later use. while we carry on with our sim.
		memcpy(&g_ballsSendDataBk, sd, sizeof(BallsSendData_typ));
		// ErrorMessage(g_wnd, "memcpy ballsDat");
		return;		
	}


	
	


	// [normal] receive data...
	//ErrorMessage(g_wnd, "[normal ballsData 1:2]");
	// if player did not see the selection lines then do the following... i.e for late arrivals
	if( (!m_snooker->m_bSeenSelectBall) ||
		(m_snooker->m_cueBallSelect == 4) || // or if they r in state 4
		(sd->m_bForceReceive == TRUE) ) // or if bForceReceive is true
	{
		if(m_snooker->m_cueBallSelect == 4)
			m_snooker->m_cueBallSelect = 3; /// *********************^^^^^^^^^^^^^^^^^^^^^^^^ do this in sendballs receive		

		//ErrorMessage(g_wnd, "[normal ballsData 2:2]");

		// *NEW!
		m_snooker->m_reRackRndVal = sd->m_reRackRndVal;
		m_snooker->m_foul3Times1P = sd->m_foul3Times1P;
		m_snooker->m_foul3Times2P = sd->m_foul3Times2P;

		//////////
		// backup all ball Pundo's [1:2]
		CVector PUndoTmp[MAX_TOTALBALLS];
		FVector fPUndoTmp[MAX_TOTALBALLS];
		for(int p=0;p<MAX_TOTALBALLS;p++)
		{
			PUndoTmp[p] = m_snooker->m_ball[p]->m_PUndo;
			fPUndoTmp[p] = m_snooker->m_ball[p]->f_PUndo;
		}
		//////////


		m_lobby->TableClearReRackRequest(m_playerSockIdx);


		for(int t=0; t<MAX_TOUCHING_BALLS; t++)
			m_snooker->m_touchingBall[t] = sd->m_touchBall[t];

		///
		if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			if(m_snooker->m_customTable->m_type == CTTYPE_RESPOTBLACK)
				{
				m_snooker->m_reRackType = RERACK_BLACK;
				}
			else if(m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
				{
				m_snooker->m_reRackType = RERACK_BILLIARDS;
				}
			else
				{
				// SNOOKER, SNOOKER10, SNOOKER6
				m_snooker->m_reRackType = RERACK_START;
				}
			
			m_snooker->ClearBalls();
			//m_snooker->ReRack(0,0,1);
			m_snooker->ReRack(0,m_snooker->m_reRackRndVal,1); //*NEW!
		}
		if(g_build.gameType == GAMETYPE_POOL)
		{
			// change game type
			if(m_snooker->m_customTable->m_type == CTTYPE_8BALL)
				m_snooker->m_reRackType = RERACK_8BALL;
			else if(m_snooker->m_customTable->m_type == CTTYPE_9BALL)
				m_snooker->m_reRackType = RERACK_9BALL;
			else if(m_snooker->m_customTable->m_type == CTTYPE_ROTATIONBALL)
				m_snooker->m_reRackType = RERACK_ROTATIONBALL;
			else if(m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
				m_snooker->m_reRackType = RERACK_BOWLS;
			else if(m_snooker->m_customTable->m_type == CTTYPE_6BALL)
				m_snooker->m_reRackType = RERACK_6BALL;
			else if(m_snooker->m_customTable->m_type == CTTYPE_10BALL)
				m_snooker->m_reRackType = RERACK_10BALL;
			else if(m_snooker->m_customTable->m_type == CTTYPE_UKPOOL)
				m_snooker->m_reRackType = RERACK_UKPOOL;
			else if(m_snooker->m_customTable->m_type == CTTYPE_BREAK)
				m_snooker->m_reRackType = RERACK_BREAK;

			m_snooker->ClearBalls();
			//m_snooker->ReRack(0,0,1);
			m_snooker->ReRack(0,m_snooker->m_reRackRndVal,1);
		}

		///

		//////////
		// restore all ball Pundo's [2:2]
		for(int p=0;p<MAX_TOTALBALLS;p++)
		{
			m_snooker->m_ball[p]->m_PUndo = PUndoTmp[p];
			m_snooker->m_ball[p]->f_PUndo = fPUndoTmp[p];
		}
		//////////


		// get new values for ball pos's
		int m;
		for(m=0;m<MAX_TOTALBALLS;m++)
		{
			
			/////////////////////////////////////////////////////////////
			// clear all 'POTTED' balls
			ClearFlag(m_snooker->m_ball[m]->m_flags, Flg_BALL_POTTED);
			/////////////////////////////////////////////////////////////

			// check if these balls are active, i.e. still on the table
			if(sd->m_ballx[m] >= 9999 && sd->m_bally[m] >= 9999)
			{
				//char buf[80];
				//sprintf(buf, "1: m = %d", m);
				//ErrorMessage(m_pParentWnd, buf);
				#ifdef THE_POOL_CLUB

				
				// this ball is out of play
				if(sd->m_ballx[m] >= 19999 && sd->m_bally[m] >= 19999)
				if(m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
				{								
					SetFlag(m_snooker->m_ball[m]->m_flags, Flg_BALL_POTTED);
					//ErrorMessage(m_pParentWnd, "YO!");
				}
				

				m_snooker->m_ball[m]->m_P.x = sd->m_ballx[m];
				m_snooker->m_ball[m]->m_P.y = sd->m_bally[m];
				
				// not active
				ClearFlag(m_snooker->m_ball[m]->m_flags, Flg_BALL_ACTIVE);

				
				//}
				#else
				
				// not active
				ClearFlag(m_snooker->m_ball[m]->m_flags, Flg_BALL_ACTIVE);

				// check for colourseq >= 2 (YELLOW THRU TO BLACK)
				if(m_snooker->m_customTable->m_type != CTTYPE_BILLIARDS)
				if(sd->m_colourseq >= 2)
					if(m_snooker->m_ball[m]->m_colour >= 2)
						if(m_snooker->m_ball[m]->m_colour <= sd->m_colourseq)
						{	
							m_snooker->m_ball[m]->m_colour = 100;
						}
				#endif //THE_POOL_CLUB
			}
			else {												
				//char buf[80];
				//sprintf(buf, "2: m = %d", m);
				//ErrorMessage(m_pParentWnd, buf);
				
				if(m_snooker->m_ball[m]->m_colour == 100) // *NEW - 28/OCT/04 - balls turn black and worth 100pts BUGFIX!
				{
					m_snooker->m_ball[m]->m_colour = 1;
				}

				// active
				SetFlag(m_snooker->m_ball[m]->m_flags, Flg_BALL_ACTIVE);
				
				m_snooker->m_ball[m]->m_P.x = sd->m_ballx[m];
				m_snooker->m_ball[m]->m_P.y = sd->m_bally[m];
				
				// *NEW - de-rem the following code (was remmed out)
				// also update old position aswell, to stop balls rotating everytime at end of a shot
				m_snooker->m_ball[m]->m_POld.x = sd->m_ballx[m];
				m_snooker->m_ball[m]->m_POld.y = sd->m_bally[m];
			}

			// removes any balls still in pockets
			//if(m_snooker->m_ball[m]->CushionsProximity())
			//	m_snooker->m_ball[m]->CollideWithPockects(FALSE);
			#ifdef FIXEDMODE
			m_snooker->m_ball[m]->UpdateFixeds();
			#endif
		} // end for

		#ifdef THE_POOL_CLUB
		if(m_snooker->m_customTable->m_type == CTTYPE_8BALL)
			m_snooker->m_customTable->Referee8BallUpdatePots();
		else if(m_snooker->m_customTable->m_type == CTTYPE_9BALL)
			m_snooker->m_customTable->Referee9BallUpdatePots();
		else if(m_snooker->m_customTable->m_type == CTTYPE_ROTATIONBALL)
			m_snooker->m_customTable->RefereeRotationBallUpdatePots();
		else if(m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
			m_snooker->m_customTable->RefereeBowlsUpdatePots();
		else if(m_snooker->m_customTable->m_type == CTTYPE_6BALL)
			m_snooker->m_customTable->Referee6BallUpdatePots();
		else if(m_snooker->m_customTable->m_type == CTTYPE_10BALL)
			m_snooker->m_customTable->Referee10BallUpdatePots();
		else if(m_snooker->m_customTable->m_type == CTTYPE_UKPOOL)
			m_snooker->m_customTable->RefereeUKPoolUpdatePots();
		else if(m_snooker->m_customTable->m_type == CTTYPE_BREAK)
			m_snooker->m_customTable->RefereeBreakUpdatePots();
		#endif // THE_POOL_CLUB

		// Data is always received in Decoded state //
		g_gameAppView->m_snooker->m_customTable->Decode();

		m_snooker->m_score1P = sd->m_score1P;
		m_snooker->m_score2P = sd->m_score2P;
		m_snooker->m_break1P = sd->m_break1P;
		m_snooker->m_break2P = sd->m_break2P;					
		
		m_snooker->m_bestScore = sd->m_bestScore;
		m_snooker->m_gameOver = sd->m_gameOver;
		m_snooker->m_bConcededGame = sd->m_bConcededGame;
		m_snooker->m_bTurn1P = sd->m_bTurn1P;

		

				
		m_snooker->m_foul = sd->m_foul;
		//m_snooker->m_lifes = sd->m_lifes;

		m_snooker->m_bMiss = sd->m_bMiss;
		m_snooker->m_rednext = sd->m_rednext;
		m_snooker->m_colourseq = sd->m_colourseq;
		m_snooker->m_bBallInHand = sd->m_bBallInHand;
		m_snooker->m_nominateBall = sd->m_nominateBall;

		/*
		// DBBUG //
		char buf[256];
		sprintf(buf, "[R] sd->m_nSimEndMsgBalls:%d, m_bMiss:%d, m_redNext:%d, m_colorseq:%d, m_bTurn1P:%d", sd->m_nSimEndMsgBalls, m_snooker->m_bMiss, m_snooker->m_rednext, m_snooker->m_colourseq, m_snooker->m_bTurn1P);
		Message(buf, 40);
		*/

		m_snooker->m_dominoHitLast = sd->m_dominoHitLast;
		m_snooker->m_dominoHit1st = sd->m_dominoHit1st;


		m_snooker->m_testBall->m_colour = sd->m_testBallColour;
		

		// (*put back in on 29/3/2004)
		m_snooker->m_shotTime = sd->m_shotTime;

		m_snooker->m_poolPots1P = sd->m_poolPots1P;
		m_snooker->m_poolPots2P = sd->m_poolPots2P;

		// if white was potted, and is now in 'D', allow ball-in-hand
		if(TestFlag(m_snooker->m_foul, Flg_FOUL_WHITEPOTTED))
		{
			m_snooker->m_bBallInHand = 1;
			m_snooker->m_bStandUpFromShot = 1;
		}

		// now refresh scores
		m_snooker->m_bRefreshScores = TRUE;					
		
		memset(&g_ballsSendDataBk, 0, sizeof(BallsSendData_typ));

	}


	

	#endif //!MAIN_SERVER
}


void CGameAppView::SendStartPressed(int plrSockIdx)
{
	#ifndef MAIN_SERVER
	
	//uni_timer = 0;

	StartPressedSendData StartPressedData;
	
	StartPressedData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	StartPressedData.buffer[1] = 60;	   // MSGGAME_STARTPRESSED
	StartPressedData.buffer[2] = 0;
	StartPressedData.buffer[3] = 0;
	
	StartPressedData.m_plrSockIdx = plrSockIdx;	
	StartPressedData.m_rndval = rand();

	int plrIdx = m_lobby->GetPlayerIdx(plrSockIdx);
	
	if(mainShell)
		mainShell->Client->SendToQueue((void *)&StartPressedData, sizeof(StartPressedSendData_typ));

	#endif //!MAIN_SERVER
}


void CGameAppView::SendGameOverForAll(int tblIdx, int gameOver, BOOL bForceRacksEnd, BOOL bMatchTimeUp)
{
	//#ifndef MAIN_SERVER
	GameOverForAllSendData GameOverForAllData;

	GameOverForAllData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	GameOverForAllData.buffer[1] = 74;   // MSGGAME_GAMEOVERFORALL
	GameOverForAllData.buffer[2] = 0;
	GameOverForAllData.buffer[3] = 0;
	
	GameOverForAllData.m_tblIdx = tblIdx;
	GameOverForAllData.m_gameOver = gameOver;
	GameOverForAllData.m_bForceRacksEnd = bForceRacksEnd;
	GameOverForAllData.m_bMatchTimeUp = bMatchTimeUp;

	//if(gameShell)
	//	gameShell->Client->SendToQueue((void *)&StartPressedData, sizeof(StartPressedSendData_typ));

	if(mainShell)
		mainShell->Client->SendToQueue((void *)&GameOverForAllData, sizeof(GameOverForAllSendData_typ));

	//#endif //!MAIN_SERVER
}


void CGameAppView::SendGameOver(Player *pPlr1, Player *pPlr2, BOOL bPlr1Won, BOOL bRated, BOOL bInvalidGame, int tblIdx, int oldRating1P, int oldRating2P, BOOL bRacksStillToPlay, int EOGmsg)
{
	#ifndef MAIN_SERVER
	

	GameOverSendData GameOverData;
	
	GameOverData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	GameOverData.buffer[1] = 61;   // MSGGAME_GAMEOVER
	GameOverData.buffer[2] = 0;
	GameOverData.buffer[3] = 0;
	
	strcpy(GameOverData.m_nameP1, pPlr1->name);
	strcpy(GameOverData.m_nameP2, pPlr2->name);

	GameOverData.m_ratingP1		= pPlr1->rating;
	GameOverData.m_winsP1		= pPlr1->wins;
	GameOverData.m_lossesP1		= pPlr1->losses;
	GameOverData.m_streakP1		= pPlr1->streak;
	GameOverData.m_p50sP1		= pPlr1->_p50s;
	GameOverData.m_p60sP1		= pPlr1->_p60s;
	GameOverData.m_p70sP1		= pPlr1->_p70s;
	GameOverData.m_p80sP1		= pPlr1->_p80s;
	GameOverData.m_p90sP1		= pPlr1->_p90s;
	GameOverData.m_p100sP1		= pPlr1->_p100s;
	GameOverData.m_pHighBreakP1	= pPlr1->pHighBreak;
	GameOverData.m_pMax147sP1	= pPlr1->pMax147s;
	GameOverData.m_50sP1		= pPlr1->_50s;
	GameOverData.m_60sP1		= pPlr1->_60s;
	GameOverData.m_70sP1		= pPlr1->_70s;
	GameOverData.m_80sP1		= pPlr1->_80s;
	GameOverData.m_90sP1		= pPlr1->_90s;
	GameOverData.m_100sP1		= pPlr1->_100s;
	GameOverData.m_HighBreakP1	= pPlr1->HighBreak;
	GameOverData.m_Max147sP1	= pPlr1->Max147s;
	GameOverData.m_pBioAverageShotTimeP1 = pPlr1->pBioAverageShotTime;
	GameOverData.m_pBioAveragePositionP1 = pPlr1->pBioAveragePosition;
	GameOverData.m_pBioAverageSafetyP1 = pPlr1->pBioAverageSafety;
	GameOverData.m_pBioAverageBreakP1 = pPlr1->pBioAverageBreak;
	GameOverData.m_bioAverageShotTimeP1 = pPlr1->bioAverageShotTime;
	GameOverData.m_bioAveragePositionP1 = pPlr1->bioAveragePosition;
	GameOverData.m_bioAverageSafetyP1 = pPlr1->bioAverageSafety;
	GameOverData.m_bioAverageBreakP1 = pPlr1->bioAverageBreak;
	GameOverData.m_highestratingP1 = pPlr1->highestrating;
	GameOverData.m_cashP1 = pPlr1->cash;
	GameOverData.m_reracksP1 = pPlr1->reracks;
	GameOverData.m_ladderPointsP1 = pPlr1->ladderPoints;
	GameOverData.m_ladderWinsLossesP1 = pPlr1->ladderWinsLosses;
	GameOverData.m_ladderHighBreakP1 = pPlr1->ladderHighBreak;


	GameOverData.m_ratingP2		= pPlr2->rating;
	GameOverData.m_winsP2		= pPlr2->wins;
	GameOverData.m_lossesP2		= pPlr2->losses;
	GameOverData.m_streakP2		= pPlr2->streak;
	GameOverData.m_p50sP2		= pPlr2->_p50s;
	GameOverData.m_p60sP2		= pPlr2->_p60s;
	GameOverData.m_p70sP2		= pPlr2->_p70s;
	GameOverData.m_p80sP2		= pPlr2->_p80s;
	GameOverData.m_p90sP2		= pPlr2->_p90s;
	GameOverData.m_p100sP2		= pPlr2->_p100s;
	GameOverData.m_pHighBreakP2	= pPlr2->pHighBreak;
	GameOverData.m_pMax147sP2	= pPlr2->pMax147s;
	GameOverData.m_50sP2		= pPlr2->_50s;
	GameOverData.m_60sP2		= pPlr2->_60s;
	GameOverData.m_70sP2		= pPlr2->_70s;
	GameOverData.m_80sP2		= pPlr2->_80s;
	GameOverData.m_90sP2		= pPlr2->_90s;
	GameOverData.m_100sP2		= pPlr2->_100s;
	GameOverData.m_HighBreakP2	= pPlr2->HighBreak;
	GameOverData.m_Max147sP2	= pPlr2->Max147s;
	GameOverData.m_pBioAverageShotTimeP2 = pPlr2->pBioAverageShotTime;
	GameOverData.m_pBioAveragePositionP2 = pPlr2->pBioAveragePosition;
	GameOverData.m_pBioAverageSafetyP2 = pPlr2->pBioAverageSafety;
	GameOverData.m_pBioAverageBreakP2 = pPlr2->pBioAverageBreak;
	GameOverData.m_bioAverageShotTimeP2 = pPlr2->bioAverageShotTime;
	GameOverData.m_bioAveragePositionP2 = pPlr2->bioAveragePosition;
	GameOverData.m_bioAverageSafetyP2 = pPlr2->bioAverageSafety;
	GameOverData.m_bioAverageBreakP2 = pPlr2->bioAverageBreak;
	GameOverData.m_highestratingP2 = pPlr2->highestrating;
	GameOverData.m_cashP2 = pPlr2->cash;
	GameOverData.m_reracksP2 = pPlr2->reracks;
	GameOverData.m_ladderPointsP2 = pPlr2->ladderPoints;
	GameOverData.m_ladderWinsLossesP2 = pPlr2->ladderWinsLosses;
	GameOverData.m_ladderHighBreakP2 = pPlr2->ladderHighBreak;


	GameOverData.m_bPlr1Won = bPlr1Won;
	GameOverData.m_bRated = bRated;
	GameOverData.m_bInvalidGame = bInvalidGame;
	GameOverData.m_tblIdx = tblIdx;

	GameOverData.m_oldRating1P = oldRating1P;
	GameOverData.m_oldRating2P = oldRating2P;

	GameOverData.m_bRacksStillToPlay = bRacksStillToPlay;

	GameOverData.m_EOGmsg = EOGmsg;


	/*
	GameOverData.m_plrSockIdx = plrSockIdx;
	GameOverData.m_gameOver = gameOver;
	GameOverData.m_highBreaks1P0 = highBreaks1P0;
	GameOverData.m_highBreaks1P1 = highBreaks1P1;
	GameOverData.m_highBreaks2P0 = highBreaks2P0;
	GameOverData.m_highBreaks2P1 = highBreaks2P1;
	GameOverData.m_bInvalidGame = bInvalidGame;
	*/
	
	//if(gameShell)
	//	gameShell->Client->SendToQueue((void *)&StartPressedData, sizeof(StartPressedSendData_typ));

	if(mainShell)
		mainShell->Client->SendToQueue((void *)&GameOverData, sizeof(GameOverSendData_typ));

	#endif //!MAIN_SERVER
}

void CGameAppView::SendPlayerBioData(int cueError)
{
	#ifndef MAIN_SERVER

	PlayerBioSendData PlayerBioData;
	
	PlayerBioData.buffer[0] = 0x7f;  // MSGCODE_GAME Game message.
	PlayerBioData.buffer[1] = 98;	 // MSGGAME_UPDATEPLAYERBIO
	PlayerBioData.buffer[2] = 0;
	PlayerBioData.buffer[3] = 0;
	
	PlayerBioData.m_cueError = cueError;
	PlayerBioData.m_bioAverageShotTime = g_bioAverageShotTime;
	PlayerBioData.m_bioAveragePosition = g_bioAveragePosition;
	PlayerBioData.m_bioAverageSafety = g_bioAverageSafety;
	if(cueError == 1) PlayerBioData.m_bioAverageBreak = g_sbioAverageBreak;
	else if(cueError == 2) PlayerBioData.m_bioAverageBreak = g_pbioAverageBreak;
	else PlayerBioData.m_bioAverageBreak = -1;

	if(mainShell)
	{
		mainShell->Client->SendToQueue((void *)&PlayerBioData, sizeof(PlayerBioSendData_typ));
	}

	#endif //!MAIN_SERVER
}

void CGameAppView::SendRequestPlayerBio(int plrIdx)
{
	int sockIdx;
	if(!m_player[plrIdx].status) return; // status doesn't exist.
	sockIdx = m_player[plrIdx].playerSocketIdx;

	RequestPlayerBioSendData RequestPlayerBioData;
	
	RequestPlayerBioData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	RequestPlayerBioData.buffer[1] = 99;   // MSGGAME_REQUESTPLAYERBIO
	RequestPlayerBioData.buffer[2] = 0;
	RequestPlayerBioData.buffer[3] = 0;
	
	RequestPlayerBioData.m_plrSockIdx = sockIdx;
	RequestPlayerBioData.m_returnPlrSockIdx = -1;

	//ErrorMessage(g_wnd, "SendRequest");

	if(mainShell)
	{
		mainShell->Client->SendToQueue((void *)&RequestPlayerBioData, sizeof(RequestPlayerBioSendData_typ));
	}
}

void CGameAppView::ReceiveRequestPlayerBio(int returnPlrSockIdx)
{
	#ifndef MAIN_SERVER

	//ErrorMessage(g_wnd, "ReceiveRequest");

	SendReturnPlayerBio(returnPlrSockIdx);

	#endif //!MAIN_SERVER
}

void CGameAppView::SendReturnPlayerBio(int returnPlrSockIdx)
{
	ReturnPlayerBioSendData ReturnPlayerBioData;
	
	ReturnPlayerBioData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	ReturnPlayerBioData.buffer[1] = 100;  // MSGGAME_RETURNPLAYERBIO
	ReturnPlayerBioData.buffer[2] = 0;
	ReturnPlayerBioData.buffer[3] = 0;
	
	ReturnPlayerBioData.m_returnPlrSockIdx = returnPlrSockIdx;

	m_detailsDlg.UpdateData(TRUE);


	strcpy(ReturnPlayerBioData.m_comments, m_detailsDlg.m_comments.GetBuffer(0));//, sizeof(char)*128);	
	ReturnPlayerBioData.m_comments[128] = 0;


	strcpy(ReturnPlayerBioData.m_town, m_detailsDlg.m_town.GetBuffer(0));//, sizeof(char)*28);	
	ReturnPlayerBioData.m_town[28] = 0;
	

	strcpy(ReturnPlayerBioData.m_age, m_detailsDlg.m_age.GetBuffer(0));//, sizeof(char)*3);
	ReturnPlayerBioData.m_age[3] = 0;

	strcpy(ReturnPlayerBioData.m_name, m_detailsDlg.m_realName.GetBuffer(0));//, sizeof(char)*28);
	ReturnPlayerBioData.m_name[28] = 0;
	
	strcpy(ReturnPlayerBioData.m_sex, m_detailsDlg.m_sex.GetBuffer(0));//, sizeof(char)*1);
	ReturnPlayerBioData.m_sex[1] = 0;

	
	//ErrorMessage(g_wnd, "SendReturn");

	if(mainShell)
	{
		mainShell->Client->SendToQueue((void *)&ReturnPlayerBioData, sizeof(ReturnPlayerBioSendData_typ));
	}
}



void CGameAppView::ReceiveReturnPlayerBio(ReturnPlayerBioSendData *sd)
{
	//BP_FIX4
	//m_statsTabCtrlDlg.DestroyWindow();
	//m_statsTabCtrlDlg.Create(IDD_STATSTABCTRL);
	if(!m_personalDetailsDlg.m_hWnd) return;
	if(!m_personalDetailsDlg.IsWindowEnabled()) return;
		

	//ErrorMessage(g_wnd, "ReceiveReturn");
	m_personalDetailsDlg.m_comments.Format("%s", sd->m_comments);	
	m_personalDetailsDlg.m_town.Format("%s", sd->m_town);
	m_personalDetailsDlg.m_age.Format("%s", sd->m_age);
	m_personalDetailsDlg.m_name.Format("%s", sd->m_name);
	m_personalDetailsDlg.m_sex.Format("%s", sd->m_sex);
	if(m_personalDetailsDlg.IsWindowEnabled()) m_personalDetailsDlg.UpdateData(FALSE);
	
}

void CGameAppView::ReceivePlayerBioData(int plrIdx, int cueError, float bioAverageShotTime, float bioAveragePosition, float bioAverageSafety, float bioAverageBreak)
{
	#ifdef MAIN_SERVER

	if(cueError == 0) return; // ignore beginner

//	char buff[128];
//	sprintf(buff, "bioAverageShotTime=%f, bioAveragePosition=%f, bioAverageSafety=%f", bioAverageShotTime, bioAveragePosition, bioAverageSafety);
//	ErrorMessage(this, buff);

	Player plr;
	m_lobby->ClearPlayer(&plr);

	if(plrIdx==-1) return;
	if(m_player[plrIdx].bIsGuest) return;

	strcpy(plr.name, m_player[plrIdx].name);
	
	// load player data
	if(!LoadPlayerProfile(&plr, ".txt")) return;

	// update player data
	if(cueError == 1) // semi-pro
	{
		//ErrorMessage(this, "Here!!!!!!!!!!!");

		if(plr.bioAverageShotTime<1) plr.bioAverageShotTime = 15*0.9f + bioAverageShotTime*0.1f;
		else plr.bioAverageShotTime = plr.bioAverageShotTime*0.9f + bioAverageShotTime*0.1f;
		if(plr.bioAverageShotTime<1) plr.bioAverageShotTime = 1;
		if(plr.bioAverageShotTime>120) plr.bioAverageShotTime = 120;

		if(plr.bioAveragePosition<1) plr.bioAveragePosition =50*0.9f + bioAveragePosition*0.1f;
		else plr.bioAveragePosition = plr.bioAveragePosition*0.9f + bioAveragePosition*0.1f;
		if(plr.bioAveragePosition<1) plr.bioAveragePosition = 1;
		if(plr.bioAveragePosition>100) plr.bioAveragePosition = 100;
		
		if(plr.bioAverageSafety<1) plr.bioAverageSafety = 50*0.9f + bioAverageSafety*0.1f;
		else plr.bioAverageSafety = plr.bioAverageSafety*0.9f + bioAverageSafety*0.1f;
		if(plr.bioAverageSafety<1) plr.bioAverageSafety = 1;
		if(plr.bioAverageSafety>100) plr.bioAverageSafety = 100;

		if(bioAverageBreak != -1) // if this is not a WILD game type
		{
			#ifndef THE_POOL_CLUB
			if(plr.bioAverageBreak<1) plr.bioAverageBreak = 25*0.9f + bioAverageBreak*0.1f;
			else plr.bioAverageBreak = plr.bioAverageBreak*0.9f + bioAverageBreak*0.1f;
			if(plr.bioAverageBreak<1) plr.bioAverageBreak = 1;
			if(plr.bioAverageBreak>155) plr.bioAverageBreak = 155;
			#else
			if(plr.bioAverageBreak<1) plr.bioAverageBreak = 3*0.9f + bioAverageBreak*0.1f;
			else plr.bioAverageBreak = plr.bioAverageBreak*0.9f + bioAverageBreak*0.1f;
			if(plr.bioAverageBreak<1) plr.bioAverageBreak = 1;
			if(plr.bioAverageBreak>15) plr.bioAverageBreak = 15;
			#endif
		}

		m_player[plrIdx].bioAverageShotTime = plr.bioAverageShotTime;
		m_player[plrIdx].bioAveragePosition = plr.bioAveragePosition;
		m_player[plrIdx].bioAverageSafety = plr.bioAverageSafety;
		m_player[plrIdx].bioAverageBreak = plr.bioAverageBreak;
	}
	else if(cueError == 2) // pro
	{
		if(plr.pBioAverageShotTime<1) plr.pBioAverageShotTime = 15*0.9f + bioAverageShotTime*0.1f;
		else plr.pBioAverageShotTime = plr.pBioAverageShotTime*0.9f + bioAverageShotTime*0.1f;
		if(plr.pBioAverageShotTime<1) plr.pBioAverageShotTime = 1;
		if(plr.pBioAverageShotTime>120) plr.pBioAverageShotTime = 120;

		if(plr.pBioAveragePosition<1) plr.pBioAveragePosition = 50*0.9f + bioAveragePosition*0.1f;
		else plr.pBioAveragePosition = plr.pBioAveragePosition*0.9f + bioAveragePosition*0.1f;
		if(plr.pBioAveragePosition<1) plr.pBioAveragePosition = 1;
		if(plr.pBioAveragePosition>100) plr.pBioAveragePosition = 100;
		
		if(plr.pBioAverageSafety<1) plr.pBioAverageSafety = 50*0.9f + bioAverageSafety*0.1f;
		else plr.pBioAverageSafety = plr.pBioAverageSafety*0.9f + bioAverageSafety*0.1f;
		if(plr.pBioAverageSafety<1) plr.pBioAverageSafety = 1;
		if(plr.pBioAverageSafety>100) plr.pBioAverageSafety = 100;

		if(bioAverageBreak != -1) // if this is not a WILD game type
		{
			#ifndef THE_POOL_CLUB
			if(plr.pBioAverageBreak<1) plr.pBioAverageBreak = 25*0.9f + bioAverageBreak*0.1f;
			else plr.pBioAverageBreak = plr.pBioAverageBreak*0.9f + bioAverageBreak*0.1f;
			if(plr.pBioAverageBreak<1) plr.pBioAverageBreak = 1;
			if(plr.pBioAverageBreak>155) plr.pBioAverageBreak = 155;
			#else
			if(plr.pBioAverageBreak<1) plr.pBioAverageBreak = 3*0.9f + bioAverageBreak*0.1f;
			else plr.pBioAverageBreak = plr.pBioAverageBreak*0.9f + bioAverageBreak*0.1f;
			if(plr.pBioAverageBreak<1) plr.pBioAverageBreak = 1;
			if(plr.pBioAverageBreak>9) plr.pBioAverageBreak = 9;
			#endif
		}

		m_player[plrIdx].pBioAverageShotTime = plr.pBioAverageShotTime;
		m_player[plrIdx].pBioAveragePosition = plr.pBioAveragePosition;
		m_player[plrIdx].pBioAverageSafety = plr.pBioAverageSafety;
		m_player[plrIdx].pBioAverageBreak = plr.pBioAverageBreak;
	}

//	char buff2[128];
//	sprintf(buff2, "-->> plr.bioAverageShotTime=%f, plr.bioAveragePosition=%f, plr.bioAverageSafety=%f", plr.bioAverageShotTime, plr.bioAveragePosition, plr.bioAverageSafety);
//	ErrorMessage(this, buff2);

	// save player data
	//SavePlayerProfile(&plr, ".bak");
	SavePlayerProfile(&plr, ".txt");
	//DeletePlayerProfile(&plr, ".bak");
	
	#endif //MAIN_SERVER
}


bool CGameAppView::IsLadderMatch(int tableIdx)
{
	if (tableIdx != -1)
	{
		return m_table[tableIdx].bLadderMatch;
	}
	return false;
}

bool CGameAppView::InLadderMatch()
{
	int myTableIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	if (myTableIdx != -1)
	{
		return m_table[myTableIdx].bLadderMatch;
	}
	return false;
}


int CGameAppView::MyTableIdx()
{
	int myTableIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	return myTableIdx;
}

void CGameAppView::SendConcedePressed(BOOL bIsHost, int plrSockIdx, BOOL bAndExit, BOOL bAndClose, int tableIdx)
{
	// If no table index was specificed, then check if we can find ours 
	if(tableIdx == -1)
	{
		// check i'm on the same table before restarting table
		int myTableIdx = g_gameAppView->m_lobby->GetTableIdxFromPlayer(g_gameAppView->m_playerSockIdx);
		if(myTableIdx != -1)
		{
			tableIdx = myTableIdx;
		}
		else
		{
			// If we still couldn't find a tableIdx then don't do this function
			return;
		}
	}


	//#ifndef MAIN_SERVER
	//if(m_snooker->m_cueBallSelect == 0)
	if(m_lobby->GameStarted(plrSockIdx))
	//if(m_lobby->SeatedAtTable(m_playerSockIdx))
	//if(m_lobby->BothSeatsTaken(m_playerSockIdx))
	//if(m_snooker->MyTurn())
	//if(gameShell)
	{		

		ConcedePressedSendData ConcedePressedData;
	
		ConcedePressedData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
		ConcedePressedData.buffer[1] = 62;	 // MSGGAME_CONCEDEPRESSED
		ConcedePressedData.buffer[2] = 0;
		ConcedePressedData.buffer[3] = 0;
	

		ConcedePressedData.m_plrSockIdx = plrSockIdx;
		ConcedePressedData.m_bAndExit = bAndExit;
		ConcedePressedData.m_bAndClose = bAndClose;
		ConcedePressedData.m_tableIdx = tableIdx;

		int plrIdx = m_lobby->GetPlayerIdx(plrSockIdx);
	

		if(mainShell) // MAYBE WE SHOULD USE 'gameShell' HERE
		{
			if(bIsHost)
				mainShell->Server->SendToQueue((void *)&ConcedePressedData, sizeof(ConcedePressedSendData_typ));
			else
				mainShell->Client->SendToQueue((void *)&ConcedePressedData, sizeof(ConcedePressedSendData_typ));
		}
	}	
/*

	// Safety Check, since (uni_timer/60) should never be less than g_concede_time
	if((uni_timer/60)<g_concede_time) uni_timer=g_concede_time+295;

	if((uni_timer/60)>=(g_concede_time+300) || bAndExit || bAndClose)
		{
		// Get the Time Of the Concede Press //
		g_concede_time = uni_timer/60;

		
		if(mainShell) // MAYBE WE SHOULD USE 'gameShell' HERE
			{
			if(bIsHost)
				mainShell->Server->SendToQueue((void *)&ConcedePressedData, sizeof(ConcedePressedSendData_typ));
			else
				mainShell->Client->SendToQueue((void *)&ConcedePressedData, sizeof(ConcedePressedSendData_typ));
			}
		}
	else{
		// Cannot Concede Until x Minutes //
		char _buffer[80];
		sprintf(_buffer,"You cannot concede again until %d seconds",(g_concede_time+300)-(uni_timer/60));
		Message(_buffer,10); // personal message
		}
	}
*/
	//#endif //!MAIN_SERVER
}

void CGameAppView::SendReRackPressed(int plrSockIdx, BOOL bAccepted, int acceptType, BOOL bAbortRaceTo)
{
	#ifndef MAIN_SERVER
	
	if(!bAccepted)
	{
		//if(m_snooker->m_cueBallSelect == 0)
		if(m_lobby->SeatedAtTable(m_playerSockIdx))
		if(m_lobby->BothSeatsTaken(m_playerSockIdx))
		if(m_snooker->MyTurn())
			goto _proceed;
	}
	else
	{
		if(m_lobby->SeatedAtTable(m_playerSockIdx))
			goto _proceed;
	}

	// failed!
	return;
	
_proceed:;


	// Get Table Idx //
	int tblIdx =  m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);

	// must be at a table to proceed with Re-Rack Code//
	if(tblIdx != -1)
	if(!m_table[tblIdx].bCanRerack)
		{
		#ifdef THE_POOL_CLUB
			g_gameAppView->Message("Sorry but you can only rerack once per rack.", 40);
		#else
			g_gameAppView->Message("Sorry but you can only rerack once per frame.", 40);
		#endif
		
		// If we get to this code then we're not allowed to re-rack, so return //
		return;
		}							  

	//if(gameShell)
	{
	ReRackPressedSendData ReRackPressedData;
	
	ReRackPressedData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	ReRackPressedData.buffer[1] = 63;	// MSGGAME_RERACKPRESSED
	ReRackPressedData.buffer[2] = 0;
	ReRackPressedData.buffer[3] = 0;
	
	ReRackPressedData.m_plrSockIdx = plrSockIdx;
	ReRackPressedData.m_bAccepted = bAccepted;
	ReRackPressedData.m_acceptType = acceptType;
	ReRackPressedData.m_bAbortRaceTo = 0;//bAbortRaceTo;
	
	//if(gameShell)
	//	gameShell->Client->SendToQueue((void *)&ReRackPressedData, sizeof(ReRackPressedSendData_typ));

	if(mainShell)
		mainShell->Client->SendToQueue((void *)&ReRackPressedData, sizeof(ReRackPressedSendData_typ));
	}

	#endif //!MAIN_SERVER
}


void CGameAppView::ReRackAcceptDlg(BOOL bAbortRaceTo)
{
	m_rerackAccept2Dlg.m_bAbortRaceTo = 0;//bAbortRaceTo;
	m_rerackAccept2Dlg.DestroyWindow();
	if(!bAbortRaceTo) m_rerackAccept2Dlg.Create(IDD_RERACKACCEPT2DLG);
	else m_rerackAccept2Dlg.Create(IDD_ABORTRACETOACCEPTDLG);
	m_rerackAccept2Dlg.ShowWindow(SW_SHOW);
	//SetFocus();
	PreviousWndEditSetFocus();
}

/*
void CGameAppView::SendConcede(int plrSockIdx)
{
	#ifndef MAIN_SERVER

	ConcedeSendData ConcedeData;
	
	ConcedeData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	ConcedeData.buffer[1] = 2;	  // MSGGAME_SIM_END				
	ConcedeData.buffer[2] = 0;
	ConcedeData.buffer[3] = 0;
	
	SimEndData.m_plrSockIdx = plrSockIdx;
	
	if(gameShell)
		gameShell->Client->SendToQueue((void *)&SimEndData, sizeof(SimEndSendData_typ));

    #endif //!MAIN_SERVER
}
*/


void CGameAppView::SendTextColorChange(int textcolor)
{
	// Check if we're onli
	int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
	if(plrIdx == -1)
	{
		return;
	}

	TextColorSendData TextColorData;
	
	TextColorData.buffer[0] = 0x7f;  // MSGCODE_GAME Game message.
	TextColorData.buffer[1] = 113;	 // MSGGAME_TEXTCOLORCHANGED
	TextColorData.buffer[2] = 0;
	TextColorData.buffer[3] = 0;
	
	TextColorData.textcolor = textcolor;


	if(mainShell)
		mainShell->Client->SendToQueue((void *)&TextColorData, sizeof(TextColorSendData_typ));
}

void CGameAppView::SendClientUpdateVCash(int playerSockIdx, int cash)
{

	UpdateVCashSendData UpdateVCashData;
	
	UpdateVCashData.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	UpdateVCashData.buffer[1] = 114;		// MSGGAME_UPDATEVCASH
	UpdateVCashData.buffer[2] = 0;
	UpdateVCashData.buffer[3] = 0;
	
	UpdateVCashData.playerSockIdx = playerSockIdx;
	UpdateVCashData.cash = cash;

	if(mainShell)
		mainShell->Server->SendToQueue((void *)&UpdateVCashData, sizeof(UpdateVCashSendData_typ));

}

void CGameAppView::SendServerUpdateVCash()
{
	// Check if we're onli
	int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
	if(plrIdx == -1)
	{
		return;
	}
	
	UpdateVCashSendData UpdateVCashData;
	
	UpdateVCashData.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	UpdateVCashData.buffer[1] = 114;		// MSGGAME_UPDATEVCASH
	UpdateVCashData.buffer[2] = 0;
	UpdateVCashData.buffer[3] = 0;
	
	UpdateVCashData.playerSockIdx = m_playerSockIdx;
	UpdateVCashData.cash = 0;

	if(mainShell)
		mainShell->Client->SendToQueue((void *)&UpdateVCashData, sizeof(UpdateVCashSendData_typ));
}



void CGameAppView::SendInvitePressed(int plrSockIdx, int invitedPlrSockIdx, char *name, char *invitedName, BOOL bAccepted, char *str, int initialHostTbl, int table, int enterType)
{
	//#ifndef MAIN_SERVER

	InvitePressedSendData InvitePressedData;
	

	InvitePressedData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	InvitePressedData.buffer[1] = 64;	// MSGGAME_INVITEPRESSED
	InvitePressedData.buffer[2] = 0;
	InvitePressedData.buffer[3] = 0;
	
	InvitePressedData.m_plrSockIdx = plrSockIdx;
	InvitePressedData.m_invitedPlrSockIdx = invitedPlrSockIdx;
	InvitePressedData.m_bAccepted = bAccepted;
	InvitePressedData.m_str[0] = 0;
	if(str)	strcpy(InvitePressedData.m_str, str);

	InvitePressedData.m_initialHostTbl = initialHostTbl;
	InvitePressedData.m_table = table;
	InvitePressedData.m_enterType = enterType;

	InvitePressedData.m_name[0] = 0;
	InvitePressedData.m_invitedName[0] = 0;
	if(name)
		strcpy(InvitePressedData.m_name, name);		
	if(invitedName)
		strcpy(InvitePressedData.m_invitedName, invitedName);
				
	if(mainShell)
		mainShell->Client->SendToQueue((void *)&InvitePressedData, sizeof(InvitePressedSendData_typ));

	//#endif //!MAIN_SERVER
}



void CGameAppView::InvitationDlg(int HostSockIdx, char *hostName, int initialHostTbl, int table, int enterType, int reracks, int totalGames)
{
	int n;
	for(n=0;n<MAX_INVITATIONDLGS;n++)
		if(HostSockIdx == m_invitationDlg[n].m_hostSockIdx) break;
	
	if(n == MAX_INVITATIONDLGS) // this is a new inviter
	{	
		m_invitationDlg[m_invitationN].DestroyWindow();
		m_invitationDlg[m_invitationN].GetInviterHostSockIdx(HostSockIdx, hostName, initialHostTbl, table, enterType, reracks, totalGames);
		if(HostSockIdx != 0) m_invitationDlg[m_invitationN].Create(IDD_INVITATIONDLG); // normal player invite
		else m_invitationDlg[m_invitationN].Create(IDD_INVITATIONTDLG); // special tourney invite
		m_invitationDlg[m_invitationN].ShowWindow(SW_SHOW);
		//SetFocus();
		PreviousWndEditSetFocus();
		
		// move along to next invitation dialog (in the circular queue)
		m_invitationN++;
		if(m_invitationN == MAX_INVITATIONDLGS)
			m_invitationN = 0;
	}
	else // an old inviter, so just update
	{
		
		m_invitationDlg[n].DestroyWindow();
		m_invitationDlg[n].GetInviterHostSockIdx(HostSockIdx, hostName, initialHostTbl, table, enterType, reracks, totalGames);
		if(HostSockIdx != 0) m_invitationDlg[n].Create(IDD_INVITATIONDLG); // normal player invite
		else m_invitationDlg[n].Create(IDD_INVITATIONTDLG); // special tourney invite
		m_invitationDlg[n].ShowWindow(SW_SHOW);
		//SetFocus();
		PreviousWndEditSetFocus();
		
	}
}


void CGameAppView::AlertMessage(char *str, BOOL bDoModal)
{
	m_alertDlg.DestroyWindow();
	m_alertDlg.SetStr(str);

	if(!bDoModal)
	{
		m_alertDlg.Create(IDD_ALERTDLG);
		m_alertDlg.ShowWindow(SW_SHOW);
	}
	else
	{
		m_alertDlg.DoModal();	
	}
}

void CGameAppView::AlertLoginMessage(char *str)
{
	m_alertDlg.DestroyWindow();
	m_alertDlg.SetStr(str);
	m_alertDlg.Create(IDD_ALERTLOGINDLG);
	m_alertDlg.ShowWindow(SW_SHOW);
}

void CGameAppView::OnButtonHelpLoginError()
{
	#ifndef MAIN_SERVER
	m_alertDlg.EndDialog(0);
	m_alertDlg.DestroyWindow();

	if(g_build.gameType == GAMETYPE_SNOOKER)
		ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thesnookerclub.com/faq/errormsg.html"),_T(""),NULL,0);
	else if(g_build.gameType == GAMETYPE_POOL)
		ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thepoolclub.com/errormsg.php"),_T(""),NULL,0);	
	#endif //!MAIN_SERVER
}

void CGameAppView::SendBootPressed(int plrSockIdx, int bootedPlrSockIdx)
{
	#ifndef MAIN_SERVER
	
	BootPressedSendData BootPressedData;
	
	BootPressedData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	BootPressedData.buffer[1] = 65;	  // MSGGAME_BOOTPRESSED
	BootPressedData.buffer[2] = 0;
	BootPressedData.buffer[3] = 0;
	
	BootPressedData.m_plrSockIdx = plrSockIdx;
	BootPressedData.m_bootedPlrSockIdx = bootedPlrSockIdx;

	// (was gameShell)
	if(mainShell)
		mainShell->Client->SendToQueue((void *)&BootPressedData, sizeof(BootPressedSendData_typ));

	#endif //!MAIN_SERVER
}


void CGameAppView::SendClearTable(int tblIdx)
{
	ClearTableSendData ClearTableData;
	
	ClearTableData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	ClearTableData.buffer[1] = 78;	 // MSGGAME_CLEARTABLE
	ClearTableData.buffer[2] = 0;
	ClearTableData.buffer[3] = 0;
	
	ClearTableData.m_tblIdx = tblIdx;

	if(mainShell)
		mainShell->Server->SendToQueue((void *)&ClearTableData, sizeof(ClearTableSendData_typ));
}

void CGameAppView::SendPlayerTextFormat(int plrSockIdx, int textFormat) // for admin only
{
	#ifdef MAIN_SERVER

	TextFormatSendData TextFormatData;
	
	TextFormatData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	TextFormatData.buffer[1] = 92;	  // MSGGAME_PLAYERTEXTFORMAT
	TextFormatData.buffer[2] = 0;
	TextFormatData.buffer[3] = 0;
	
	TextFormatData.m_plrSockIdx = plrSockIdx;
	TextFormatData.m_textFormat = textFormat;

	int plrIdx = m_lobby->GetPlayerIdx(plrSockIdx);
	if(plrIdx==-1) return; // can't find this player forget it.
	if(!m_player[plrIdx].status) return; // status doesn't exist
	strcpy(TextFormatData.m_name, m_player[plrIdx].name);
	
	// (was gameShell)
	if(mainShell)
		mainShell->Server->SendToQueue((void *)&TextFormatData, sizeof(TextFormatSendData_typ));

	#endif //MAIN_SERVER
}


void CGameAppView::UpdateLobbyTVClient(int plrSockIdx, char tblIdx)
{
	char buffer[4];
	
	buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	buffer[1] = 107;		// MSGGAME_UPDATELOBBYTVCLIENT
	buffer[2] = tblIdx;
	buffer[3] = 0;

	// Send this Data to plrSocketIdx only //
	if(mainShell) 
		{
		mainShell->Server->SendToQueue(buffer, 4, plrSockIdx);
		}

}

void CGameAppView::RefreshLeaderBoardsClients(void)
{
	/*
	char buffer[4];
	
	buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	buffer[1] = 109;		// MSGGAME_REFRESHLEADERBOARDS
	buffer[2] = 0;
	buffer[3] = 0;

	// Send this Data to plrSocketIdx only //
	if(mainShell) 
		{
		mainShell->Server->SendToQueue(buffer, 4, -1);	// Send to Everyone
		}
	*/

}


void CGameAppView::UpdateLobbyTVServer(int plrSockIdx, char tblIdx)
{
	
	LobbyWatchSendData LobbyWatchData;
	
	LobbyWatchData.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	LobbyWatchData.buffer[1] = 108;			// MSGGAME_UPDATELOBBYTVSERVER
	LobbyWatchData.buffer[2] = 0;			 
	LobbyWatchData.buffer[3] = 0;			

	LobbyWatchData.plrSockIdx = plrSockIdx;
	LobbyWatchData.tblIdx = tblIdx;
	
	// Send this Data to Server //
	if(mainShell) mainShell->Client->SendToQueue((void *)&LobbyWatchData, sizeof(LobbyWatchSendData_typ));

}


void CGameAppView::AbortMatch(int tblIdx)
{

	// Tell Server & Clients to End the Game //
	char buffer[16];
	buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	buffer[1] = 16;	  // MSGGAME_ABORT_BYSERVER
	buffer[2] = 0;
	buffer[4] = 0; 
	int *v = (int *)&buffer[4];
	*v = rand();
	buffer[6] = tblIdx;

	// Send this Data to Server //
	if(mainShell) mainShell->Client->SendToQueue(buffer, 16);

}




void CGameAppView::UpdateSponsor(int plrSockIdx)
{
	char buffer[256];
	int siz;
	
	// Send Sponsor Text //
	buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	buffer[1] = 101;		// MSGGAME_TABLECHANGEDATA
	buffer[2] = TABLECHANGE_SPONSOR;
	buffer[3] = 0;
	buffer[4] = g_ftpupload;	// We'll send the BOOL state for ftpupload here //

	sprintf(&buffer[5],"%s",m_sponsortxt);
	siz = strlen(&buffer[5]) + 5 + 1; // (1) terminator.

	if(mainShell) mainShell->Server->SendToQueue(buffer, siz, plrSockIdx);

	// Send Sponsor URL //
	buffer[3] = 1; // url instead of text

	sprintf(&buffer[5],"%s",m_sponsorurl);
	siz = strlen(&buffer[5]) + 5 + 1; // (1) terminator.

	if(mainShell) mainShell->Server->SendToQueue(buffer, siz, plrSockIdx);


	if(g_sponsorback==FALSE)
		{
		buffer[3] = 2; // url instead of text
		if(mainShell) mainShell->Server->SendToQueue(buffer, 5, plrSockIdx);
		}
	else{
		buffer[3] = 3; // url instead of text
		if(mainShell) mainShell->Server->SendToQueue(buffer, 5, plrSockIdx);
		}

}

void CGameAppView::SendAbuseLst(int plrSockIdx)
{
	
	g_AbuseLstData.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	g_AbuseLstData.buffer[1] = 110;		// MSGGAME_ABUSELST
	g_AbuseLstData.buffer[2] = 0;	
	g_AbuseLstData.buffer[3] = 0;	
	
	if(mainShell)
		{
		mainShell->Server->SendToQueue((void *)&g_AbuseLstData, sizeof(AbuseLstSendData_typ));
		}
	
}






void CGameAppView::SendServerTime(int plrSockIdx)
{
	serverTimeSendData serverTimeData;
	CTime time;
	time = CTime::GetCurrentTime();


	serverTimeData.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	serverTimeData.buffer[1] = 96;		// MSGGAME_SERVERTIME
	serverTimeData.buffer[2] = 0;
	serverTimeData.buffer[3] = 0;

	
	serverTimeData.year = time.GetYear();
	serverTimeData.month = time.GetMonth();
	serverTimeData.day = time.GetDay();
	serverTimeData.hour = time.GetHour();
	serverTimeData.minute = time.GetMinute();
	serverTimeData.second = time.GetSecond();
	
	serverTimeData.g_GoldThreshold8Ball = (char)(g_GoldThreshold8Ball*100);
	serverTimeData.g_GoldThreshold9Ball = (char)(g_GoldThreshold9Ball*100);
	serverTimeData.g_GoldThresholdEng = (char)(g_GoldThresholdEng*100);
	serverTimeData.g_GoldDecay8Ball = (char)(g_GoldDecay8Ball*100);
	serverTimeData.g_GoldDecay9Ball = (char)(g_GoldDecay9Ball*100);
	serverTimeData.g_GoldDecayEng = (char)(g_GoldDecayEng*100);
	

	if(mainShell)
	{
	mainShell->Server->SendToQueue((void *)&serverTimeData, sizeof(serverTimeSendData_typ));
	}
}

void CGameAppView::ReceiveServerTime(serverTimeSendData *sd)
{
	CTime time;
	CTimeSpan diff;
	time = CTime::GetCurrentTime();

	CTime stime(sd->year, sd->month, sd->day, sd->hour, sd->minute, sd->second);
	diff = stime - time;
	m_ltime2stime = diff.GetTotalSeconds();

	g_GoldThreshold8Ball = ((float)(sd->g_GoldThreshold8Ball))/100;
	g_GoldThreshold9Ball = ((float)(sd->g_GoldThreshold9Ball))/100;
	g_GoldThresholdEng = ((float)(sd->g_GoldThresholdEng))/100;
	g_GoldDecay8Ball = ((float)(sd->g_GoldDecay8Ball))/100;
	g_GoldDecay9Ball = ((float)(sd->g_GoldDecay9Ball))/100;
	g_GoldDecayEng = ((float)(sd->g_GoldDecayEng))/100;



}

CTime CGameAppView::GetServerTime(void)
{
	int ltime;
	CTime time;
	time = CTime::GetCurrentTime();
/*
	int hours = (m_ltime2stime/3600)%24;
	
	if(hours >= 0) time += CTimeSpan(0,hours,0,0); 
		else time -= CTimeSpan(0,(-hours),0,0); 
*/
	time += CTimeSpan(0,0,0,m_ltime2stime);

	/*
	ltime = time.GetHour()*3600+time.GetMinute()*60+time.GetSecond();
	ltime+= m_ltime2stime; // defaults to 0 (i.e. will display local time)
	if(ltime>=86400) ltime-=86400;
	else if(ltime<0) ltime+=86400;

	return CTime(time.GetYear(),time.GetMonth(),time.GetDay(),(ltime/3600)%24,(ltime/60)%60,ltime%60);
	*/
	return CTime(time.GetYear(),time.GetMonth(),time.GetDay(),time.GetHour(),time.GetMinute(),time.GetSecond());
}



void CGameAppView::SendHighBreak(BOOL bIsHost, int plrSockIdx, int highBreak, int cueError, int high4)
{
	HighBreakSendData HighBreakData;
	
	HighBreakData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	HighBreakData.buffer[1] = 79;	// MSGGAME_HIGHBREAK
	HighBreakData.buffer[2] = 0;
	HighBreakData.buffer[3] = 0;
	
	HighBreakData.m_plrSockIdx = plrSockIdx;
	HighBreakData.m_highBreak = highBreak;
	HighBreakData.m_cueError = cueError;
	HighBreakData.m_high4 = high4;
	
	// DEBUG - REMOVE!!
	//char buf[80];
	//sprintf(buf, "SendHighBreak(...) : break = %d (high4 = %d)", highBreak, high4);
	//ErrorMessage(this, buf);

	if(mainShell)
	{
		if(bIsHost)
			mainShell->Server->SendToQueue((void *)&HighBreakData, sizeof(HighBreakSendData_typ));
		else
			mainShell->Client->SendToQueue((void *)&HighBreakData, sizeof(HighBreakSendData_typ));
	}
}


void CGameAppView::SendAllHighBreaks(int plrSockIdx, int high4, int cueError)
{
	AllHighBreaksSendData AllHighBreaksData;
	
	AllHighBreaksData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	AllHighBreaksData.buffer[1] = 80;   // MSGGAME_ALLHIGHBREAKS
	AllHighBreaksData.buffer[2] = 0;
	AllHighBreaksData.buffer[3] = 0;
	
	AllHighBreaksData.m_plrSockIdx = plrSockIdx; // redundant i think.
	
	strcpy(AllHighBreaksData.m_highBreakName0, m_sLobbyHighBreakName[0].GetBuffer(0));
	strcpy(AllHighBreaksData.m_highBreakName1, m_sLobbyHighBreakName[1].GetBuffer(0));
	strcpy(AllHighBreaksData.m_highBreakName2, m_sLobbyHighBreakName[2].GetBuffer(0));
	AllHighBreaksData.m_highBreak0 = m_sLobbyHighBreak[0];
	AllHighBreaksData.m_highBreak1 = m_sLobbyHighBreak[1];
	AllHighBreaksData.m_highBreak2 = m_sLobbyHighBreak[2];

	strcpy(AllHighBreaksData.m_highPBreakName0, m_sLobbyPHighBreakName[0].GetBuffer(0));
	strcpy(AllHighBreaksData.m_highPBreakName1, m_sLobbyPHighBreakName[1].GetBuffer(0));
	strcpy(AllHighBreaksData.m_highPBreakName2, m_sLobbyPHighBreakName[2].GetBuffer(0));
	AllHighBreaksData.m_highPBreak0 = m_sLobbyPHighBreak[0];
	AllHighBreaksData.m_highPBreak1 = m_sLobbyPHighBreak[1];
	AllHighBreaksData.m_highPBreak2 = m_sLobbyPHighBreak[2];

	strcpy(AllHighBreaksData.m_highUKBreakName0, m_sLobbyUKHighBreakName[0].GetBuffer(0));
	strcpy(AllHighBreaksData.m_highUKBreakName1, m_sLobbyUKHighBreakName[1].GetBuffer(0));
	strcpy(AllHighBreaksData.m_highUKBreakName2, m_sLobbyUKHighBreakName[2].GetBuffer(0));
	AllHighBreaksData.m_highUKBreak0 = m_sLobbyUKHighBreak[0];
	AllHighBreaksData.m_highUKBreak1 = m_sLobbyUKHighBreak[1];
	AllHighBreaksData.m_highUKBreak2 = m_sLobbyUKHighBreak[2];


		// This Should Already be Updated (Client Side At Least, and not Vital on Server
	// update high-breaks table


	AllHighBreaksData.m_high4 = high4;
	AllHighBreaksData.m_cueError = cueError;

	if(mainShell)
	{
		if(plrSockIdx == -1) // send to all
			mainShell->Server->SendToQueue((void *)&AllHighBreaksData, sizeof(AllHighBreaksSendData_typ));
		else
			mainShell->Server->SendToQueue((void *)&AllHighBreaksData, sizeof(AllHighBreaksSendData_typ), plrSockIdx);
	}
}

void CGameAppView::SendAllHighBreaksReset(void)
{
	m_serverAllPlayersStats->DeleteAll(); // for iPool
	m_serverAllPlayersSBreaks->DeleteAll(); // for iSnooker Semi Pro Breaks
	m_serverAllPlayersPBreaks->DeleteAll(); // for iSnooker Pro Breaks

	m_sLobbyHighBreakName[0] = _T("...");
	m_sLobbyHighBreakName[1] = _T("...");
	m_sLobbyHighBreakName[2] = _T("...");
	m_sLobbyHighBreak[0] = 0;
	m_sLobbyHighBreak[1] = 0;
	m_sLobbyHighBreak[2] = 0;

	m_sLobbyPHighBreakName[0] = _T("...");
	m_sLobbyPHighBreakName[1] = _T("...");
	m_sLobbyPHighBreakName[2] = _T("...");
	m_sLobbyPHighBreak[0] = 0;
	m_sLobbyPHighBreak[1] = 0;
	m_sLobbyPHighBreak[2] = 0;

	m_sLobbyUKHighBreakName[0] = _T("...");
	m_sLobbyUKHighBreakName[1] = _T("...");
	m_sLobbyUKHighBreakName[2] = _T("...");
	m_sLobbyUKHighBreak[0] = 0;
	m_sLobbyUKHighBreak[1] = 0;
	m_sLobbyUKHighBreak[2] = 0;


	SendAllHighBreaks(-1);
}


void CGameAppView::SendTableHostComplete(int tblIdx)
{
	TableHostCompleteSendData TableHostCompleteData;
	
	TableHostCompleteData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	TableHostCompleteData.buffer[1] = 81;	// MSGGAME_TABLEHOSTCOMPLETE
	TableHostCompleteData.buffer[2] = 0;
	TableHostCompleteData.buffer[3] = 0;
	
	TableHostCompleteData.m_tblIdx = tblIdx;

	if(mainShell)
		mainShell->Client->SendToQueue((void *)&TableHostCompleteData, sizeof(TableHostCompleteSendData_typ));
}

void CGameAppView::SendPlayerTimeUp(BOOL bTimeUp, int i)
{
	TimeUpSendData TimeUpData;
	
	TimeUpData.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	TimeUpData.buffer[1] = 83;		// MSGGAME_TIMEUP
	TimeUpData.buffer[2] = 0;
	TimeUpData.buffer[3] = i;	

	TimeUpData.m_shotTime = m_snooker->m_shotTime;
	TimeUpData.m_bTimeUp = bTimeUp;

	if(mainShell)
		mainShell->Client->SendToQueue((void *)&TimeUpData, sizeof(TimeUpSendData_typ));
}

void CGameAppView::SendPlayerMaxTimeUp(int playerSockIdx)
{
	MaxTimeUpSendData MaxTimeUpData;
	
	MaxTimeUpData.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	MaxTimeUpData.buffer[1] = 90;	// MSGGAME_MAXTIMEUP
	MaxTimeUpData.buffer[2] = 0;
	MaxTimeUpData.buffer[3] = 0;

	MaxTimeUpData.m_playerSockIdx = playerSockIdx;

	if(mainShell)
		mainShell->Client->SendToQueue((void *)&MaxTimeUpData, sizeof(MaxTimeUpSendData_typ));
}


void CGameAppView::ReceivePlayerTimeUp(int shotTime, BOOL bTimeUp)
{	
	if(!bTimeUp)
	{
		m_snooker->m_shotTime = shotTime;
	}
	else
	{
		
		m_snooker->m_shotTimeOld = m_snooker->m_shotTime = 60*50; // *NEW - i put this line back in

		m_snooker->m_bShotTimeUp = FALSE;
		
		FreeMouse();

		// reset mouse cursor position back to start position
		CRect rect;
		GetWindowRect(&rect);
		SetCursorPos(rect.left + m_snooker->m_sCPoint.x+2, rect.top + m_snooker->m_sCPoint.y+2);

		// display TimeUp! message
		///////////////////////////////////
		// display system msg
		int tbl = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tbl!=-1)
		{
			int plr1Idx = m_lobby->GetPlayerIdx(m_table[tbl].player1SockIdx);
			if(plr1Idx == -1) goto endsystemmsg;
			int plr2Idx = m_lobby->GetPlayerIdx(m_table[tbl].player2SockIdx);
			if(plr2Idx == -1) goto endsystemmsg;

			char _buffer[MAX_CHARS];
			if(m_snooker->m_bTurn1P)
				sprintf(_buffer,"*** %s has run out of time! ***", m_player[plr1Idx].name);
			else
				sprintf(_buffer,"*** %s has run out of time! ***", m_player[plr2Idx].name);

			Message(_buffer,10); // system message
		}
		endsystemmsg:;
		///////////////////////////////////
	
		m_snooker->m_selectBall = WHITE; // just in case player selected another ball

		// special case for bowls game
		if(g_build.gameType == GAMETYPE_POOL)
		if(m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
		{
			//m_snooker->m_customTable->RefereeBowlsOutOfTime(); // removes the bowl, that wasn;t played out			
			//m_snooker->m_selectBall = m_snooker->m_dominoHit1st = m_snooker->m_customTable->RefereeBowlsNextStrikeBall();
			
			// get next ball to be rolled out, just in case player selected another ball that has already been played out
			m_snooker->m_selectBall = m_snooker->m_customTable->RefereeBowlsNextStrikeBall();			
		}
											
		// now strike ball at 0%, to induce referee() code call -- to give a foul!
		// ---------------------------------------------------
		// play a 0% shot, so that the referee code is triggered
		if(m_snooker->MyTurn())
		{
			m_snooker->m_bSeenSelectBall = TRUE;

			

			m_snooker->m_bCueTipReady = FALSE;
			m_snooker->m_bCueTipReadyFirstTime = TRUE;
			 
			m_snooker->m_ballMouseOn = 1;
			m_sliderRaiseButt.EnableWindow(FALSE);
			PreviousWndEditSetFocus();

			m_snooker->StrikeBallSend(TRUE);

			// player decided to play the shot! - so loses opportunity to put opponent back in!
			if(m_snooker->m_bFoulDecideTurn)
			{
				m_snooker->m_bFoulDecideTurn = FALSE;					
				m_snooker->m_foulDlg.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
			}
		}
		// ---------------------------------------------------
	}
}


void CGameAppView::ReceivePlayerMaxTimeUp(int playerSockIdx)
{	
	int myTbl = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	int tbl = m_lobby->GetTableIdxFromPlayer(playerSockIdx);

	// only if on the same table
	if(tbl!=-1)
	if(myTbl == tbl)
		{
		if(!m_table[tbl].doubles)
			{
			int plr1Idx = m_lobby->GetPlayerIdx(m_table[tbl].P1StartAtTable);
			if(plr1Idx == -1) goto endsystemmsg;
			int plr2Idx = m_lobby->GetPlayerIdx(m_table[tbl].P2StartAtTable);
			if(plr2Idx == -1) goto endsystemmsg;

			// display MaxTimeUp! message
			char _buffer[MAX_CHARS];
			if(m_snooker->m_bTurn1P)
				{						
				sprintf(_buffer,"*** %s has exceeded the '2 minutes' allowed for a shot! ***", m_player[plr1Idx].name);
				Message(_buffer,10); // system message
				sprintf(_buffer,"*** %s has the option to force %s to forfeit this frame/rack ***", m_player[plr2Idx].name, m_player[plr1Idx].name);
				Message(_buffer,10); // system message
				}
			else
				{
				sprintf(_buffer,"*** %s has exceeded the '2 minutes' allowed for a shot! ***", m_player[plr2Idx].name);
				Message(_buffer,10); // system message
				sprintf(_buffer,"*** %s has the option to force %s to forfeit this frame/rack ***", m_player[plr1Idx].name, m_player[plr2Idx].name);
				Message(_buffer,10); // system message			
				}
			}
		else{
			int plr1Idx = m_lobby->GetPlayerIdx(m_table[tbl].P1StartAtTable);
			if(plr1Idx == -1) goto endsystemmsg;
			int plr1bIdx = m_lobby->GetPlayerIdx(m_table[tbl].P1bStartAtTable);
			if(plr1bIdx == -1) goto endsystemmsg;
			
			int plr2Idx = m_lobby->GetPlayerIdx(m_table[tbl].P2StartAtTable);
			if(plr2Idx == -1) goto endsystemmsg;
			int plr2bIdx = m_lobby->GetPlayerIdx(m_table[tbl].P2bStartAtTable);
			if(plr2bIdx == -1) goto endsystemmsg;

			// display MaxTimeUp! message
			char _buffer[MAX_CHARS];
			if(m_snooker->m_bTurn1P)
				{						
				sprintf(_buffer,"*** %s / %s have exceeded the '2 minutes' allowed for a shot! ***", m_player[plr1Idx].name, m_player[plr1bIdx].name);
				Message(_buffer,10); // system message
				sprintf(_buffer,"*** %s / %s have the option to force %s / %s to forfeit this frame/rack ***", m_player[plr2Idx].name, m_player[plr2bIdx].name, m_player[plr1Idx].name, m_player[plr1bIdx].name);
				Message(_buffer,10); // system message
				}
			else
				{
				sprintf(_buffer,"*** %s / %s has exceeded the '2 minutes' allowed for a shot! ***", m_player[plr2Idx].name, m_player[plr2bIdx].name);
				Message(_buffer,10); // system message
				sprintf(_buffer,"*** %s / %s has the option to force %s / %s to forfeit this frame/rack ***", m_player[plr1Idx].name, m_player[plr1bIdx].name, m_player[plr2Idx].name, m_player[plr2bIdx].name);
				Message(_buffer,10); // system message			
				}
			}

		}
	

	endsystemmsg:;
}


void CGameAppView::SendPlayerLostConnection(int playerSockIdx, char name[22], int tblIdx)
{
	PLCSendData PLCData;

	PLCData.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	PLCData.buffer[1] = 84;		// MSGGAME_PLAYERLOSTCONN
	PLCData.buffer[2] = 0;
	PLCData.buffer[3] = 0;

	PLCData.m_playerSockIdx = playerSockIdx;
	strcpy(PLCData.m_name, name);
	PLCData.m_tblIdx = tblIdx;
	
	
	if(mainShell)
	{
		// get server's own client to send it to itself, so that it can be rebroadcasted to all at specified table...
		mainShell->Client->SendToQueue((void *)&PLCData, sizeof(PLCSendData_typ));		
	}
}




void CGameAppView::SendPlayerConnection(int playerSockIdx, int gameOver, int gameOverIWon, int playerSockIdx2, int m_tblIdx)
{
	PCSendData PCData;

	PCData.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	PCData.buffer[1] = 103;		// MSGGAME_PLAYERCONN
	PCData.buffer[2] = 0;
	PCData.buffer[3] = 0;

	PCData.m_playerSockIdx = playerSockIdx;
	PCData.m_gameOver = gameOver;
	PCData.m_gameOverIWon = gameOverIWon;
	PCData.m_playerSockIdx2 = playerSockIdx2;
	PCData.m_tblIdx = m_tblIdx;
	PCData.m_cueBallSelect = m_snooker->m_cueBallSelect;

	if(mainShell)
	{
		mainShell->Client->SendToQueue((void *)&PCData, sizeof(PCSendData_typ));		
	}
}

void CGameAppView::SendPlayerTargetData(int targetPocket, int targetBall, BOOL bTargetSuccess)
{	
	PlayerTargetSendData PlayerTargetData;

	PlayerTargetData.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	PlayerTargetData.buffer[1] = 91;	// MSGGAME_PLAYERTARGETDATA
	PlayerTargetData.buffer[2] = 0;
	PlayerTargetData.buffer[3] = 0;

	PlayerTargetData.m_targetPocket = targetPocket;
	PlayerTargetData.m_targetBall = targetBall;
	PlayerTargetData.m_bTargetSuccess = bTargetSuccess;
	
	if(mainShell)
	{
		mainShell->Client->SendToQueue((void *)&PlayerTargetData, sizeof(PlayerTargetSendData_typ));		
	}
}

void CGameAppView::SendTMatchTimerLeft(int timeRemaining, int type, char *str, int plrSockIdx, int tblIdx)
{
	TMatchTimerLeftSendData TMatchTimerLeftData;
	
	TMatchTimerLeftData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	TMatchTimerLeftData.buffer[1] = 93;   // MSGGAME_TMATCHTIMERLEFT
	TMatchTimerLeftData.buffer[2] = 0;
	TMatchTimerLeftData.buffer[3] = 0;

	TMatchTimerLeftData.m_timeRemaining = timeRemaining;
	TMatchTimerLeftData.m_type = type;
	TMatchTimerLeftData.m_str[0] = 0;
	if(str) strcpy(TMatchTimerLeftData.m_str, str);
	TMatchTimerLeftData.m_str[127] = 0;
	TMatchTimerLeftData.m_plrSockIdx = plrSockIdx;
	TMatchTimerLeftData.m_tblIdx = tblIdx;

	if(mainShell)
	{
		/*
		if(tblIdx != -1 && plrSockIdx != -1) // SPECIAL CASE: let 'tblIdx' take priority
		{
			// get server's own client to send it to itself, so that it can be rebroadcasted to all at specified table...
			mainShell->Client->SendToQueue((void *)&TMatchTimerLeftData, sizeof(TMatchTimerLeftSendData_typ));
		}
		*/

		// normal plrSockIdx Xor tblIdx...
		if(plrSockIdx == -1) // send to all...
		{
			if(tblIdx == -1) // now send to all...
				mainShell->Server->SendToQueue((void *)&TMatchTimerLeftData, sizeof(TMatchTimerLeftSendData_typ));
			else // get server's own client to send it to itself, so that it can be rebroadcasted to all at specified table...
				mainShell->Client->SendToQueue((void *)&TMatchTimerLeftData, sizeof(TMatchTimerLeftSendData_typ));
		}
		else // send to an individual...
			mainShell->Server->SendToQueue((void *)&TMatchTimerLeftData, sizeof(TMatchTimerLeftSendData_typ), plrSockIdx);
	}
}

void CGameAppView::SendTextMsg(char *str, int type, int plrSockIdx, int tblIdx, int lobbyAndTblIdx)
{
	TextMsgSendData TextMsgData;
	
	TextMsgData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	TextMsgData.buffer[1] = 95;   // MSGGAME_TEXTMSG
	TextMsgData.buffer[2] = 0;
	TextMsgData.buffer[3] = 0;

	TextMsgData.m_str[0] = 0;
	if(str) strcpy(TextMsgData.m_str, str);
	TextMsgData.m_str[199] = 0; // just in case our string is >=200
	TextMsgData.m_type = type;
	TextMsgData.m_plrSockIdx = plrSockIdx;
	TextMsgData.m_tblIdx = tblIdx;
	TextMsgData.m_lobbyAndTblIdx = lobbyAndTblIdx;

	if(mainShell)
	{	// this client to send this msg to the server. (the server will decide what to do with it)
		mainShell->Client->SendToQueue((void *)&TextMsgData, sizeof(TextMsgSendData_typ));
	}
}



void CGameAppView::BootPlayer(int plrSockIdx, int msg)
{		
	// change window title
	CString title;
	title.Format("  Lobby");
	ChangeTitle(title);

	if(g_gameAppView)
	{
		g_gameAppView->m_sit1PButtonB.ShowWindow(SW_HIDE);
		g_gameAppView->m_sit2PButtonB.ShowWindow(SW_HIDE);

		// Destroy the Force forfit MaxTimeUp dlg if it's open!
		if(g_gameAppView->m_forfeitDlg.m_hWnd)
		if(g_gameAppView->m_forfeitDlg.IsWindowEnabled())
		if(g_gameAppView->m_forfeitDlg.m_forfeitType == 1)
		{
			g_gameAppView->m_forfeitDlg.DestroyWindow();
		}

	}

	m_lobby->m_bInLobby = TRUE;
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;



	::ShowWindow(g_hwndDX, SW_HIDE);
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
	DestroyGameShell();

	
	if(msg == 1)
	{
		// display status msg
		char _buffer[MAX_CHARS];
		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		sprintf(_buffer,"*** LOST CONNECTION WITH 'HOST' OF TABLE #%d! ***", tblIdx+1);
		Message(_buffer,10); // system message
	}
	else if(msg == 2)
	{
		// display booted message in lobby - for booted player only:
		char _buffer[MAX_CHARS];
		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		sprintf(_buffer,"*** You have been booted from table #%d! ***", tblIdx+1);
		Message(_buffer,10); // system message		
	}
	
	FreeMouse();

	// send main server message that we've left the table (destroyed the game shell)
	SendPlayerExit(FALSE, plrSockIdx);
}


void CGameAppView::ExitTable2Lobby(void)
{
#ifndef MAIN_SERVER

	g_tabSelected = 0;
	m_bLobbyMode = 1;				

	m_bUpdateTable = TRUE;
	// change window title
	CString title;
	title.Format("  Lobby");
	ChangeTitle(title);

	::ShowWindow(g_hwndDX, SW_HIDE);
	m_lobby->m_bInLobby = TRUE;


	if(g_gameAppView)
	{
		// Destroy the Force forfit MaxTimeUp dlg if it's open!
		if(g_gameAppView->m_forfeitDlg.m_hWnd)
		if(g_gameAppView->m_forfeitDlg.IsWindowEnabled())
		if(g_gameAppView->m_forfeitDlg.m_forfeitType == 1)
		{
			g_gameAppView->m_forfeitDlg.DestroyWindow();
		}
	}


	/*
	// Render Lobby TV Frame, so it's smooth at transitioning //
	//CDC *pDC = NULL;
	//pDC = GetDC();
	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	int widthMixedMode = 4+(70 + 50 + 100 + 100)+::GetSystemMetrics(SM_CXVSCROLL);
	int tv_x, tv_y, tv_w, tv_h;
	CBrush brush_black = RGB(0,0,0);
	tv_x = 0;
	tv_y = 108;
	// tv_w = (float)(m_cx) * 0.33f;
	tv_h = (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-1;

	tv_w = (float)(m_cx) * 0.43f;
	
	// Make sure our Table and Player List has at least 
	if( (m_cx - tv_w) < 620 )
	{
		tv_w = m_cx - 620;
	}

	if(m_bFullMode)
	{
		tv_w = m_cx - 249;
	}



	int offY = 0;
	int offX = 2;

	
		DrawLobbyTV(tv_x+offX, tv_y, tv_w, tv_h);
	}
	*/
	

	if(g_gameAppView)
	{
		g_gameAppView->m_sit1PButtonB.ShowWindow(SW_HIDE);
		g_gameAppView->m_sit2PButtonB.ShowWindow(SW_HIDE);
	}

	//m_htmlViewTickerBoard.SetWindowPos(&wndTop, 0, 0,100,32, SWP_SHOWWINDOW);

	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	
	m_htmlViewBanner.Invalidate(); // causes ondraw message - for repainting
	m_htmlViewLeaderBoardA.Invalidate(); // causes ondraw message - for repainting
	m_htmlViewLeaderBoardB.Invalidate(); // causes ondraw message - for repainting	
	m_htmlViewTickerBoard.Invalidate(); // causes ondraw message - for repainting
	m_htmlViewTickerBoard.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_htmlViewMB.Invalidate(); // causes ondraw message - for repainting

	m_htmlViewLeaderBoardA.Refresh2(REFRESH_COMPLETELY);
	m_htmlViewLeaderBoardB.Refresh2(REFRESH_COMPLETELY);
	//m_htmlViewTickerBoard.Refresh();

	
	// Show the Ticker Board and Banner URL
	m_htmlViewTickerBoard.Navigate2(g_URLlobbyTickerBoard, NULL, NULL);
	m_htmlViewBanner.Navigate2(g_URLBanner,NULL,NULL);

	m_htmlViewTickerBoard.ShowWindow(SW_SHOW);
	m_htmlViewBanner.ShowWindow(SW_SHOW);
		
	PreviousWndEditSetFocus();
	
	if(g_build.gameType == GAMETYPE_POOL)
		m_tableSetupDlg.DestroyWindow();
	else if(g_build.gameType == GAMETYPE_SNOOKER)
		m_tableSetupDlg2.DestroyWindow();
	
	FreeMouse();

	DestroyGameShell();

#endif	
}


void CGameAppView::FreeMouse(void)
{
	///////**************/////////
	// ensure mouse cursor is visible (just in-case someone is mid-way thru the line-up process)
	//if(GAMEAPPVIEW->m_snooker->MyTurn())
	if(!m_bShowCursor)
	{
		// Now Give ,mouse's attention to all
		if(GetCapture() == this) ReleaseCapture();

		// give mouse full movement
		ClipCursor(&m_rectCursor);

		m_bShowCursor = TRUE;
		SetCursor(m_hCursor);
		ShowCursor(m_bShowCursor); // show cursor
	}
	///////**************/////////

	
	// Now Give ,mouse's attention to all
		//if(GetCapture() == GAMEAPPVIEW->m_sendEdit) 
		//{
			//AfxGetMainWnd()->EnableWindow(TRUE);
			ReleaseCapture();
			PreviousWndEditSetFocus();
		//}			
	
}


void CGameAppView::CloseApp(void)
{
	
	if(gameShell) 
	{
		if(gameShell->Client)
			gameShell->Client->Close();

		if(gameShell->Server)
			gameShell->Server->Close();

		delete gameShell;
		gameShell = NULL;
	}

	if(mainShell) 
	{
		if(mainShell->Client)
			mainShell->Client->Close();

		if(mainShell->Server)
			mainShell->Server->Close();

		delete mainShell;
		mainShell = NULL;
	}

	g_bClose = 1;
	AfxGetMainWnd()->DestroyWindow();
	return;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
void CGameAppView::GamePingInit(void)
{
	return;

	// reset counts
	m_sendGamePingCount = 0;
	m_receiveGamePingCount = -1;
}

void CGameAppView::GamePingProcess(void)
{
	return;

	int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
	if(plrIdx == -1)
		return;

	int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	if(tblIdx == -1)
		return;

	// only people online and at tables do this:
	
	if(m_receiveGamePingCount == -1)
	{
		m_sendGamePingCount++;
		if(m_sendGamePingCount >= (GAMEAPPCLIENT_FPS * 5))
		{
			// send GamePing out to 'Host' of table (GameShell)
			SendGamePing(m_playerSockIdx);
			m_receiveGamePingCount = 0;
		}
	}
	else
	{
		// wait for a certain time 'till ping bounces back...
		m_receiveGamePingCount++;
		if(m_receiveGamePingCount >= (GAMEAPPCLIENT_FPS * 15))
		{
			// (Error!!! probably lost connection to host of table!)
			
			// check if a player 1P or 2P is holding up the game, if so then it MUST be his fault so forfeits the game			
			int myTbl = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
			if(myTbl == -1)
			return;

			if(m_playerSockIdx == m_table[myTbl].P1StartAtTable) // P1 check
			{
				//GAMEAPPVIEW->SendPlayerExit(FALSE, m_playerSocketIdx, TRUE);
				BootPlayer(m_playerSockIdx, 1); // boot myself for now
				SendGameOverForAll(myTbl, 16+1); // cancel game
			}
			else if(m_playerSockIdx == m_table[myTbl].P2StartAtTable) // P2 check
			{
				//GAMEAPPVIEW->SendPlayerExit(FALSE, m_playerSocketIdx, TRUE);
				BootPlayer(m_playerSockIdx, 1); // boot myself for now
				SendGameOverForAll(myTbl, 16+2); // cancel game
			}
			else
			{
				BootPlayer(m_playerSockIdx, 1); // boot myself for now
				//GAMEAPPVIEW->SendPlayerExit(FALSE, m_playerSocketIdx, TRUE);
			}
			
			//BootPlayer(m_playerSockIdx, 1); // boot myself for now
		}
	}

}

void CGameAppView::SendGamePing(int plrSockIdx)
{
	return;	
	
	#ifndef MAIN_SERVER
	
	GamePingSendData GamePingData;
	
	GamePingData.buffer[0] = 0x7f; // MSGCODE_GAME Game message.
	GamePingData.buffer[1] = 77;   // MSGGAME_GAMEPING
	GamePingData.buffer[2] = 0;
	GamePingData.buffer[3] = 0;
	
	GamePingData.m_plrSockIdx = plrSockIdx;
	
	if(gameShell)
		gameShell->Client->SendToQueue((void *)&GamePingData, sizeof(GamePingSendData_typ));

	#endif //!MAIN_SERVER
}

void CGameAppView::GamePingReceive(int plrSockIdx)
{
	return;

	if(plrSockIdx == -1)
		return;
	
	// is this my own ping msg bouncing back?
	if(m_playerSockIdx == plrSockIdx)
	{
		// display host Ping time
		m_hostPingTime = (float)(m_receiveGamePingCount / GAMEAPPCLIENT_FPS);

		// all is well, reset counts for next ping
		m_sendGamePingCount = 0;
		m_receiveGamePingCount = -1;
	}	
}
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////


/*void CGameAppView::ProcessReplay(void)
{
	if(m_bReplayStatus==2)
	{
	m_bReplayStatus = 1;
	
	// handle next step //
	CReplay *m_replay = GAMEAPPVIEW->m_replay;

	if(m_replay->GetStrike(0)==NULL);
	else {
		// REPLAY: Step Forward /////////////////////////////////////////////////////////////////
		CReplayStrike *strike = m_replay->StepStrike();
		((CGameAppView *)m_pParent)->HandleReplayCommand(strike);
		m_slider.SetPos(GetSliderPos());
		
		// ///////////////////////////////////////////////////////////////////////////////

		GAMEAPPVIEW->HandleReplayCommand(CReplayStrike *strike)
		}
	}
}*/

void CGameAppView::HandleReplayCommand(CReplayStrike *strike)
{
	#ifndef MAIN_SERVER

	switch(strike->m_type)
		{
		case STRIKETYPE_BALL:m_snooker->StrikeBallReplay((CReplayStrikeBall *) strike);
							 break;
		case STRIKETYPE_RERACK:
							   #ifdef THE_POOL_CLUB
							   m_snooker->m_customTable->m_type = ((CReplayStrikeReRack *) strike)->m_customTableType;
							   #endif //THE_POOL_CLUB
							   m_snooker->m_reRackType = ((CReplayStrikeReRack *) strike)->m_reRackType;
							   m_snooker->ClearBalls();
							   m_snooker->ReRack(1,((CReplayStrikeReRack *) strike)->m_randseed);
							   break;
		case STRIKETYPE_BALLPOS:m_snooker->BallPosReplay((CReplayStrikeBallPos *) strike);
								break;
		case STRIKETYPE_TIME:m_replay->HandleTime((CReplayStrikeTime *) strike);
							 break;
		case STRIKETYPE_STATE:m_snooker->StateReplay((CReplayStrikeState *) strike);
							  break;
		}

	#endif //!MAIN_SERVER
}

/*void CGameAppView::FinishReplayCommand(void)
{
	m_bReplayStatus = 2; // command finished
}*/


// buttons pressed!
void CGameAppView::OnButtonStart(void)
{
	#ifndef MAIN_SERVER

	if(m_snooker->m_bPracticeMode)
	{
		//if(gameShell) SendReset(); // network game only!
		m_snooker->Init(m_snooker->m_reRackType);
		//m_snooker->UpdateGPottedBalls();
	}
	else
	{
		// check this player is 'sitting' at a table (not watching!), before sending start message
		if(m_lobby->SeatedAtTable(m_playerSockIdx))
			if(m_lobby->BothSeatsTaken(m_playerSockIdx))
				{
				SendStartPressed(m_playerSockIdx); // network game only!
				}

	}

	// initialise snooker object
	//m_snooker->Init(m_snooker->m_reRackType);

	#endif //!MAIN_SERVER
}

void CGameAppView::OnButtonReRack(void)
{
	#ifndef MAIN_SERVER
	
	if(m_snooker->m_bPracticeMode)
	{
		// do nothing if in practice mode
	}
	else
	{
		
		// check this player is 'sitting' at a table (not watching!)
		//if(m_snooker->m_cueBallSelect == 0)
		if(m_lobby->SeatedAtTable(m_playerSockIdx))
			if(m_lobby->BothSeatsTaken(m_playerSockIdx))
				if(m_snooker->MyTurn())
				{
					//if(gameShell)
					{
						m_rerackDlg.DestroyWindow();
						m_rerackDlg.Create(IDD_RERACKDLG);
						m_rerackDlg.ShowWindow(SW_SHOW);	
					}
				}
	}

	#endif //!MAIN_SERVER
}


void CGameAppView::OnButtonConcede(void)
{
	#ifndef MAIN_SERVER

	if(m_snooker->m_bPracticeMode)
	{
		// do nothing if in practice mode
	}
	else
	{

		/*
		// Team Captains are the only people who can Concede / Rerack Games //
		if(!m_myself.status) 
			{
			char _buffer[80];
			sprintf(_buffer,"*** Only Team Captains can Concede ***");
			Message(_buffer,10); // personal message			
			}
		*/

		// check this player is 'sitting' at a table (not watching!)
		//if(m_snooker->m_cueBallSelect == 0)
		if(m_lobby->SeatedAtTable(m_playerSockIdx)) // NEW: must be seated
		if(m_lobby->GameStarted(m_playerSockIdx))
		if(m_myself.status)
		if(m_snooker->m_gameOver == 0)
			{
			m_concedeDlg.DestroyWindow();
			m_concedeDlg.Create(IDD_CONCEDEDLG);
			m_concedeDlg.ShowWindow(SW_SHOW);	
			}
	}

	#endif //!MAIN_SERVER
}





void CGameAppView::OnButtonExit(void)
{
	#ifndef MAIN_SERVER
	//if(gameShell) //?? [-]

	

	if(!m_lobby->m_bInLobby)
	{
		// *NEW* - fix for "concede then exit table in raceto"...
		BOOL bConcedeThenExit = FALSE;
		int myTblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(myTblIdx != -1)			
		if(m_table[myTblIdx].raceTo > 0)
		{
			if(m_lobby->GetPlayerSeat(m_playerSockIdx) == 1) // if 1P has pressed 'EXIT'
			{
				if(m_table[myTblIdx].racksWon2P <= (m_table[myTblIdx].raceTo-1))
					bConcedeThenExit = TRUE;
			}
			else if(m_lobby->GetPlayerSeat(m_playerSockIdx) == 2) // if 2P has pressed 'EXIT'
			{
				if(m_table[myTblIdx].racksWon1P <= (m_table[myTblIdx].raceTo-1))
					bConcedeThenExit = TRUE;
			}
			if(m_lobby->GetPlayerSeat(m_playerSockIdx) == 3) // if 1Pb has pressed 'EXIT'
			{
				if(m_table[myTblIdx].racksWon2P <= (m_table[myTblIdx].raceTo-1))
					bConcedeThenExit = TRUE;
			}
			else if(m_lobby->GetPlayerSeat(m_playerSockIdx) == 4) // if 2Pb has pressed 'EXIT'
			{
				if(m_table[myTblIdx].racksWon1P <= (m_table[myTblIdx].raceTo-1))
					bConcedeThenExit = TRUE;
			}
		}
		////////////////////////////////////////////////////////////


		if(!m_snooker->m_bPracticeMode)
		{


			
			

			// if player is still involved in a game?
			if(m_lobby->GameStarted(m_playerSockIdx) && m_myself.status && (m_snooker->m_gameOver == 0 || m_snooker->m_gameOverIWon == 1 || bConcedeThenExit) )
			{ 
				m_exitDlg.DestroyWindow();
				m_exitDlg.Create(IDD_EXITDLG);
				m_exitDlg.ShowWindow(SW_SHOW);

				return;
			}			
			
			 // If we are sitting at P1b or P2b and Exited Table, then we need to go into the following code too //
			else if(m_lobby->GameStarted(m_playerSockIdx) && m_lobby->SeatedAtTable(m_playerSockIdx) && (m_snooker->m_gameOver == 0 || m_snooker->m_gameOverIWon == 1 || bConcedeThenExit) )
			{ 
				m_exitDlg.DestroyWindow();
				m_exitDlg.Create(IDD_EXITDLG);
				m_exitDlg.ShowWindow(SW_SHOW);

				return;
			}			
			
			else
			{
				// ExitTable2Lobby(); This has to be down when Server Has OK'ed Table Exit //
				// Incase the other player quickly pressed start at the same time //
				// send main server message that we've left the table (destroyed the game shell)
				SendPlayerExit(FALSE, m_playerSockIdx);
				return;
			}			
		}
	}
	else
	{
		OnInternetExit();

		// Reset Find Match Ctrl
		m_findMatchCtrl->UpdateStatus(0);

		return;
	}
	#endif //!MAIN_SERVER
}

void CGameAppView::OnButtonUndo(void)
{
	#ifndef MAIN_SERVER

	if(!g_ButtonUndoActive) return;
	// if not practice mode
	//sendrerack(playsockidx);

	
	m_snooker->RestorePreviousPosition();

	#endif //!MAIN_SERVER
}
	
void CGameAppView::OnButtonInvite(void)
{
	#ifndef MAIN_SERVER

	if(m_snooker->m_bPracticeMode)
	{
		// do nothing if in practice mode
	}
	else
	{
		if(m_lobby->HostOfTable(m_playerSockIdx))
		{		
			/*
			int plrIdxOfHost = m_lobby->GetPlayerIdx(m_playerSockIdx);
			if(m_player[plrIdxOfHost].bIsGuest)
			{
				// [guests not able to invite other players]
				char _buffer[80];
				sprintf(_buffer,"*** Option not avaliable for guests ***");
				Message(_buffer,10); // personal message			
				
			}
			else
			{
			*/
//			if(!OptionNotForGuest(m_playerSockIdx))
			{
				// members
				m_inviteDlg.DestroyWindow();
				m_inviteDlg.Create(IDD_INVITE);
				m_inviteDlg.ShowWindow(SW_SHOW);
				
			}
		}
	}

	#endif //!MAIN_SERVER
}

void CGameAppView::OnButtonBoot(void)
{
	#ifndef MAIN_SERVER

	if(m_snooker->m_bPracticeMode)
	{
		// do nothing if in practice mode
	}
	else
	{
		if(m_lobby->HostOfTable(m_playerSockIdx))
		{		
			/*
			int plrIdxOfHost = m_lobby->GetPlayerIdx(m_playerSockIdx);
			if(m_player[plrIdxOfHost].bIsGuest)
			{
				// [guests not able to boot other players]
				char _buffer[80];
				sprintf(_buffer,"*** Option not avaliable for guests ***");
				Message(_buffer,10); // personal message				
			}
			else
			*/
			if(!OptionNotForGuest(m_playerSockIdx))
			{
				// members
				m_bootDlg.DestroyWindow();
				m_bootDlg.Create(IDD_BOOT);
				m_bootDlg.ShowWindow(SW_SHOW);
			}
		}
	}		
	//Msfx_smpplay(&m_game_smp[SFX_INTRO]);

	#endif //!MAIN_SERVER
}

void CGameAppView::OnButtonSetup(void)
{

	// If we're in a Ladder Match, don't allow Setup button to be clicked


	if(g_build.gameType == GAMETYPE_POOL)
	{
		if( m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 )
		{
			m_tableSetupDlg.DestroyWindow();
			m_tableSetupDlg.Create(IDD_TABLESETUPDLG);
			m_tableSetupDlg.ShowWindow(SW_SHOW);
		}
	}
	else if(g_build.gameType == GAMETYPE_SNOOKER)
	{		
		m_tableSetupDlg2.DestroyWindow();
		m_tableSetupDlg2.Create(IDD_TABLESETUPDLG2);
		m_tableSetupDlg2.ShowWindow(SW_SHOW);
	}
}

void CGameAppView::OnButtonReportAbuse(void)
{
	ErrorMessage(this, "Report button!");
}

void CGameAppView::OnButtonStand(void)
{	
	ButtonPressedSend("/n");
}

void CGameAppView::OnButtonEndPractice(void) // *NOTE - this code is now absolete!
{
	#ifndef MAIN_SERVER
	
	m_bPracticeEditPlay = TRUE;

	m_snooker->Init(RERACK_EMPTY);//RERACK_START);
	//m_snooker->Init(RERACK_START);
	m_snooker->m_bPracticeMode = FALSE;
	m_snooker->m_bComputerMode = TRUE;
	m_snooker->m_seat = -1;
	
//	m_EndPracticeButton.EnableWindow(FALSE);
//	m_EndPracticeButton.ShowWindow(SW_HIDE);
	m_practiceEditDlg.DestroyWindow();
	m_practiceEditDlg.m_commentDlg.DestroyWindow();
	m_replayDlg.DestroyWindow(); m_bReplayMode = FALSE;

	// clear out all the text in the chat window
	DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
	m_editExChat.SetSel(ss,FALSE);
	m_editExChat.ReplaceSel(_T(""));
	//m_editExChat.Clear(); // Beep
	m_sendEdit.SetSel(ss,FALSE);
	m_sendEdit.ReplaceSel(_T(""));
	
	ChangeTitle("");
	
	m_justEndedPractice = TRUE;
		
	// ensure that all seats are enabled & visible
	if(gameShell) 
	{
		for(int n=0;n<gameShell->m_seatList_n;n++)
		if(gameShell->m_seatList[n])
		if(n>0)
		{
			gameShell->m_seatList[n]->m_button.EnableWindow(TRUE);
			//gameShell->m_seatList[n]->m_button.ShowWindow(SW_SHOW);
			break;
		}

		//gameShell->OnDraw(GetDC(), m_cx, m_cy);
		// make sure player has stood up from seat
		//m_standButton.m_pParent->OnEvent(100);//m_standButton.m_id);

		gameShell->m_seat = -1; // if our player is standing then we're back to -1. not a player.
		gameShell->m_seatList[0]->Stand();
		//CDC *pDC = ((CGameAppView *)m_pParentWnd)->GetDC();
		//OnDraw(pDC, ((CGameAppView *)m_pParentWnd)->m_cx, ((CGameAppView *)m_pParentWnd)->m_cy);
		//((CGameAppView *)m_pParentWnd)->ReleaseDC(pDC);
		//m_snooker->m_seat = gameShell->m_seat;
		//gameShell->OnDraw(GetDC(), m_cx, m_cy);
	}

	#endif //!MAIN_SERVER
}



void CGameAppView::OnButtonCueError(void)
{
#if 0
	#ifndef MAIN_SERVER

	if(m_lobby->HostOfTable(m_playerSockIdx))
	{		
		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tblIdx == -1)
			return;

		if(m_table[tblIdx].bGameStarted)
		{
			int selectType = m_cueErrorBox.GetCurSel();
			if(selectType != m_table[tblIdx].cueError)
				m_cueErrorBox.SetCurSel(m_table[tblIdx].cueError);
			return;	
		}
		
		int selectType = m_cueErrorBox.GetCurSel();
		if(selectType != m_table[tblIdx].cueError)
			SendTableHostDetails(FALSE, selectType, 0, -1, 0, m_playerSockIdx);
	}
	else if(m_snooker->m_bPracticeMode)
	{
		int selectType = m_cueErrorBox.GetCurSel();
		m_snooker->m_cueError = selectType;
		/*
		int state = m_cueErrorButton.GetCheck();
		switch(selectType)
		{
			case 0:// toggle to ON
				m_cueErrorBox.SetCheck(1);
				m_snooker->m_bCueError = 0;
				break;
			case 1:// toggle to OFF
				m_cueErrorButton.SetCheck(0);
				m_snooker->m_bCueError = FALSE;
				break;
			case 2:
				break;
		}
		*/
	}
	else
	{
		// for all other people at a table, they cant change the table type
		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tblIdx == -1)
			return;

		int selectType = m_cueErrorBox.GetCurSel();
		if(selectType != m_table[tblIdx].cueError)
			m_cueErrorBox.SetCurSel(m_table[tblIdx].cueError);
	}

	#endif //!MAIN_SERVER
#endif //0
}

void CGameAppView::OnButtonRated(void)
{
	#ifndef MAIN_SERVER
	
	if(m_lobby->HostOfTable(m_playerSockIdx))
		{	
		if(g_bTournamentLobby)
			return;

		/*// DISABLE RATED BUTTON!!!!! - SO THAT ALL GAMES ARE FIXED TO 'RATED' AS TICKED
		char _buff[256];
		sprintf(_buff,"*** Option has been disabled ***");
		Message(_buff,10); // personal message			
		return;
		*/

		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tblIdx == -1)
			return;

		if(m_table[tblIdx].bGameStarted)
			return;		

		/*
		int plrIdxOfHost = m_lobby->GetPlayerIdx(m_playerSockIdx);
		if(m_player[plrIdxOfHost].bIsGuest)
		{
			// [guests not able to change 'rated' option]
			char _buffer[80];
			sprintf(_buffer,"*** Option not avaliable for guests ***");
			Message(_buffer,10); // personal message			
			
		}
		else
		*/
		BOOL ok = FALSE;
		
		// Find out if we're a Member, if so, 'ok' = TRUE //
		int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
		if(plrIdx != -1)
		if(!OptionNotForGuest(m_playerSockIdx))
		if(!(m_player[plrIdx].state&PLRSTATE_GUESTMEMBER)) ok=TRUE;


		if(ok)
			{
			// For iSnooker: Only Allow Rated Button To Be Pressed if the Game Type is 15 or 10 Reds, Billiards and Semi Pro or Pro Game Types //
			if(g_build.gameType == GAMETYPE_SNOOKER)
				{
				if(m_table[tblIdx].gameType == 2 || m_table[tblIdx].gameType == 3 || m_table[tblIdx].doubles || m_table[tblIdx].cueError == 0)
					{
					char _buff[256];
					sprintf(_buff,"*** Rated Option only available for Semi Pro & Pro '15 Reds', '10 Reds' & 'Billiards' Single & Non-Wild game modes ***");
					Message(_buff,10); // personal message			
					return;
					}
				}
			// For iPool, Allow Rated Option for everything, for now //
			else{
				// Do Nothing //
				}

			//if(m_table[sd->m_tblIdx].gameType
			SendTableHostDetails(FALSE, -1, 1, -1, 0, m_playerSockIdx); // GuestMembers are allowed to change the rated.
			}
		else{
			// Option is Only for Members //
			char _buffer[80];
			sprintf(_buffer,"*** Option only avaliable for Registered Members ***");
			Message(_buffer,10); // personal message	
			}
		}
	else if(m_snooker->m_bPracticeMode)
	{
		int state = m_ratedButton.GetCheck();
		switch(state)
		{
			case 0:// toggle to ON
				m_ratedButton.SetCheck(1);
				m_snooker->m_bRated = TRUE;
				break;
			case 1:// toggle to OFF
				m_ratedButton.SetCheck(0);
				m_snooker->m_bRated = FALSE;
				break;
			case 2:
				break;
		}
	}

	#endif //!MAIN_SERVER
}

void CGameAppView::OnTableTypeBoxSelect()
{
	#ifndef MAIN_SERVER

	if(m_lobby->HostOfTable(m_playerSockIdx))
	{		
		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tblIdx == -1)
			return;

//		if(m_table[tblIdx].bGameStarted)
//			return;	
		
		/*
		int plrIdxOfHost = m_lobby->GetPlayerIdx(m_playerSockIdx);
		if(m_player[plrIdxOfHost].bIsGuest)
		{
			// [guests not able to change the table type]
			m_tableTypeBox.SetCurSel(0);
			char _buffer[80];
			sprintf(_buffer,"*** Option not avaliable for guests ***");
			Message(_buffer,10); // personal message			
			
		}
		else
		*/
		if(!OptionNotForGuest(m_playerSockIdx))
		{
			// members:
			int selectType = m_tableTypeBox.GetCurSel();
			if(selectType != m_table[tblIdx].type)
				SendTableHostDetails(FALSE, -1, 0, selectType, 0, m_playerSockIdx);
		}
		else
		{
			// reset
			m_tableTypeBox.SetCurSel(0);
		}
	}
/*	else if(m_snooker->m_bPracticeMode)
	{
		int state = m_cueErrorButton.GetCheck();
		switch(state)
		{
			case 0:// toggle to ON
				m_cueErrorButton.SetCheck(1);
				m_snooker->m_bCueError = TRUE;
				break;
			case 1:// toggle to OFF
				m_cueErrorButton.SetCheck(0);
				m_snooker->m_bCueError = FALSE;
				break;
			case 2:
				break;
		}
	}*/

	#endif //!MAIN_SERVER
}

void CGameAppView::OnButtonMissRule(void) // also 'call shot' [iPool]
{
	#ifndef MAIN_SERVER
	
	if(m_lobby->HostOfTable(m_playerSockIdx))
	{	
		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tblIdx == -1)
			return;

		if(g_bTournamentLobby)
			return;

		if(m_table[tblIdx].bGameStarted)
			return;	

		/*
		int plrIdxOfHost = m_lobby->GetPlayerIdx(m_playerSockIdx);
		if(m_player[plrIdxOfHost].bIsGuest)
		{
			// [guests not able to change 'rated' option]
			char _buffer[80];
			sprintf(_buffer,"*** Option not avaliable for guests ***");
			Message(_buffer,10); // personal message			
			
		}
		else
		*/
		BOOL ok = FALSE;
		{
		int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
		if(plrIdx != -1)
		if(m_player[plrIdx].state&PLRSTATE_GUESTMEMBER) ok=TRUE;
		}
		if(ok)
		{
		SendTableHostDetails(FALSE, -1, 0, -1, 1, m_playerSockIdx); // GuestMembers are allowed to change the rated.
		}
		else {
		if(!OptionNotForGuest(m_playerSockIdx))
		{
			// members:
			SendTableHostDetails(FALSE, -1, 0, -1, 1, m_playerSockIdx);
		}
			 }
	}
	else if(m_snooker->m_bPracticeMode)
	{
		int state = m_missRuleButton.GetCheck();
		switch(state)
		{
			case 0:// toggle to ON
				m_missRuleButton.SetCheck(1);
				m_snooker->m_bMissRule = TRUE;
				//#ifdef THE_POOL_CLUB
				m_snooker->m_bCallShot = TRUE;
				//#endif //THE_POOL_CLUB
				break;
			case 1:// toggle to OFF
				m_missRuleButton.SetCheck(0);
				m_snooker->m_bMissRule = FALSE;
				//#ifdef THE_POOL_CLUB
				m_snooker->m_bCallShot = FALSE;
				//#endif //THE_POOL_CLUB
				break;
			case 2:
				break;
		}
	}

	#endif //!MAIN_SERVER
}


/*
void CGameAppView::OnButtonSay()
{
	CString strText;

	m_sendEdit.GetWindowText(strText);
	// check if we have any text to send?
	if( !strText.GetLength() ) return;



	// Get a List of Smileys 
	IRichEditOle	*m_pRichEditOle_SE;
	m_pRichEditOle_SE = m_sendEdit.GetIRichEditOle();

	
	
	

	int n;
	int total = 0;
	int data_pos[128], data_idx[128];  // Maximum of 128 Objects //

	for(n=0;n<128;n++) 
		{
		data_pos[n] = 0;
		data_idx[n] = 0;
		}
	if (m_pRichEditOle_SE)
		{
		HRESULT hr = 0;

		//
		// Start by getting the total number of objects in the control.
		//
		int objectCount = m_pRichEditOle_SE->GetObjectCount();


		//
		// Loop through each object in the control and if active
		// deactivate, and if open, close.
		//
		for (int i = 0; i < objectCount; i++)
			{
			REOBJECT reObj;
			 ZeroMemory(&reObj, sizeof(REOBJECT));
			reObj.cbStruct  = sizeof(REOBJECT);

			//
			// Get the Nth object
			//
			hr = m_pRichEditOle_SE->GetObject(i,&reObj,REO_GETOBJ_POLEOBJ);
			if(SUCCEEDED(hr))
				{
				// Insert the Smiley Short Cut Code, back into string, so it's dispalyed in main Chat //
				data_pos[i] = reObj.cp;
				data_idx[i] = reObj.dwUser;
				total++;
				//
				// If active, deactivate.
				//
				if (reObj.dwFlags && REO_INPLACEACTIVE)
				  m_pRichEditOle_SE->InPlaceDeactivate();

				//
				// If the object is open, close it.
				//
				if(reObj.dwFlags&&REO_OPEN)
				  hr = reObj.poleobj->Close(OLECLOSE_NOSAVE);

				  reObj.poleobj->Release();
				}
			}
		m_pRichEditOle_SE->Release();
		//if(m_pRichEditOle_SE) delete m_pRichEditOle_SE;
		}

	
	// Replace the Smiley Objects, by their ASCII code, so they are processed correctly and then
	char tbuf[256];
	int iTotalTextLength;
	for(n=(total-1);n>=0;n--)
		{	
		iTotalTextLength = g_gameAppView->m_sendEdit.GetWindowTextLength();
		if(iTotalTextLength>110) break;
		m_sendEdit.SetSel(data_pos[n], data_pos[n]+1);
		m_sendEdit.ReplaceSel(smiley_lst[data_idx[n]]);
		}
	
	m_sendEdit.GetWindowText(strText);
	// check if we have any text to send?
	if( !strText.GetLength() ) return;

	strcpy(m_sendEdit.m_message, strText);

	if(!OptionNotForGuest(m_playerSockIdx, 666))
		MessageSend(m_sendEdit.m_message);
		
	strText=_T("");
	m_sendEdit.SetWindowText(strText);

	// Turn off Button //
	#ifndef MAIN_SERVER
		if(m_sendEdit.m_buttonstate) 
			{
			g_gameAppView->m_sayButton.SetBitmap(Skin_ButtonSayOff);
			m_sendEdit.m_buttonstate = FALSE;
			}
	#endif

	// Set Focus Back to sendEdit
	g_gameAppView->m_sendEdit.SetFocus();


}
*/


void CGameAppView::OnButtonSay()
{
	#ifndef MAIN_SERVER

	// We must be Level 3 or above to access this
	if(m_playerSockIdx != -1 && m_playerIdx >= 0)
	{
		if( m_player[m_playerIdx].level < m_TextColorChangerDlg.access_level ) return;
	}
	else
	{
		return;
	}


	// Make sure SmileySelect is Closed
	if(m_SmileySelectDlg)
	if(m_SmileySelectDlg.IsWindowVisible())
	{
		m_SmileySelectDlg.DestroyWindow();
	}

	if(m_TextColorChangerDlg)
	if(m_TextColorChangerDlg.IsWindowVisible())
	{
		return;
	}

	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view
	int excess_w = m_cx - (squareHeight + (72*2 + 19));
	int initial_w = (300+40) + (100+g_FIX_shiftX-40);
	g_FIX_SpareW = excess_w - initial_w;
	if(g_FIX_SpareW < 0) g_FIX_SpareW = 0;
			
	CRect tmpRect;
	CSize tmpSize;
	CPoint tmpPoint;

	m_sayButton.GetWindowRect(&tmpRect);

	m_TextColorChangerDlg.DestroyWindow();
	m_TextColorChangerDlg.Create(IDD_TEXTCOLORCHANGER);
	m_TextColorChangerDlg.Init();
	
	m_TextColorChangerDlg.SetWindowPos(&wndTop, tmpRect.left-227, tmpRect.top - 102, 256, 100, SWP_SHOWWINDOW);
	m_TextColorChangerDlg.ShowWindow(SW_SHOW);

	#endif
}

void CGameAppView::OnButtonSmileySelect()
{
#ifndef MAIN_SERVER



	// Close TextColorChanger Button
	if(m_TextColorChangerDlg)
	if(m_TextColorChangerDlg.IsWindowVisible())
	{
		m_TextColorChangerDlg.DestroyWindow();
	}

	if(m_SmileySelectDlg)
	if(m_SmileySelectDlg.IsWindowVisible())
	{
		return;
	}

	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view
	int excess_w = m_cx - (squareHeight + (72*2 + 19));
	int initial_w = (300+40) + (100+g_FIX_shiftX-40);
	g_FIX_SpareW = excess_w - initial_w;
	if(g_FIX_SpareW < 0) g_FIX_SpareW = 0;
				

	
	CRect tmpRect;
	CSize tmpSize;
	CPoint tmpPoint;
	
	
	m_SmileySelectDlg.DestroyWindow();
	m_SmileySelectDlg.Create(IDD_SMILEYSELECT);
	m_SmileySelectDlg.Init();

		
	// Smiley Select Dialog //
	/*m_SmileySelectDlg.GetWindowRect(&tmpRect);
	tmpSize = tmpRect.Size();
	tmpPoint =  tmpRect.TopLeft();
	*/
	m_sayButton.GetWindowRect(&tmpRect);
	

	
	m_SmileySelectDlg.SetWindowPos(&wndTop, tmpRect.left-200, tmpRect.top - 181, 250, 180, SWP_SHOWWINDOW);
	m_SmileySelectDlg.ShowWindow(SW_SHOW);
	
	
	//if(m_lobby->m_bInLobby) m_smileyselectButton.SetWindowPos(&wndTop, 0+100+58, m_cy-100-20 + offsetY*0.5f - 200, 400, 200, SWP_SHOWWINDOW);
	//	else m_SmileySelectDlg.SetWindowPos(&wndTop, 388-offsetX-g_FIX_shiftX-g_FIX_SpareW + 15 +58, (int)(435-ceil(offsetX*0.5f)-g_yBarOffset)-200, 400, 200, SWP_SHOWWINDOW);
	
	/////////////////
	
	
#endif 		

		
}



// This Function is called up when the User Clicks on the View Tables Button in the Lobby //
// When called up, the Message Board will be changed to the Tables View and Updated //

void CGameAppView::OnButtonViewTables()
{
	
	g_tabSelected = 0;	// Lobby TV / HTML Board //

	if(m_bLobbyMode == 0)	
		{
		// If we're in Message-Board Mode, then we need to change to Tables Mode //
		m_bLobbyMode = 1;				// 0: Default Mode, Message-Board is On, 1: Playing Mode, Tables is On //
		// Hide - Inactivate MB //
		//m_htmlViewMB.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		m_viewtablesButton.SetBitmap(Skin_ButtonViewTables[1]);		// 'View MessageBoard' button //
		}
	else{					
		// If we're in Tables Mode, then we need to Toggle Back to Message-Board Mode //
		m_bLobbyMode = 0;				// 0: Default Mode, Message-Board is On, 1: Playing Mode, Tables is On //
		m_viewtablesButton.SetBitmap(Skin_ButtonViewTables[0]);		// 'Click Here To View Tables' button //
		}

	// Hide all Table Buttons, so when it's refreshed, only the buttons in view are shown //
	m_listTables.HideAllButtons();
	// Refresh Lobby
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

}

// This Button will Change the Message-Board or Table List to the Lobby Select 
void CGameAppView::OnButtonChangeLobby()
{
#ifndef MAIN_SERVER
	m_bLobbyMode = 1;				// 0: Default Mode, Message-Board is On, 1: Playing Mode, Tables is On //
	// Hide - Inactivate MB //


	g_tabSelected = 1;	// Lobby Select //
	m_tabLobbyCtrlEx.m_bSelChanged = TRUE;	// Used for Lobby Select Timing //
		
	m_htmlViewMB.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	// m_listTables.SetWindowPos(&wndTop,  0, 0, 0, 0, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	
	// Update the Description Width, since we're in lobby viewing Lobby List and have less space
	m_lobbySelectDlg.m_listLobbies.SetColumnWidth(1, 220);

	// Refresh Lobby
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);


	if(m_lobbySelectDlg.m_listLobbies.m_totalItems == 0)
		{		
		CString cstr[4];
		cstr[0] = "Searching...";
		cstr[1] = "";
		cstr[2] = "";
		cstr[3] = "";
		m_lobbySelectDlg.m_listLobbies.CreateItem(0, cstr);
		}

	// Refresh Lobby List //
	OnButtonRefresh();
#endif
}

// This toggles message-board / Lobby TV to full and not
void CGameAppView::OnButtonMBFullLobby()
{
#ifndef MAIN_SERVER
	//m_bLobbyMode = 0;				// 0: Default Mode, Message-Board is On, 1: Playing Mode, Tables is On //
	// Hide - Inactivate MB //

	if(m_bFullMode) 
	{
		m_bFullMode = false;
	}
	else
	{
		m_bFullMode = true;
	}
	
	
	
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	
	if(m_bLobbyMode == 2) m_bUpdateTable = true;


#endif
}


void CGameAppView::OnButtonHome()
{
#ifndef MAIN_SERVER
	m_bLobbyMode = 1;				// 0: Default Mode, Message-Board is On, 1: Playing Mode, Tables is On //
	g_tabSelected = 0;
	
	m_viewtablesButton.SetBitmap(Skin_ButtonViewTables[0]);		// 'Click Here To View Tables' button /
	// Refresh Lobby


	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	// Load the Home Page - Message Board //
	m_htmlViewMB.Navigate2(g_lobbyMessageBoard, NULL, NULL);
#endif
}

void CGameAppView::OnButtonRegister()
{
#ifndef MAIN_SERVER
	m_bLobbyMode = 1;				// 0: Default Mode, Message-Board is On, 1: Playing Mode, Tables is On //
	g_tabSelected = 0;
	m_viewtablesButton.SetBitmap(Skin_ButtonViewTables[0]);		// 'Click Here To View Tables' button /
	// Refresh Lobby
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_htmlViewMB.Navigate2(g_lobbyRegister, NULL, NULL);
#endif
}


void CGameAppView::OnButtonLeagues()
{
#ifndef MAIN_SERVER
	m_bLobbyMode = 1;				// 0: Default Mode, Message-Board is On, 1: Playing Mode, Tables is On //
	g_tabSelected = 0;
	m_viewtablesButton.SetBitmap(Skin_ButtonViewTables[0]);		// 'Click Here To View Tables' button /
	// Refresh Lobby
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_htmlViewMB.Navigate2(g_lobbyLeague, NULL, NULL);
#endif	
}


void CGameAppView::OnButtonTourneys()
{
#ifndef MAIN_SERVER
	m_bLobbyMode = 1;				// 0: Default Mode, Message-Board is On, 1: Playing Mode, Tables is On //
	g_tabSelected = 0;
	m_viewtablesButton.SetBitmap(Skin_ButtonViewTables[0]);		// 'Click Here To View Tables' button /
	// Refresh Lobby
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	m_htmlViewMB.Navigate2(g_lobbyTournament, NULL, NULL);
#endif
}


void CGameAppView::OnButtonRefresh()
{
	ButtonRefresh();
}


void CGameAppView::ButtonRefresh()
{

#ifndef MAIN_SERVER

	if(!m_refreshButtonEnabled) return;
	//if(g_tabSelected == 1) m_lobbyRefreshDelay = 0;

	if(m_lobby->m_bInLobby)
	if(!m_lobbyRefreshDelay)
	{
		//int tabSelected = m_tabLobbyCtrlEx.GetCurSel();
		if(g_tabSelected == 0) // [Tbls / Msg]
		{
			m_lobbyRefreshDelay = 20;//60*2; // approx. 1 min delay intervals
			m_htmlViewMB.Refresh2(REFRESH_COMPLETELY);
		}
		else if(g_tabSelected == 1) // [Lobby Select]
		{
			m_lobbyRefreshDelay = 20;//60*2; // approx. 1 min delay intervals
			m_connectStyle = CONNECTSTYLE_NORMAL;
			//ConnectToLobby(TRUE);
		}
		/*
		else if(tabSelected == 2)// [Leagues]
		{
			m_lobbyRefreshDelay = 60*2; // approx. 1 min delay intervals
			m_tableTabCtrlDlg.m_htmlViewLeague.Refresh2(REFRESH_COMPLETELY);
		}
		else if(tabSelected == 3)// [Tournaments]
		{
			m_lobbyRefreshDelay = 60*2; // approx. 1 min delay intervals
			m_tableTabCtrlDlg.m_htmlViewTourney.Refresh2(REFRESH_COMPLETELY);
		}
	
		else if(tabSelected == 4)// [Lobby Select]
		{
			m_lobbyRefreshDelay = 60*2; // approx. 1 min delay intervals
			m_connectStyle = CONNECTSTYLE_NORMAL;
			ShowTerms(); // This Function Calls up ConnectToLobby if User Agrees with Terms - ConnectToLobby(TRUE);
		}
		*/
	}
#endif
}

void CGameAppView::OnButtonEnterLobby()
{
	if(m_lobby->m_bInLobby)
	{
		//ErrorMessage(this, "OnButtonEnterLobby");
		int tabSelected = m_tabLobbyCtrlEx.GetCurSel();
		if(tabSelected == 4)// [Lobby Select]
			m_lobbySelectDlg.Select();	
	}
}

void CGameAppView::OnButtonServerConfig()
{
	#ifdef MAIN_SERVER
	m_serverConfigDlg.DestroyWindow();
	m_serverConfigDlg.Create(IDD_SERVERCONFIG);
	m_serverConfigDlg.ShowWindow(SW_SHOW);	
	#endif //MAIN_SERVER
}

void CGameAppView::OnButtonAccountConfig()
{
	#ifdef MAIN_SERVER
  	m_accountConfigDlg.DestroyWindow();
	m_accountConfigDlg.Create(IDD_ACCOUNTCONFIG);
	m_accountConfigDlg.ShowWindow(SW_SHOW);	
	#endif //MAIN_SERVER
}

void CGameAppView::OnButtonLobbyStat()
{
	#ifdef MAIN_SERVER
	// Display lobby stat dialogue
	g_lobbystat->Appear();
	#endif //MAIN_SERVER
}

void CGameAppView::OnHelpMessage()
{

	#ifdef TEST_BOT

	/////////////////////////////////////////////////////////////
	//char buf[80];
	//sprintf(buf, "-- (START) m_snooker->m_colourseq = %d ---", m_snooker->m_colourseq);
	//ErrorMessage(this, buf);
	/////////////////////////////////////////////////////////////
	
	m_bot->Init("AIBot1", 1200, Flg_TYPE_NORMAL);
	//m_bot->m_bStatus^=1;
	if(m_bot->m_bStatus) Message("Test Bot Activated!", 40);
	else Message("Test Bot De-Activated!", 40);
	return;

	#endif //TEST_BOT

	// if strike is in progress - don't update mouse data
	#ifndef MAIN_SERVER
				 
	//if(g_build.gameType == GAMETYPE_POOL)
	{
		if( m_snooker->m_cueBallSelect == 10 ||
			m_snooker->m_cueBallSelect == 9 ||
			m_snooker->m_cueBallSelect == 2 ||
			m_snooker->m_cueBallSelect >= 20)
			return;
		
		if(m_notePadDlg.m_hWnd)
		if(m_notePadDlg.IsWindowVisible()) return;

		//int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		//if(tblIdx != -1)
		
		if( m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 || m_snooker->m_bPracticeMode)
		{
			if(g_build.gameType == GAMETYPE_POOL)
			{
				switch(m_snooker->m_customTable->m_type)//m_table[tblIdx].gameType)
				{
				case CTTYPE_8BALL: // 8-Ball
				m_notePadDlg.TitleAndFilename("8-Ball Rules / Controls", "help/8BallRules.txt");
				break;
				case CTTYPE_9BALL: // 9-ball
				m_notePadDlg.TitleAndFilename("9-Ball Rules / Controls", "help/9BallRules.txt");
				break;
				case CTTYPE_ROTATIONBALL: // Rotation Ball
				m_notePadDlg.TitleAndFilename("Rotation Ball Rules / Controls", "help/RotationBallRules.txt");
				break;
				case CTTYPE_BOWLS: // Bowls
				m_notePadDlg.TitleAndFilename("Bowls Rules / Controls", "help/BowlsRules.txt");
				break;
				case CTTYPE_6BALL: // 6-ball
				m_notePadDlg.TitleAndFilename("6-Ball Rules / Controls", "help/6BallRules.txt");
				break;
				case CTTYPE_10BALL: // 10-ball
				m_notePadDlg.TitleAndFilename("10-Ball Rules / Controls", "help/10BallRules.txt");
				break;
				case CTTYPE_UKPOOL: // UK POOL
				m_notePadDlg.TitleAndFilename("8-Ball Rules / Controls", "help/UKPoolRules.txt");
				break;
				case CTTYPE_BREAK: // Pool Snooker Game Type
				m_notePadDlg.TitleAndFilename("Break Rules / Controls", "help/BreakRules.txt");
				break;
				}
			}
			else if(g_build.gameType == GAMETYPE_SNOOKER)
			{
				switch(m_snooker->m_customTable->m_type)//m_table[tblIdx].gameType)
				{
				case CTTYPE_SNOOKER: // Snooker (15 reds)
				case CTTYPE_SNOOKER10: // Snooker (10 reds)
				case CTTYPE_SNOOKER6: // Snooker (6 reds)
				case CTTYPE_RESPOTBLACK: // Snooker (Re-Spot Black)
						m_notePadDlg.TitleAndFilename("Snooker Rules / Controls", "help/SnookerRules.txt");
						break;
				case CTTYPE_BILLIARDS: // Snooker (Billiards)
					m_notePadDlg.TitleAndFilename("Billiards Rules / Controls", "help/BilliardsRules.txt");
						break;
				}
			}
					
			m_notePadDlg.DestroyWindow();
			m_notePadDlg.Create(IDD_NOTEPAD);
			m_notePadDlg.ShowWindow(SW_SHOW);
		}
	}

	#endif //!MAIN_SERVER
}
	


BOOL CGameAppView::OnEraseBkgnd(CDC* pDC) 
{
	// TODO: Add your message handler code here and/or call default
	return 0;
	//return CView::OnEraseBkgnd(pDC);
}

// messages received
void CGameAppView::Message(LPCTSTR lpszMessage, int messageID, int plrSockIdx, COLORREF col, int senderLevel)
{
		
	int plrIdx, i;
	BOOL bColourAdjust = FALSE;
	BOOL bIsMsg = FALSE;
	BOOL bSkipLineScroll = FALSE;
	//strcpy(m_message, lpszMessage);
	
	CString strTemp = lpszMessage;

	

	if(messageID >= 0) // note: messageID must not be -ve number if you want newline-CR appended to string
		strTemp += _T("\r\n");
	else bSkipLineScroll = TRUE;

	int len = GetWindowTextLength(); // ??? not sure why this is here (Not Used!!!)
	int strLength = strTemp.GetLength();	

#ifdef MAIN_SERVER
#ifndef TEST_SERVER

	// Add Time / Date for each Log
	char _buffer[MAX_CHARS];
	char *timestr;

	// Get (Local) time
	GetTime();
	timestr = m_stringTimeStamp.GetBuffer(0);

	if(messageID >= 0)
	{
		// Add the "->" part to messages when we log it
		sprintf(_buffer, "%s -> %s", timestr, (char *) lpszMessage);
		AddLog("LogChat.txt", _buffer);
	}
	
#endif // !TEST_SERVER
#endif // MAIN_SERVER

#ifndef MAIN_SERVER
	m_recentLog->AddStr((char *)lpszMessage);
#endif
	



#ifndef MAIN_SERVER   /// New Code, to fix Memory Leak 1 //////

	CHARFORMAT2 cf;
	::ZeroMemory(&cf, sizeof(CHARFORMAT2));
	cf.cbSize = sizeof(CHARFORMAT2);
	m_editExChat.GetSelectionCharFormat(cf);



	cf.dwMask = CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR | CFM_BOLD | CFM_FACE | CFM_SIZE;
	cf.dwEffects = 0;//CFE_BOLD;
	
	int TextColorMain;
	int TextColorMsg;

	if(g_gfxDetails.bDefaultColorScheme == TRUE) 
		{
		TextColorMain = RGB(220,220,220);
		TextColorMsg = RGB(180,180,180);
		}
	else{
		TextColorMain = RGB(20,20,20);
		TextColorMsg = RGB(60,60,60);
		}

	 

	cf.crTextColor = TextColorMain;
	strcpy(cf.szFaceName, "Compact");

	if(messageID == -1) // apply colour adjust from normal
	{
		bColourAdjust = TRUE;
		messageID = 0; // force back to default param.
	}
	else if(messageID == -2) // /msg '->'
	{
		bColourAdjust = TRUE;
		bIsMsg = TRUE;
		messageID = 0; // force back to default param.
	}
	else if(messageID <= -10) // apply colour adjust from normal
	{
		messageID *= -1;
	}
			
	// check for own player chat text
	if(!messageID)
	{
		// normal text
		if(!bColourAdjust) cf.crTextColor = TextColorMain;
		// '> '
		else 
		{
			if(!bIsMsg) cf.crTextColor = TextColorMsg;
			else  cf.crTextColor = TextColorMsg;
			cf.dwEffects = CFE_ITALIC;
		}

		if(plrSockIdx!=-1) // online code - Note: this messed up practice mode comments, made it black!
		{



			// special admin code here
			plrIdx = m_lobby->GetPlayerIdx(plrSockIdx);
			if(plrIdx == -1) return;

			// Members Defaultly get normal text, Mods/Admins get Bold by default //
			if(!(m_player[plrIdx].state&PLRSTATE_AUTHMASK)) 
				{
				strcpy(cf.szFaceName, "Arial");
				cf.crTextColor = TextColorMain;
				cf.yHeight = 215;
				}
			else 
				{
				strcpy(cf.szFaceName, "Arial Bold");
				cf.crTextColor = TextColorMain;
				cf.yHeight = 200;
				}
		

			if(m_player[plrIdx].status)
			if (m_player[plrIdx].bIsGuest == false)
			// if ((m_player[plrIdx].state&PLRSTATE_AUTHMASK)) // Allow Trialists and above to use coloured text
			// if( (m_player[plrIdx].state&PLRSTATE_AUTHMASK) || !(m_player[plrIdx].state&PLRSTATE_GUESTMEMBER))
			{		
						
				cf.dwEffects = 0;

				if( (m_player[plrIdx].textFormat&TEXTFORMAT_DEFAULT) ) cf.dwEffects  = 0;
				
				/*
				// normal text
				if(!bColourAdjust) {
									if(g_gfxDetails.bDefaultColorScheme == TRUE)
										{
										if(m_player[plrIdx].textFormat&0x08) cf.crTextColor = tfmt_colorrgb_lsta[16+((m_player[plrIdx].textFormat>>4)&0xf)]; // set color according to the lut
											else cf.crTextColor = tfmt_colorrgb_lsta[(m_player[plrIdx].textFormat>>4)&0xf]; // set color according to the lut
										}
									else{
										if(m_player[plrIdx].textFormat&0x08) cf.crTextColor = tfmt_colorrgb_lsta[16+((m_player[plrIdx].textFormat>>4)&0xf)]; // set color according to the lut
											else cf.crTextColor = tfmt_colorrgb_lsta[(m_player[plrIdx].textFormat>>4)&0xf]; // set color according to the lut
										}
									}
				// '> '
				else 
				{
					if(m_player[plrIdx].textFormat&0x08) cf.crTextColor = tfmt_colorrgbadjust_lst[16+((m_player[plrIdx].textFormat>>4)&0xf)]; // set color according to the lut
					else cf.crTextColor = tfmt_colorrgbadjust_lst[(m_player[plrIdx].textFormat>>4)&0xf]; // set color according to the lut
					//cf.dwEffects = CFE_ITALIC;
				}
				*/
		
				cf.crTextColor = col;
					


				//if( (m_player[plrIdx].textFormat&TEXTFORMAT_BLUE) ) cf.crTextColor = RGB(74,74,255);
				//else if( (m_player[plrIdx].textFormat&TEXTFORMAT_GREEN) ) cf.crTextColor = RGB(20,255,20);
				//else if( (m_player[plrIdx].textFormat&TEXTFORMAT_ORANGE) ) cf.crTextColor = RGB(255,128,20);

				if( (m_player[plrIdx].textFormat&TEXTFORMAT_ITALIC) ) cf.dwEffects |= CFE_ITALIC;
				//if( (m_player[plrIdx].textFormat&TEXTFORMAT_UNDERLINE) ) cf.dwEffects |= CFE_UNDERLINE;

				if( (m_player[plrIdx].textFormat&TEXTFORMAT_COMIC) ) 
					{
					strcpy(cf.szFaceName, "Comic Sans MS");
					cf.dwEffects = CFE_BOLD;
					}
				if( (m_player[plrIdx].textFormat&TEXTFORMAT_BOLD) ) 
					{
					strcpy(cf.szFaceName, "Arial Black");
					cf.dwEffects = CFE_BOLD;
					}
						
			}
		}
	}
	// check for other players chat text
	else if(messageID == 1)
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(100,100,215);
			else cf.crTextColor = RGB(10,10,21);
		cf.dwEffects = 0;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}
	// check for system commands!
	else if(messageID == 10)
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(255,0,0);
			else cf.crTextColor = RGB(190,0,0);
		cf.dwEffects = 0;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}
	// Game Over Rating 
	else if(messageID == 11) 
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(239,150,71);
			else cf.crTextColor = RGB(239,150,71);
		cf.dwEffects = 0;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}

	// Game Over vCash / Level XP messages
	else if(messageID == 12) 
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(239,177,71);
			else cf.crTextColor = RGB(239,177,71);
		cf.dwEffects = 0;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}
	// Game Over Ladder Points
	else if(messageID == 13) 
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(239,150,71);
		else cf.crTextColor = RGB(108,215,121);
		cf.dwEffects = 0;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}

	// check server message
	else if(messageID == 20)
	{
		cf.crTextColor = RGB(0,115,0);
		cf.dwEffects = 0;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}
	// check game/lobby accessible server message e.g /msg!
	else if(messageID == 30)
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(140,140,140);
			else cf.crTextColor = RGB(50,50,50);
		cf.dwEffects = CFE_ITALIC;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}
	// check game/lobby accessible server message e.g error incorrect command etc.
	else if(messageID == 40)
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(150,150,150);
			else cf.crTextColor = RGB(55,55,55);
		cf.dwEffects = CFE_ITALIC;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}
	else if(messageID == 50) // important error messages
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(230,40,250);
			else cf.crTextColor = RGB(90,10,110);		
		//cf.dwEffects = CFE_BOLD|CFE_UNDERLINE;
		cf.dwEffects = 0;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}
	else if(messageID == 60) // Announcement text (i.e. high breaks, top 16 players entering lobby, etc)
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(255,148,40);
			else cf.crTextColor = RGB(0,128,128);
		cf.dwEffects = 0;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}
	else if(messageID == 70) // Admin Announcement text (i.e. for text to stand out more)
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(200,200,200);
			else cf.crTextColor = RGB(10,10,10);
		//cf.dwEffects = CFE_BOLD|CFE_UNDERLINE;
		cf.dwEffects = 0;
		cf.dwEffects = CFE_ITALIC;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;

	}
	else if(messageID == 80)
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(255,162,99);
			else cf.crTextColor = RGB(155,62,29);
		cf.dwEffects = CFE_ITALIC;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}
	else if(messageID == 90)
	{
		if(g_gfxDetails.bDefaultColorScheme == TRUE) cf.crTextColor = RGB(235,180,14);
			else cf.crTextColor = RGB(235,180,14);
		cf.dwEffects = 0;
		strcpy(cf.szFaceName, "Arial Bold");
		cf.yHeight = 200;
	}


	// Find out if we need to move the scrollbar down to the latest chat //
	// This should be done before any new text is added //
	
	bool bScrollBottom = false;
	if(!bSkipLineScroll)
	{
		int pos,limit;

		limit = m_editExChat.GetScrollLimit(1);
		pos = m_editExChat.GetScrollPos(1);

		if(g_gameAppView)	
		{
			if( (plrSockIdx == g_gameAppView->m_playerSockIdx) || (pos > (limit-20)) )
			{
				// set bScrollBottom flag to true //
				bScrollBottom = true;
			}
		}
	}


	cf.cbSize = sizeof(cf);
	int nBegin = m_editExChat.GetTextLength();
	int iStartPos = nBegin;
	m_editExChat.SetSel(nBegin, nBegin); 
	m_editExChat.SetSelectionCharFormat(cf);
	//m_editExChat.ReplaceSel(strTemp); 
	


	//nBegin = m_editExChat.GetTextLength(); // Get New Length
	//m_editExChat.ScrollWindow(0, 1000000000); // ugly scroll to end hack :D
	//m_editExChat.SetSel(nBegin , nBegin );    // No more selection?
 
#ifdef SMILEYS_ENABLED
	IRichEditOle	*m_pRichEditOle_G;
	m_pRichEditOle_G = m_editExChat.GetIRichEditOle();
	ASSERT(m_pRichEditOle_G != NULL);

	
	// Only do if the m_pRichEditOle is Valid //


	if(m_pRichEditOle_G != NULL)
		{	
		gstr = new char[strlen(strTemp)+1];
		strcpy(gstr, strTemp);

		smiley_data.smiley_offset = 0;
		smiley_data.smiley_adjust = 0;
		

		// Skip to the first ':' in the string so we don't change anything in the Username //
		for(i=0;i<strlen(gstr);i++)
		if(gstr[i]==':') 
			{
			smiley_data.smiley_offset = i;
			break;
			}

		
		int spos[32], epos[32], offset[32], type[32];

		int totalsmileys = 0;
		int level = 99;
		
		if(senderLevel != -1)
		{
			level = senderLevel;
		}
		else
		{
			if(plrSockIdx !=-1) level = m_player[plrIdx].level;
		}

		for(i=0;i<32;i++)
		{
			if(GET_SMILEYS(&smiley_data, level))
			{
				spos[totalsmileys] = smiley_data.smiley_spos;
				epos[totalsmileys] = smiley_data.smiley_epos;
				offset[totalsmileys] = smiley_data.smiley_offset;
				type[totalsmileys] = smiley_data.smiley_type;
				totalsmileys++;
			}
		}

		// Draw any text prior to the Smileys //
		if(!totalsmileys) m_editExChat.ReplaceSel(strTemp);
		else
		{
			// we have some smileys //
			int len = 0;
			int start = 0;
			int n;
			char tstr[512];
			for(n=0;n<totalsmileys;n++)
			{
				// Get any Text Prior to Smiley //
				int idx = 0;
				for(i=start;i<spos[n];i++)
				{
					tstr[idx] = gstr[i];
					idx++;
				}
				
				tstr[idx] = 0;
				len = strlen(tstr);
				if(len)
				{
					nBegin = m_editExChat.GetTextLength();
					m_editExChat.SetSel(nBegin, nBegin);
					m_editExChat.SetSelectionCharFormat(cf);
					m_editExChat.ReplaceSel(tstr);
					start += len;
				}

				// Draw Smiley //
				nBegin = m_editExChat.GetTextLength();
				m_editExChat.SetSel(nBegin, nBegin);
				if(CImageDataObject::InsertBitmap(m_pRichEditOle_G, smiley[type[n]], type[n]))
				{
					start += (epos[n] - spos[n]);
				}
			}

			// Check if there's any text left to draw after the final Smiley //
			// Get any Text Prior to Smiley //
			int idx = 0;
			for(i=start;i<strlen(gstr);i++)
			{
				tstr[idx] = gstr[i];
				idx++;
			}
			
			tstr[idx] = 0;
			len = strlen(tstr);
			if(len)
			{
				nBegin = m_editExChat.GetTextLength();
				m_editExChat.SetSel(nBegin, nBegin);
				m_editExChat.SetSelectionCharFormat(cf);
				m_editExChat.ReplaceSel(tstr);
			}
		}


		if(gstr) delete gstr;
		}

		m_pRichEditOle_G->Release();
		//if(m_pRichEditOle_G) delete m_pRichEditOle_G;
#else

	m_editExChat.ReplaceSel(strTemp); 

#endif

	m_editExChat.HideSelection(TRUE, FALSE);	




	if(bScrollBottom) m_editExChat.PostMessage(WM_VSCROLL, SB_BOTTOM, 0);

	/*
	if(!bSkipLineScroll)
		m_editExChat.LineScroll(1);
	*/
#endif


	// note: need to make an AddText(... here
}


// find every pixel of the default background color in the specified
// bitmap and set each one to the user's button color.
static void	ReplaceBackgroundColor (CBitmap& ioBM)
{
 // figure out how many pixels there are in the bitmap
 BITMAP		bmInfo;

 VERIFY (ioBM.GetBitmap (&bmInfo));

 // add support for additional bit depths if you choose
 VERIFY (bmInfo.bmBitsPixel == 24);
 VERIFY (bmInfo.bmWidthBytes == (bmInfo.bmWidth * 3));

 const UINT		numPixels (bmInfo.bmHeight * bmInfo.bmWidth);

 // get a pointer to the pixels
 DIBSECTION  ds;

 VERIFY (ioBM.GetObject (sizeof (DIBSECTION), &ds) == sizeof (DIBSECTION));

 RGBTRIPLE*		pixels = reinterpret_cast<RGBTRIPLE*>(ds.dsBm.bmBits);
 VERIFY (pixels != NULL);

 // get the user's preferred button color from the system
 const COLORREF		buttonColor (::GetSysColor (COLOR_BTNFACE));
 const RGBTRIPLE		userBackgroundColor = {
 GetBValue (buttonColor), GetGValue (buttonColor), GetRValue (buttonColor)};

 // search through the pixels, substituting the user's button
 // color for any pixel that has the magic background color
 for (UINT i = 0; i < numPixels; ++i)
 {
  if (pixels [i].rgbtBlue == 255
  && pixels [i].rgbtGreen == 255
  && pixels [i].rgbtRed == 255)
  {
   pixels [i] = userBackgroundColor;
  }
 }
}


void LOAD_ABUSE(void)
{
/*
	abuse_lst_n = 0;
	abuse_lst = new char *[2];
	
	abuse_lst[0] = new char[strlen("fuck")+1];
	strcpy(abuse_lst[0], "fuck");
	abuse_lst_n++;

	abuse_lst[1] = new char[strlen("shit")+1];
	strcpy(abuse_lst[1], "shit");
	abuse_lst_n++;
*/	
}

void LOAD_SMILEYS(void)
{
// Trick to align the Text with Smiley Image in sendEdit, before smiley image is used //
smiley_empty	= (HBITMAP)LoadImage(0, "Graphics/Smileys/empty.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);


if(g_gfxDetails.bDefaultColorScheme == TRUE)
	{
	smiley[0]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/smile.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[1]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/wink.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[2]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/laugh.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[3]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/sad.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[4]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/shock.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[5]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/slap.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[6]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/mad.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[7]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/tongue.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[8]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/puzzled.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[9]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/cool.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[10]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/blush.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[11]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/surprise.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[12]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/cry.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[13]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/biggrin.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[14]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/mischief.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[15]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/mouth.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[16]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/girl.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[17]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/devil.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[18]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/pleased.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[19]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/e/santa.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[20]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/pirate.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[21]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/sad.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[22]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/santa.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[23]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/sleep.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[24]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/sly.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[25]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/smile.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[26]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/tongue.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[27]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/unsure.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[28]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/whistle.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[29]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/wink.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[30]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/woot.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[31]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/wub.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[32]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/a/swear_filter.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	}
else{
	smiley[0]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/smile.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[1]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/wink.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[2]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/laugh.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[3]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/sad.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[4]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/shock.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[5]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/slap.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[6]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/mad.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[7]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/tongue.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[8]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/puzzled.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[9]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/cool.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[10]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/blush.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[11]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/surprise.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[12]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/cry.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[13]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/biggrin.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[14]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/mischief.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[15]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/mouth.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[16]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/girl.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[17]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/devil.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[18]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/please.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[19]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/f/santa.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[20]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/pirate.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[21]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/sad.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[22]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/santa.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[23]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/sleep.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[24]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/sly.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[25]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/smile.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[26]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/tongue.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[27]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/unsure.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[28]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/whistle.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[29]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/wink.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[30]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/woot.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	smiley[31]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/wub.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

	smiley[32]		= (HBITMAP)LoadImage(0, "Graphics/Smileys/b/swear_filter.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	}
//

}






void LOAD_SKIN(void)
{
Skin_ButtonSayOn			= (HBITMAP)LoadImage(0, "Graphics/skin/button_textcolor_mo.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonSayOff			= (HBITMAP)LoadImage(0, "Graphics/skin/button_textcolor.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonSmiley			= (HBITMAP)LoadImage(0, "Graphics/skin/button_smiley.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonSmiley2			= (HBITMAP)LoadImage(0, "Graphics/skin/button_smiley2.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonExitLobby		= (HBITMAP)LoadImage(0, "Graphics/skin/button_exitlobby.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonChangeLobby		= (HBITMAP)LoadImage(0, "Graphics/skin/button_changelobby.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonMBFullLobby		= (HBITMAP)LoadImage(0, "Graphics/skin/ChangeSizeBtn.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonMsgBoardTabOn[0]	= (HBITMAP)LoadImage(0, "Graphics/skin/button_home_on.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonMsgBoardTabOff[0]= (HBITMAP)LoadImage(0, "Graphics/skin/button_home_off.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonMsgBoardTabOn[1]	= (HBITMAP)LoadImage(0, "Graphics/skin/button_register_on.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonMsgBoardTabOff[1]= (HBITMAP)LoadImage(0, "Graphics/skin/button_register_off.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonMsgBoardTabOn[2]	= (HBITMAP)LoadImage(0, "Graphics/skin/button_tourneys_on.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonMsgBoardTabOff[2]= (HBITMAP)LoadImage(0, "Graphics/skin/button_tourneys_off.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonMsgBoardTabOn[3]	= (HBITMAP)LoadImage(0, "Graphics/skin/button_leagues_on.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonMsgBoardTabOff[3]= (HBITMAP)LoadImage(0, "Graphics/skin/button_leagues_off.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonRefresh			= (HBITMAP)LoadImage(0, "Graphics/skin/button_refresh.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
// Game Table Button //
Skin_ButtonG[0]				= (HBITMAP)LoadImage(0, "Graphics/skin/button_gstart.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonG[1]				= (HBITMAP)LoadImage(0, "Graphics/skin/button_grerack.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonG[2]				= (HBITMAP)LoadImage(0, "Graphics/skin/button_gconcede.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonG[3]				= (HBITMAP)LoadImage(0, "Graphics/skin/button_gexit.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonG[4]				= (HBITMAP)LoadImage(0, "Graphics/skin/button_gundo.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonG[5]				= (HBITMAP)LoadImage(0, "Graphics/skin/button_ginvite.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonG[6]				= (HBITMAP)LoadImage(0, "Graphics/skin/button_gboot.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonG[7]				= (HBITMAP)LoadImage(0, "Graphics/skin/button_gsetup.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonG[8]				= (HBITMAP)LoadImage(0, "Graphics/skin/button_gstand.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);


Skin_ButtonViewTables[0]	= (HBITMAP)LoadImage(0, "Graphics/skin/button_viewtables.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
Skin_ButtonViewTables[1]	= (HBITMAP)LoadImage(0, "Graphics/skin/button_viewmsgb.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);


// Chat Area Skinning //


#ifndef THE_POOL_CLUB		
		BitmapSkin[SKIN_TABLEBUTTONS] = (HBITMAP)LoadImage(0, "Graphics/skin/tablebtnswood.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);		
		BitmapSkin[SEMIPROHIGHBREAKSBG_LEFT] = (HBITMAP)LoadImage(0, "Graphics/skin/semiprohighbreaksbg.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);		
		BitmapSkin[PROHIGHBREAKSBG_LEFT] = (HBITMAP)LoadImage(0, "Graphics/skin/prohighbreaksbg.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
#else
		BitmapSkin[SKIN_TABLEBUTTONS] = (HBITMAP)LoadImage(0, "Graphics/skin/tablebtnswood_ipool.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);		
		BitmapSkin[SEMIPROHIGHBREAKSBG_LEFT] = (HBITMAP)LoadImage(0, "Graphics/skin/8ballmostrunoutsbg.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[PROHIGHBREAKSBG_LEFT] = (HBITMAP)LoadImage(0, "Graphics/skin/9ballmostrunoutsbg.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
#endif
			
		if(g_gfxDetails.bDefaultColorScheme == TRUE)
		{
			BitmapSkin[SKIN_CHATEDITLEFTT] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatleftta.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
			BitmapSkin[SKIN_CHATEDITLEFTM] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatleftma.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
			BitmapSkin[SKIN_CHATEDITLEFTB] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatleftba.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		}
		else
		{
			BitmapSkin[SKIN_CHATEDITLEFTT] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatlefttb.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
			BitmapSkin[SKIN_CHATEDITLEFTM] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatleftmb.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
			BitmapSkin[SKIN_CHATEDITLEFTB] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatleftbb.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		}

		BitmapSkin[SKIN_CHATEDITTOP1] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chattop1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_CHATEDITMID1] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatmid1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_CHATEDITMID2] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatmid2.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_CHATEDITMID3] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatmid3.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_CHATEDITMID4] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatmid4.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_CHATEDITBOT1] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatbot1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		
		BitmapSkin[SKIN_CHATEDITRIGHTM1] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatrightm1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_CHATEDITRIGHTM2] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatrightm2.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_CHATEDITRIGHTM3] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatrightm3.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

			

		
		// for this piece we have some exclude regions (255,0,255) colors //
		if(g_gfxDetails.bDefaultColorScheme == TRUE) 
		{
			BitmapSkin[SKIN_CHATEDITRIGHTT] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatrightta.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		}
		else 
		{
			BitmapSkin[SKIN_CHATEDITRIGHTT] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_chatrighttb.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		}

// Lobby Skinning //
	if(g_gfxDetails.bDefaultColorScheme == TRUE)
		{
		BitmapSkin[SKIN_LOBBYCHATEDITLEFTT] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatleftta.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_LOBBYCHATEDITLEFTM] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatleftma.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_LOBBYCHATEDITLEFTB] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatleftba.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		}
	else{
		BitmapSkin[SKIN_LOBBYCHATEDITLEFTT] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatlefttb.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_LOBBYCHATEDITLEFTM] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatleftmb.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		BitmapSkin[SKIN_LOBBYCHATEDITLEFTB] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatleftbb.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		}

	BitmapSkin[SKIN_LOBBYCHATTOP1] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychattop.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYCHATMID1] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatmid1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	
	BitmapSkin[SKIN_LOBBYCHATMIDL2] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatmidl2.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYCHATMIDL3] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatmidl3.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYCHATMIDL4] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatmidl4.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

	BitmapSkin[SKIN_LOBBYCHATMIDR2] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatmidr2.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYCHATMIDR3] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatmidr3.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYCHATMIDR4] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatmidr4.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

	BitmapSkin[SKIN_LOBBYCHATBOT1] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatbot1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

	BitmapSkin[SKIN_LOBBYCHATRIGHTM0] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatrightm0.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYCHATRIGHTM1] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatrightm1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYCHATRIGHTM2] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatrightm2.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYCHATRIGHTM3] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatrightm3.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

	BitmapSkin[SKIN_LOBBYPLAYERLISTTOPLB] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_playerlisttopleftb.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYPLAYERLISTTOPL] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_playerlisttopleft.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYPLAYERLISTTOPM] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_playerlisttopmid.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
	BitmapSkin[SKIN_LOBBYPLAYERLISTTOPR] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_playerlisttopright.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

	// for this piece we have some exclude regions (255,0,255) colors //
	if(g_gfxDetails.bDefaultColorScheme == TRUE) BitmapSkin[SKIN_LOBBYCHATEDITRIGHTT] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatrightta.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		else BitmapSkin[SKIN_LOBBYCHATEDITRIGHTT] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_lobbychatrighttb.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

	BitmapSkin[SKIN_RANKS] = (HBITMAP)LoadImage(0, "Graphics/skin/skin_ranks.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);


}




BOOL GET_SMILEYS(smiley_data_typ *smiley_data, int level)
{
	int n,i,p,q;
	unsigned char found, got_a_smiley;
	




	got_a_smiley = 0;

	// Scan the strTemp for our Smiley List //
	for(n=smiley_data->smiley_offset;n<strlen(gstr);n++)
	{
		BOOL CheckedSmileys = FALSE;
		BOOL CheckedAbuse = FALSE;

		// Check Smileys
		for(p=0;p<1024;p++)
		{
			
			// Check if our Level is Sufficient
			if(g_gameAppView)
			{
				if(g_gameAppView->m_playerSockIdx != -1 && g_gameAppView->m_playerIdx >= 0) 
				{
					if(p >= level) break;
				}
				else
				{
					if(p > 0) break;
				}
			}
			
			
			// Check for Smiley Code //
			if(smiley_lst[p] == NULL) CheckedSmileys = TRUE;
			if(!CheckedSmileys)
			{
				found=0;
				for(q=0;q<strlen(smiley_lst[p]);q++) 
				{	
					if((gstr[n+q] == smiley_lst[p][q]) ) found++;
						else if(gstr[n+q]>=65 && gstr[n+q]<=90) if(((gstr[n+q]+32) == smiley_lst[p][q]) ) found++;
				}
				
				if(found==strlen(smiley_lst[p])) 
				{
					got_a_smiley=1;
					break; // Found a Smiley Code so Break out //
				}
			}
	
		if(CheckedSmileys) break;
		}

		
		// Check Abuse
		if(!got_a_smiley)
		for(p=0;p<1024;p++)
		{
			// Check for Abuse Code //
			if(g_AbuseLstData.abuse_lst[p][0] == 0) CheckedAbuse = TRUE;
			if(!CheckedAbuse)
			{
				found=0;
				for(q=0;q<strlen(g_AbuseLstData.abuse_lst[p]);q++) 
				{	
					if((gstr[n+q] == g_AbuseLstData.abuse_lst[p][q]) ) 
					{
						found++;
					}
					else if(gstr[n+q]>=65 && gstr[n+q]<=90) 
					{
						if(((gstr[n+q]+32) == g_AbuseLstData.abuse_lst[p][q]) ) found++;
					}
				}
				
				if(found==strlen(g_AbuseLstData.abuse_lst[p])) 
				{
					got_a_smiley=2;
					break; // Found a Abuse Code so Break out //
				}
			}

			if(CheckedAbuse) break;
		}


	
		if(got_a_smiley)
		{
			// Found A Smiley or Abuse //
			found=1;
			smiley_data->smiley_spos = n;
			
			if(got_a_smiley == 1) 
			{
				smiley_data->smiley_epos = n+strlen(smiley_lst[p]);
				smiley_data->smiley_type = p;
			}
			else
			{
				smiley_data->smiley_epos = n+strlen(g_AbuseLstData.abuse_lst[p]);
				smiley_data->smiley_type = 4;
			}

			smiley_data->smiley_offset = smiley_data->smiley_epos;
			break;
		}
	}

	if(got_a_smiley) return TRUE;
		else return FALSE;
}

// Scans Through Abuse List and Returns True if we find about
BOOL GET_ABUSE(smiley_data_typ *smiley_data)
{
	int n,i,p,q;
	unsigned char found, got_abuse;
	


	got_abuse = 0;

	// Scan the strTemp for our Smiley List //
	for(n=smiley_data->smiley_offset;n<strlen(gstr);n++)
		{
		for(p=0;p<g_AbuseLstData.abuse_lst_n;p++)
			{
			// Check for Smiley Code //
			found=0;
			for(q=0;q<strlen(g_AbuseLstData.abuse_lst[p]);q++) 
			{	
				if((gstr[n+q] == g_AbuseLstData.abuse_lst[p][q]) ) 
				{
						found++;
				}
				else if(gstr[n+q]>=65 && gstr[n+q]<=90) 
				{
					if(((gstr[n+q]+32) == g_AbuseLstData.abuse_lst[p][q]) ) found++;
				}
			}
			
			if(found==strlen(g_AbuseLstData.abuse_lst[p])) 
				{
				got_abuse=1;
				break; // Found a Smiley Code so Break out //
				}
			}

		// return smiley 
		if(got_abuse)
			{
			// Found A Smiley //
			found=1;
			smiley_data->smiley_spos = n;
			smiley_data->smiley_epos = n+strlen(g_AbuseLstData.abuse_lst[p]);
			smiley_data->smiley_type = 32;		// Special Smiley (image) to replace Abuse //
			smiley_data->smiley_offset = smiley_data->smiley_epos;
			break;
			}
		}

	if(got_abuse) return TRUE;
		else return FALSE;
}


// messages to send
void CGameAppView::MessageSend(CString msg)
{
		  
	/*CGameAppDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	
	pDoc->SendMsgC(msg);

	m_message[0] = 0;*/

	//HandleServerMessage(msg.GetBuffer(0), 0); // For testing
	if(mainShell) mainShell->ChatSend(msg); // all messages go via the dedi-server!

	/*
	if(m_lobby->m_bInLobby)
	{
		if(mainShell) mainShell->ChatSend(msg);
	}
	#ifndef	MAIN_SERVER
	else
	{
				char *str;
		str = msg.GetBuffer(0);
		if(str[0]=='/') // check if it's a Stroke Message. if so send thru mainShell.
			{
			if(mainShell) mainShell->ChatSend(msg);
			}
		else {
			if(gameShell) gameShell->ChatSend(msg);
			}
	}
	#endif //!MAIN_SERVER	
	*/
}

void CGameAppView::Text(CDC* pDC, int x, int y, LPCTSTR lpszString)
{
    CFont font;
    int nHeight = -16;

    font.CreateFont (nHeight, 0, 0, 0, FW_BOLD,
        TRUE, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,
        CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH |
        FF_DONTCARE, "Times New Roman");

    pDC->SetBkMode(TRANSPARENT);
    pDC->SetTextColor(RGB (0, 0, 0));

    CFont* pOldFont = pDC->SelectObject (&font);
    pDC->TextOut(x, y, lpszString);
	//pDC->DrawText (text, -1, pRect, DT_SINGLELINE | DT_CENTER |
	//				    DT_VCENTER);

    pDC->SelectObject (pOldFont);
}


void CGameAppView::OnSysCommand(UINT nID, LPARAM lParam)
{

}

void CGameAppView::OnSize(UINT nType, int cx, int cy) 
{

	CView::OnSize(nType, cx, cy);

	
	/*
	if(g_gameAppView)
		GameLoop();
*/

	


	
	// Update our Main View Width & Height //

	
	//::SetWindowPos(g_hwndDX, g_hwnd, 0, 0, g_dwMainViewWidth, g_dwMainViewHeight, SWP_SHOWWINDOW);
	//::UpdateWindow(::GetParent(g_hwndDX));



	// TODO: Add your message handler code here
	//GetClientRect(&m_newClientRect);
	//m_newClientSRect = m_newClientRect;
	//ClientToScreen(m_newClientSRect);


	
	m_cx = cx;
	m_cy = cy;

	/*
	int offsetX = 788 - m_cx; // 800
	int ypos_start = (435-ceil(offsetX*0.5f)-g_yBarOffset);
	*/
	CRect rect;
	GetClientRect(&rect);
	
	g_dwMainViewWidth = rect.Width();
	
	if(g_dwMainViewWidth > g_iMaxWidthWS) g_dwMainViewWidth = g_iMaxWidthWS;
	g_dwMainViewHeight = g_dwMainViewWidth /2;

	int offset = 0;
	offset = rect.Width() - g_dwMainViewWidth;
	offset /= 2;


	//::MoveWindow(g_hwndDX, 0+2, 0, g_dwMainViewWidth, g_dwMainViewHeight+1, true);
	BOOL retval;
	//retval = ::ShowWindow(g_hwnd, SW_SHOW);
	retval = ::MoveWindow(g_hwndDX, offset+2, 0+2, g_dwMainViewWidth, g_dwMainViewHeight, true);
	//::ShowWindow(g_hwndDX, SW_HIDE);

	

#ifndef MAIN_SERVER
	m_snooker->m_cx = cx;
	m_snooker->m_cy = cy;
	m_snooker->m_bRefreshScores = TRUE;

#endif //!MAIN_SERVER

	m_fX = (float)(m_cx) / 1182;
	m_fY = (float)(m_cy)*0.5f / 1182;

	static bool firstTimeOnSize = false;

	// re-calculate double buffer size
	if(firstTimeOnSize) Mmain_log("OnSize(...) - Deinit()");
		Deinit();
	if(firstTimeOnSize) Mmain_log("OnSize(...) - Init()");
		Init();

	m_bOnSize = TRUE;
	m_bOnSizeDrawTmpSurf = TRUE;

	if(firstTimeOnSize)
		firstTimeOnSize = false;
	
}

void CGameAppView::DisplayFoulUpdate(void) // m_snooker related function
{
	#ifndef MAIN_SERVER

	// display foul options - this is to put opponent back in when they foul!!
	if(m_snooker->m_bFoulDecideTurn)
	if( m_snooker->MyTurn() )
	{
		//m_snooker->m_bFoul = FALSE;//[?]
		// display foul options dialog box
		int offsetX = 788 - m_cx; // 800
		GetWindowRect(&m_origin);

		CRect clientrect;
		::GetClientRect(g_hwndDX, clientrect);
		int ypos_start = clientrect.Height();

		m_snooker->m_foulDlg.SetWindowPos(&wndTop, 
			m_origin.left + 688-offsetX-g_FIX_shiftX+34, 
			m_origin.top+ypos_start+8, 
			100+g_FIX_shiftX-40+4, 
			m_origin.Height() - ypos_start - 14, 
			SWP_SHOWWINDOW);

		m_snooker->m_foulDlg.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
/*
		// re-draw the GFX to screen
		m_environment->Update(); // Update lighting etc.
		Draw3D();
		DrawMini3D();
		Draw2D();
*/
	}

	#endif //!MAIN_SERVER
}


void CGameAppView::MouseWheel(short zDelta)
{
#ifndef MAIN_SERVER
	// If we're in Camera Mode, do appropriate code //
	if (g_pCameraMode)
	{
		// Get Unit Vector in direction we're looking at //
		g_pCameraFree->_distancev -= zDelta * 0.1f;
		m_bUpdateTable = true;
	}

	// If we have set our shot
	if (g_gameAppView)
	if (g_gameAppView->m_snooker->m_cueBallSelect == 5)
	{
		float percent = m_snooker->m_cuePowerPercentage;
		if (zDelta>0)
		{
			if (percent < 100) percent += 1;
		}
		else{
			if (percent > 0) percent -= 1;
		}
		UpdatePower((float)(percent / 100));
	}

#endif
}


BOOL CGameAppView::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt) 
{
	MouseWheel(zDelta);

	return CView::OnMouseWheel(nFlags, zDelta, pt);
}



void CGameAppView::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

#ifndef MAIN_SERVER

	// This Mouse Move is coming from our Main Window, so we must make sure the Coords are offsetted to D3DWindow if required //
	if (g_gameAppView)
	if (m_lobby->m_bInLobby)
	{
		m_lobbyButtons->OnLButtonDown();
		m_findMatchCtrl->OnLButtonDown();
		/*
		m_invitationDlg[0].DestroyWindow();
		// m_invitationDlg[m_invitationN].GetInviterHostSockIdx(HostSockIdx, hostName, initialHostTbl, table, enterType, reracks, totalGames);
		m_invitationDlg[0].Create(IDD_INVITATIONTDLG); // special tourney invite
		m_invitationDlg[0].ShowWindow(SW_SHOW);
		*/
	}


#endif //!MAIN_SERVER

	CView::OnLButtonDblClk(nFlags, point);
}








void CGameAppView::OnLButtonDown(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default

#ifndef MAIN_SERVER
	if (m_lobby->m_bInLobby)
	{
		m_lobbyButtons->OnLButtonDown();
		m_findMatchCtrl->OnLButtonDown();
	}

		
	

	




	// This Mouse Move is coming from our Main Window, so we must make sure the Coords are offsetted to D3DWindow if required //
	if (g_gameAppView)
	if (!m_lobby->m_bInLobby)
	if (m_snooker->m_cueBallSelect != 5)
	{
		CRect mainrect;
		CRect clientrect;
		g_gameAppView->GetWindowRect(&mainrect);
		::GetWindowRect(g_hwndDX, clientrect);
		int diff = clientrect.left - mainrect.left;
		if (diff >= 2) point.x -= diff;
	}

	bool bJustChanged = false;

	if (!m_snooker->m_bCueState) m_bRButtonDown = 0; // [*NEW*] CP
	if (!m_bLButtonDown)
	{
		m_bLButtonDown = 1;
		bJustChanged = true;
	}

	m_bMySliderRaiseButt = TRUE;
	m_point = point;
	m_bLButtonJustUp = 0;


	m_snooker->MouseMove(point); // update mouse's (3D table plane) coordinates to the exact click point!
	/*
		if(bJustChanged)
		{
		int offsetX = 788 - m_cx; // 800
		int offsetY = 542 - m_cy; // 600

		int tv_x = 0;
		int tv_y = 108;
		int tv_w = (float)(m_cx) * 0.33f;
		int tv_h = (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-1;

		int offY = 0;
		int offX = 2;


		if(m_lobby->m_bInLobby)
		//if(g_bLobbyTBReady)
		if(m_bLButtonDown)
		{
		g_bLobbyTBReady = FALSE;
		// Find the relative position that we clicked (1600:800) range //
		int mx = (int)(((m_snooker->m_mouseX - tv_x) / (float)tv_w) * 1600.0f);
		int my = (int)(((m_snooker->m_mouseY - tv_y) / (float)tv_h) * 800.0f);
		//m_snooker->MouseMove(CPoint(m_snooker->m_mouseX, m_snooker->m_mouseY));
		if(mx > 150.0f && mx < 1450.0f)
		if(my > (40-32) && my < (40+32))
		{
		m_bLobbyMode = 1 - m_bLobbyMode;	// 'View Tables' and 'View MessageBoard' button //
		g_tabSelected = 0;	// View Tables / Msg Board Mode //
		if(m_bLobbyMode == 0)
		{
		if(m_listTables) m_listTables.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
		if(m_tableTabCtrlDlg) m_tableTabCtrlDlg.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
		if(m_lobbySelectDlg) m_lobbySelectDlg.SetWindowPos(&wndTop, 0 ,0 ,0 ,0, SWP_HIDEWINDOW);
		if(m_tabLobbyCtrlEx) m_tabLobbyCtrlEx.SetWindowPos(&wndTop, 0 ,0 ,0 ,0, SWP_HIDEWINDOW);

		if(m_htmlViewMB) m_htmlViewMB.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

		}
		else if(m_bLobbyMode == 1)
		{
		if(m_lobbySelectDlg)
		if(m_lobbySelectDlg.IsWindowVisible())
		{
		m_lobbySelectDlg.SetWindowPos(&wndTop, 0 ,0 ,0 ,0, SWP_HIDEWINDOW);
		}

		if(m_htmlViewMB)
		if(m_htmlViewMB.IsWindowVisible())
		{
		m_htmlViewMB.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
		}

		if(m_tableTabCtrlDlg)
		if(m_tableTabCtrlDlg.IsWindowVisible())
		{
		m_tableTabCtrlDlg.SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_HIDEWINDOW);
		}

		m_listTables.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		m_listTables.ShowScrollBar(SB_VERT);
		m_tableTabCtrlDlg.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		}
		//RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		}

		}

		}
	*/

	if (m_bRButtonDown) return; // stop simulataneous button presses

	// if strike is in progress - don't update mouse data
	if (m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20) return;

	if (m_bot->m_bStatus) return;

	// check if it's my turn??
	if (!m_snooker->MyTurn()) return;

	UpdatePower(point);

	if (m_snooker->m_tableMouseOn)
	{

		// BAPFIX - Out of Sync bug, when ball is moved with right mouse held down, then shot set, without releasing right button //
		// check if player has stood up from shot - and has a ball-in-hand!!
		if (m_snooker->m_bStandUpFromShot)
		if (m_snooker->m_bBallInHand)
		{
			int cueBallIdx;
			if (g_build.gameType == GAMETYPE_SNOOKER && m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
			{
				if (m_snooker->m_bTurn1P) cueBallIdx = WHITE;
				else cueBallIdx = WHITE + 1;	// Yellow Ball if Player 2's Turn //
			}
			else{
				cueBallIdx = WHITE;			// Always WHITE if not Billiards or Pool //
			}

			CVector P;
			P.x = m_snooker->m_ball[cueBallIdx]->m_P.x;
			P.y = m_snooker->m_ball[cueBallIdx]->m_P.y;
			P.z = m_snooker->m_ball[cueBallIdx]->m_P.z;
			if (m_snooker->m_bPracticeMode)
				m_snooker->BallPos(P, cueBallIdx);
			else
				SendPlayerBallPos(P, cueBallIdx);
		}

		// m_bLButtonDown
		// m_snooker->m_tableMousePos[0]

		if (!m_bPracticeEditPlay)//m_snooker->m_bPracticeMode) // Edit mode
		{
			if (m_practiceEditColour == -1)
			{
				// find the ball we want to grab
				for (int n = 0; n<MAX_TOTALBALLS; n++)
				{
					if (m_snooker->m_ball[n]->Proximity(m_snooker->m_tableMousePos[0], m_snooker->m_tableMousePos[1], m_snooker->m_tableMousePos[2]) == TRUE)
					{
						if (m_snooker->m_ball[n]->m_colour != WHITE)
							ClearFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE);
						break;
					}
				}
			}
			else
			{
				int n;
				int number = 1;

				if (g_build.gameType == GAMETYPE_SNOOKER)
				{
					if (m_practiceEditColour == RED)
						number = 15;

					// count how many balls of this colour we have already on table
					for (n = 0; n<MAX_TOTALBALLS; n++)
					if (TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
					if (m_snooker->m_ball[n]->m_colour == m_practiceEditColour)
					{
						number--;
					}

					// note: the order of reds/colours are un-order, except for white-ball at [0]
					if (number)
					for (n = 0; n<MAX_TOTALBALLS; n++)
					if (!TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
					{
						m_snooker->m_ball[n]->Init(-m_snooker->m_tableMousePos[0], -m_snooker->m_tableMousePos[1], 0, m_practiceEditColour);
						break;
					}
				}
				else if (g_build.gameType == GAMETYPE_POOL)
				{
					int startBall = 0;
					if (m_practiceEditColour == RED) // spots (0-7)
					{
						number = 8;
						startBall = 0;
					}
					else if (m_practiceEditColour == YELLOW) // stripes (8-15)
					{
						number = 7;
						startBall = 9;
					}
					else if (m_practiceEditColour == GREEN) // 8-ball
					{
						number = 1;
						startBall = 8;
					}
					else if (m_practiceEditColour == BROWN) // 9-ball
					{
						number = 1;
						startBall = 9;
					}

					// count how many balls of this colour we have already on table
					for (n = startBall; n<16/*MAX_TOTALBALLS*/; n++)
					if (TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
					if (m_snooker->m_ball[n]->m_colour == m_practiceEditColour)
					{
						number--;
					}

					// note: the order of reds/colours are un-order, except for white-ball at [0]
					if (number)
					for (n = startBall; n<16/*MAX_TOTALBALLS*/; n++)
					if (!TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
					{
						if ((m_practiceEditColour == GREEN && n == 8) ||
							(m_practiceEditColour == BROWN && n == 9) ||
							(m_practiceEditColour == RED && n<9) ||
							(m_practiceEditColour == YELLOW && n >= 9))
							m_snooker->m_ball[n]->Init(-m_snooker->m_tableMousePos[0], -m_snooker->m_tableMousePos[1], 0, n);
						break;
					}
				}
			}
		}

		else if (!m_snooker->m_cueBallSelect)
		{
			// get select ball info.
			if (m_snooker->SelectBall(1, point) == TRUE)
			{
				// Only give this window the mouse's full attention 
				SetCapture();

				// limit mouse movement region
				CRect rect;
				GetClipCursor(&m_rectCursor);
				GetWindowRect(&rect);
				rect.left += 5;
				rect.top += 5;
				rect.right -= 5;
				rect.bottom -= 5;
				ClipCursor(&rect);

				// calculate mouse delta x & y position
				CPoint deltaPoint;
				deltaPoint.x = point.x - m_point.x;
				deltaPoint.y = point.y - m_point.y;

				// get mouse old screen position
				CPoint oldPoint;
				GetCursorPos(&oldPoint);

				// update mouse position with deltas
				oldPoint.x -= deltaPoint.x;
				oldPoint.y -= deltaPoint.y;
				SetCursorPos(oldPoint.x, oldPoint.y);

				m_snooker->m_deltaSum.x = m_snooker->m_deltaSum.y = 0;

				m_hCursor = GetCursor(); // save cursor
				if (m_bShowCursor)
				{
					m_bShowCursor = FALSE;
					ShowCursor(m_bShowCursor); // hide cursor
				}

				m_snooker->m_bStandUpFromShot = 0;
				m_snooker->m_sightlineFade = 60;
				m_snooker->m_cuePowerPercentage = 0;

				m_snooker->m_bCuePowerJustOn = TRUE;

				if (m_snooker->m_bPracticeMode)
					m_snooker->m_bSeenSelectBall = TRUE;
				else
					m_snooker->SelectBallSend(1, point, m_snooker->m_windowWidth, m_snooker->m_windowHeight, m_snooker->m_selectBall);
			}
		}
	}

#endif //!MAIN_SERVER

	CView::OnLButtonDown(nFlags, point);
}

void CGameAppView::OnLButtonUp(UINT nFlags, CPoint point)
{

	// TODO: Add your message handler code here and/or call default

#ifndef MAIN_SERVER	



	// Now that we have the L Button Up message, release the capture
	if (g_bOnPowerBarMouseDown)
	{
		ReleaseCapture();
		g_bOnPowerBarMouseDown = false;
		// if (g_gameAppView) ErrorMessage(g_gameAppView, "mouse up");
	}

	// This Mouse Move is coming from our Main Window, so we must make sure the Coords are offsetted to D3DWindow if required //

	if (g_gameAppView)
	if (!m_lobby->m_bInLobby)
	if (m_snooker->m_cueBallSelect != 5)
	{
		CRect mainrect;
		CRect clientrect;
		g_gameAppView->GetWindowRect(&mainrect);
		::GetWindowRect(g_hwndDX, clientrect);
		int diff = clientrect.left - mainrect.left;
		if (diff >= 2) point.x -= diff;
	}

	g_bLobbyTBReady = TRUE;

	if (m_bLButtonDown) m_bLButtonJustUp = 1;
	m_point = point;
	m_bLButtonDown = 0;
	m_bRButtonJustUp = 0;


	m_snooker->MouseMove(point);

	// if strike is in progress - don't update mouse data
	if (m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20) return;

	if (m_bot->m_bStatus) return;
	if (!m_snooker->MyTurn()) return;  // check if it's my turn??



	if (m_snooker->m_cueBallSelect == 1)
		//if(((int)m_snooker->m_cuePowerPercentage) > 0)
	{
		if (m_snooker->m_bCuePowerJustOn)
		{
			// first time in here
			m_snooker->m_bCuePowerJustOn = FALSE;
		}
		else
		{
			// LINE SET:
			ctmsg_LINESET_DATA ctmsgData;
			ctmsgData.point = point;
			m_snooker->m_customTable->Referee(CTMSG_LINESET, &ctmsgData);
			m_fineTuner->Reset(true);
		}
	}

	else if (m_snooker->m_cueBallSelect == 5)
	{
		// POCKET SET:
		ctmsg_POCKETSET_DATA ctmsgData;
		ctmsgData.point = point;
		m_snooker->m_customTable->Referee(CTMSG_POCKETSET, &ctmsgData);
	}

#endif //!MAIN_SERVER

	CView::OnLButtonUp(nFlags, point);
}

void CGameAppView::OnRButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default
#ifndef MAIN_SERVER

	if (!m_bRButtonDown)	m_bRButtonDown = 1;

	// if strike is in progress - don't update mouse data
	if (m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20) return;


	if (m_bot->m_bStatus) return;

	// check if it's my turn??
	if (!m_snooker->MyTurn()) return;

	m_snooker->m_bTestBallFinished = FALSE;
	//m_snooker->m_bCueTipReady = FALSE;

	// reset foucus to table (this) window, & reset 'raise butt'
	m_snooker->m_RaiseButt = m_snooker->m_RaiseButtOld = 0;
	m_snooker->m_bReceiveRaiseButtActive = FALSE;
	m_snooker->m_bRaiseButtHelper = TRUE;
	m_sliderRaiseButt.SetPos(90);





	PreviousWndEditSetFocus();
	m_snooker->m_bCuePowerJustOn = FALSE;

	m_point = point;



	// Only give this window the mouse's full attention 
	SetCapture();




	if (m_snooker->m_CameraMode == CAMERA_MODE_PLAYER_3D)
	if (m_bShowCursor)
	{
		m_bShowCursor = FALSE;
		ShowCursor(m_bShowCursor); // hide cursor
	}

	if (m_snooker->m_tableMouseOn)
	{
		if (m_snooker->m_bCueState)
		{
			// Now Give ,mouse's attention to all
			if (GetCapture() == this) ReleaseCapture();

			// give mouse full movement
			ClipCursor(&m_rectCursor);

			// reset mouse cursor position back to start position
			CRect rect;
			GetWindowRect(&rect);
			SetCursorPos(rect.left + m_snooker->m_sCPoint.x + 2, rect.top + m_snooker->m_sCPoint.y + 2);


			m_snooker->SelectBall(0, point);


			m_snooker->m_point = point;
			m_snooker->m_sightlineFade = 0;


			if (m_snooker->m_bPracticeMode);
			else
				m_snooker->SelectBallSend(0, point, m_snooker->m_windowWidth, m_snooker->m_windowHeight, m_snooker->m_selectBall);


		}

		if (m_bRButtonJustUp)
		{
			m_snooker->m_bStandUpFromShot = 1;

			// check if we can nominate a colour ball
			if (m_snooker->m_tableMouseOn)
			if (!m_snooker->m_rednext || TestFlag(m_snooker->m_foul, Flg_FOUL_FREEBALL))
			{
				m_snooker->NominateBall(point);
			}

		}
	}

	if (m_snooker->m_CameraMode == CAMERA_MODE_PLAYER_3D) m_snooker->m_sCPoint = point;


#endif //!MAIN_SERVER

	CView::OnRButtonDown(nFlags, point);
}

void CGameAppView::OnMButtonDown(UINT nFlags, CPoint point)
{
	m_bMButtonDown = 1;

}

void CGameAppView::OnMButtonUp(UINT nFlags, CPoint point)
{
	m_bMButtonDown = 0;
}



void CGameAppView::OnRButtonUp(UINT nFlags, CPoint point)
{



	// TODO: Add your message handler code here and/or call default

#ifndef MAIN_SERVER	

	m_bRButtonDown = 0;

	if (m_bLButtonDown) m_bRButtonJustUp = 0;
	else m_bRButtonJustUp = 1;


	// if strike is in progress - don't update mouse data
	if (m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20) return;

	if (m_bot->m_bStatus) return;

	// check if it's my turn??
	if (!m_snooker->MyTurn()) return;

	// hide mini3dcam cuetip
	m_snooker->m_cuetip[0] = 0;
	m_snooker->m_cuetip[1] = 0;
	m_snooker->m_cuetip[2] = 0;//1;
	m_snooker->m_ballMousePos[0] = 0;
	m_snooker->m_ballMousePos[1] = 0;
	m_snooker->m_ballMousePos[2] = -20;

	m_sliderRaiseButt.EnableWindow(FALSE);
	PreviousWndEditSetFocus();

	// send ball pos data
	if (!m_bPracticeEditPlay)//m_snooker->m_bPracticeMode) // Edit mode
	{
		m_snooker->DropBallOnTable(m_snooker->m_grabBall, m_snooker->m_tableMousePos[0], m_snooker->m_tableMousePos[1]);

		// removes any balls placed near pockets
		if (m_snooker->m_ball[m_snooker->m_grabBall]->m_colour != WHITE)
		if (m_snooker->m_ball[m_snooker->m_grabBall]->CushionsProximity())
		if (m_snooker->m_ball[m_snooker->m_grabBall]->CollideWithPockects(FALSE))
		{
			m_snooker->m_grabBall = WHITE;
		}
	}
	else // normal game mode (Play mode)
	{
		// check if player has stood up from shot - and has a ball-in-hand!!
		if (m_snooker->m_tableMouseOn)
		if (m_snooker->m_bStandUpFromShot)
		if (m_snooker->m_bBallInHand)
		{
			int cueBallIdx;
			if (g_build.gameType == GAMETYPE_SNOOKER && m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
			{
				if (m_snooker->m_bTurn1P) cueBallIdx = WHITE;
				else cueBallIdx = WHITE + 1;	// Yellow Ball if Player 2's Turn //
			}
			else{
				cueBallIdx = WHITE;			// Always WHITE if not Billiards or Pool //
			}


			if (g_build.gameType == GAMETYPE_POOL)
			if (m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
				cueBallIdx = m_snooker->m_customTable->RefereeBowlsNextStrikeBall();

			m_snooker->DropBallOnTable(cueBallIdx, m_snooker->m_tableMousePos[0], m_snooker->m_tableMousePos[1]);

			CVector P;
			//P.x = m_snooker->m_tableMousePos[0];
			//P.y = m_snooker->m_tableMousePos[1];
			P.x = m_snooker->m_ball[cueBallIdx]->m_P.x;
			P.y = m_snooker->m_ball[cueBallIdx]->m_P.y;
			P.z = m_snooker->m_ball[cueBallIdx]->m_P.z;
			if (m_snooker->m_bPracticeMode)
				m_snooker->BallPos(P, cueBallIdx);
			else
				SendPlayerBallPos(P, cueBallIdx);
		}
	}


	// Now Give ,mouse's attention to all
	// Only if we aren't already aiming //
	if (!m_snooker->m_cueBallSelect)
	if (GetCapture() == this) ReleaseCapture();

	// reset mouse cursor position back to start position
	// Note: this doesn't work correctly! Because of camera orient/position
	if (m_snooker->m_CameraMode == CAMERA_MODE_PLAYER_3D)
	{
		CRect rect;
		GetWindowRect(&rect);
		SetCursorPos(rect.left + m_snooker->m_sCPoint.x + 2, rect.top + m_snooker->m_sCPoint.y + 2);
	}

	if (!m_snooker->m_cueBallSelect)
	if (!m_bShowCursor)
	{
		m_bShowCursor = TRUE;
		SetCursor(m_hCursor);
		ShowCursor(m_bShowCursor); // show cursor
	}
#endif //!MAIN_SERVER

	CView::OnRButtonUp(nFlags, point);
}


LRESULT CGameAppView::OnMouseLeave(WPARAM wparam, LPARAM lparam)
{
	// m_testSprite->OnMouseLeave();
	m_lobbyButtons->OnMouseLeave();
	m_findMatchCtrl->OnMouseLeave();

	SetCursor(m_hCursor);

	return true;
}


LRESULT CGameAppView::OnMouseHover(WPARAM wparam, LPARAM lparam)
{
	// m_testSprite->OnMouseHover();
	m_lobbyButtons->OnMouseHover();
	m_findMatchCtrl->OnMouseHover();

	// SetCursor(m_hCursorHand);
	// SetClassLong(g_hwnd, GCL_HCURSOR, (DWORD)m_hCursorHand);

	return true;

	/*
	CDC* pDC = GetWindowDC();
	CRect rect;
	GetWindowRect(&rect);
	rect.OffsetRect(-rect.left, -rect.top);
	CBrush brush(RGB(0, 0, 255));
	pDC->FrameRect(&rect, &brush);
	ReleaseDC(pDC);
	return true;
	*/
}


BOOL CGameAppView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (!m_bUpdateCursor) return true;

	return CView::OnSetCursor(pWnd, nHitTest, message);
	
}


void CGameAppView::OnMouseMove(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default


#ifndef MAIN_SERVER	

	// Determine which sector mouse is in //

	// WM_MOUSEMOVE + !m_bMouseTracking becomes the equivalent of
	// WM_MOUSEENTER of which there is no such thing.
	// Restrict to Lobby for now 

	if (m_lobby->m_bInLobby)
	{
		TRACKMOUSEEVENT tme;
		tme.cbSize = sizeof(tme);
		tme.hwndTrack = m_hWnd;
		tme.dwFlags = TME_LEAVE | TME_HOVER;
		tme.dwHoverTime = 1;
		TrackMouseEvent(&tme);

		// Update our global mouse point
		if (g_gameAppView)
		{
			g_gameAppView->m_mousePoint = point;
		}

	}


	// Determine which sector mouse is in //




	g_mouseSector = SECTOR_NONE;

	{
		int x, y, w, h;
		x = point.x - m_snooker->m_moffsetX;
		y = point.y - m_snooker->m_moffsetY;
		w = m_snooker->m_mwindowWidth;
		h = m_snooker->m_mwindowHeight;

		/*
		char buffer[1024];
		sprintf(buffer,"%d,%d [%dx%d]",x,y, w, h);
		ErrorMessage(this,buffer);
		*/
		// see if tip is inside mini-camera's box
		if (x >= 0 && x<w)
		if (y >= 0 && y<h)
		{
			g_mouseSector = SECTOR_MINI;

			// ErrorMessage(this, "SECTOR_MINI");
		}
	}

	
	m_mousePoint.x = point.x;
	m_mousePoint.y = point.y;

	// This Mouse Move is coming from our Main Window, so we must make sure the Coords are offsetted to D3DWindow if required //
	if (g_gameAppView)
	if (m_snooker->m_bCueState && m_snooker->m_cueBallSelect != 5);
	else if (g_mouseSector != SECTOR_MINI)
	{
		CRect mainrect;
		CRect clientrect;
		g_gameAppView->GetWindowRect(&mainrect);
		::GetWindowRect(g_hwndDX, clientrect);
		int diff = clientrect.left - mainrect.left;
		if (diff >= 2) point.x -= diff;
	}



	if (!m_snooker->MyTurn()) return;

	if (m_snooker->m_cueBallSelect == 1 && m_bLButtonDown) return;
	if (m_bot->m_bStatus) return;

	Mio_mouseread();

	if (m_bMButtonDown)
	{
		g_pCameraFree->MouseUpdate(Mio_mouse.lX, Mio_mouse.lY);
	}

	m_bLButtonJustUp = 0;

	m_snooker->MouseMove(point);

	// if strike is in progress - don't update mouse data
	if (m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20) return;



	UpdatePower(point);

	// check for mouse operation mode - i.e. cue line of sight, or - camera orientation/positioning
	//--	if(m_snooker->m_bCueState)// || (m_bRButtonDown && CAMERA_MODE_PLAYER_3D))
	if (m_snooker->m_bCueState && m_snooker->m_cueBallSelect != 5)
	{
		// fix mouse cursor to the mouse starting point
		CRect rect;
		GetWindowRect(&rect);
		CPoint deltaPoint;

		//deltaPoint = point - m_snooker->m_sCPoint;
		deltaPoint.x = point.x - m_snooker->m_point.x;
		deltaPoint.y = point.y - m_snooker->m_point.y;
		if (deltaPoint.x || deltaPoint.y) SetCursorPos(rect.left + m_snooker->m_point.x + 2,
			rect.top + m_snooker->m_point.y + 2);

		/*
		char buf[80];
		sprintf(buf, "ref(%d, %d) - deltaPoint.x: %d, deltaPoint.y: %d", m_snooker->m_point.x, m_snooker->m_point.y, deltaPoint.x, deltaPoint.y);
		ErrorMessage(this, buf);

		if(deltaPoint.x < -20 || deltaPoint.x > 20)
		{
		buf[0] = buf[0];
		}
		*/


	}
#endif //MAIN_SERVER




	CView::OnMouseMove(nFlags, point);
}


void CALLBACK EXPORT TimerProc(
   HWND hWnd,      //handle of CWnd that called SetTimer
   UINT nMsg,      //WM_TIMER
   UINT nIDEvent,  //timer identification
   DWORD dwTime)    //system time)
{
	//	MessageBox("","",MB_OK);
}

DWORD g_startTime = 0;
DWORD g_fps = 0;

int _GameLoopRefreshRate[] = {
0,
25,
30,
50,
60,
70,
72,
75,
85,
100,
120,
140,
150,
};

CMenu *pMenu0 = 0;
CMenu *pMenu1 = 0;
CMenu *pMenu2 = 0;

float	g_fPCount = 0.0f;
int		g_iPCount = 0;
float	g_fProbeRemainder = 0.0f;


void CGameAppView::GameLoop(float timeDelta)
{
#ifndef MAIN_SERVER

	m_elCycle=EL_BALLS; // Balls only

	// 7 x 75 = 525
	// 9 x 60 = 540
	// We want to have 500 processes per second //
	// i.e. One Process every 0.002 seconds //


	if(FPS > 10 && FPS < 55) // If we can't do at least 50 fps then do extra processes based on the frequency we're hitting //
	{
		g_fProbe =  525.0f / (1.0f / timeDelta); //(float)g_pdevMode.dmDisplayFrequency;
	}
	else
	{
		g_fProbe =  525.0f / (float)g_pdevMode.dmDisplayFrequency;
	}

	// g_fProbe =  525.0f / (float)g_pdevMode.dmDisplayFrequency;

	//g_fProbe =  550.0f / (float)g_pdevMode.dmDisplayFrequency;
	//g_fProbe =  550.0f / (float)g_pdevMode.dmDisplayFrequency;


	g_fProbe += g_fProbeRemainder;
	g_iPCount = (int) g_fProbe;



	g_fProbeRemainder = g_fProbe - g_iPCount;

	//char buf[256];
	//sprintf(buf, "g_fProbe:%.2f, dmDisplayFrequency:%d, g_iPCount:%d", g_fProbe, g_pdevMode.dmDisplayFrequency, g_iPCount);
	//if( ::GetAsyncKeyState('F') & 0x8000f ) AfxMessageseBox(buf);

	
	// Balls need to be Proceesed 60 times per frame, to get precision...
	if(g_iPCount >=0 && g_iPCount <= 60) // Safety
	for(int n=0;n<g_iPCount;n++)
	{
		// Tempo Hack // 
		m_elCycle=EL_REST | EL_BALLS;
		m_snooker->ProcessBalls();
	}
	
	Process(timeDelta);

	g_pCamera->Process();
	g_pCameraMiniCam->Process();
	g_pCameraFree->Process();
	
	m_cueChanger->Process();
	m_fineTuner->Process();
	m_chalkChanger->Process();

	m_cyc++;
	g_fps++;

	Draw(timeDelta);

	if(!m_bDoneADraw) m_bDoneADraw = TRUE;


	return;


	
/*


	// check if a menu/pop-up menu has input, and cancel
	if(!m_lobby->m_bInLobby)
	if( m_snooker->m_cueBallSelect == 10 ||
	m_snooker->m_cueBallSelect == 9 ||
	m_snooker->m_cueBallSelect == 2 ||
	m_snooker->m_cueBallSelect >= 20)
	{
		// main menu
		if(!m_snooker->m_bPracticeMode) // online only
		if(g_menuNItemID != -1)
		{
			DWORD dw;
			CRect rect;
			GetWindowRect(&rect);
			dw = rect.left + rect.top<<16;
			// User did not click the Mouse //
			// Used to make SmileyDialog remain open during the game //
			g_UserMouseClick = FALSE; 
			PostMessage(WM_LBUTTONDOWN, 0, dw);
		}

		// pop-up menu (send/chat)
		if(pMenu1 || pMenu2 || pMenu0)
		{
			// User did not click the Mouse //
			// Used to make SmileyDialog remain open during the game //
			g_UserMouseClick = FALSE; 
			PostMessage(WM_LBUTTONDOWN);

		}
	}

*/

#endif //!MAIN_SERVER
}


void CGameAppView::OnTimer(UINT nIDEvent)
{


	// check if we are still busy! (from a previous call to this function)
	if(m_bOnTimerBusy || !g_oncreatecomplete) return;

	m_bOnTimerBusy = 1;
	g_processcount++;
	// ----------------------- //
	static BOOL firstTimeTimer = 1;
	if(firstTimeTimer)
	{
		//AfxMessageBox("WAIT");
		//firstTime = 0;
		#ifndef MAIN_SERVER
		g_gameAppView = this;
		#endif //!MAIN_SERVER
	}

	#ifdef MAIN_SERVER
	//GameLoop(); // nolonger here - called in onidle function.
	Process(0);
	m_cyc++;
	m_seq++;
	Draw(0);
	m_bDoneADraw = TRUE;
	#endif //MAIN_SERVER
	
	CView::OnTimer(nIDEvent);
	#ifndef MAIN_SERVER
	g_count++;
	
	m_seq++; // moved from GameLoop() (Note: this variable is not used currently)



	static bool bResized = false;
	if(g_count>2)
	if(!bResized)
	{
	
		Mmain_log("OnDraw(...) - ResizeScreenToSaved()");
		// re-sizes screen to saved settings size (call this once only on app. startup
		ResizeScreenToSaved();
		bResized = true;
	}


	// tick down lobby refreh delay timer
	if(m_lobbyRefreshDelay)
	{
		// showhide/inactivate refreh button
		if(m_lobbyRefreshDelay == 60*2)
			{
			//m_refreshButton.EnableWindow(FALSE);
			m_refreshButtonEnabled = FALSE;
			//m_changelobbyButton.EnableWindow(FALSE);
			}

		m_lobbyRefreshDelay--;

		// hide/inactivate refreh button
		if(!m_lobbyRefreshDelay) 
			{
			//m_changelobbyButton.EnableWindow(
			//m_refreshButton.EnableWindow(TRUE);TRUE);
			m_refreshButtonEnabled = TRUE;
			}
	}


	// extra call to OnIdle(...) - this prevents ppl from holding up the game (i.e. Alt-keys/Menus,etc)
/*
	m_bExtraGameLoop = TRUE;
		GameLoop(0.016f);


	m_bExtraGameLoop = FALSE;
	if(m_snooker->m_cueBallSelect != 0)// || m_snooker->m_bSimJustFinished) // if not in idle state, i.e if in simulation mode (cueballselect = 2)
	{		
		DWORD QueueStatus = GetQueueStatus(QS_ALLINPUT);
		if(HIWORD(QueueStatus) == 0)
		{
			if(m_snooker->m_bSimJustFinished > 0)
				m_snooker->m_bSimJustFinished--;

			m_bExtraGameLoop = TRUE;

			GameLoop(0.016f);
			//AfxGetApp()->OnIdle(1);
			//ErrorMessage(this, "here!");
		}
	//else
	//		ErrorMessage(this, "else!");
	}
 */


	// PING host of table! Boot myself from this table if i get no response after x time.
	if(!m_snooker->m_bPracticeMode)
	{			   
		GamePingProcess();
		if(firstTimeTimer) Mmain_log("OnTimer(...) - m_snooker->ProcessSimEndCounters()");
		m_snooker->ProcessSimEndCounters();
	}

	// Flash Window if we have a Invite Box is update
	
	
	bool bProceed = false;
	
	if (m_invitationDlg->m_hWnd)
	{
		if (::IsWindowVisible(m_invitationDlg->m_hWnd))
		{
			bProceed = true;
		}
	}
	
	if (m_bFlashWindow)
	if (m_snooker->MyTurn()) bProceed = true;
	
	// flash window if it's this player's turn and doesn't have focus
	if (bProceed)
	{
		if( AfxGetMainWnd() != GetForegroundWindow() &&
			g_previousWndNo == 0 ) // make sure the sendEdit has focus control back (NOT one of th dialogues (i.e. m_statsDlg, m_statsChatDlg)
		{
			if(!(m_knockknock%4))
				AfxGetMainWnd()->FlashWindow(TRUE);

//			if(m_knockknock==0 || m_knockknock==2)
//				Msfx_smpplayvol(&m_game_smp[SFX_CUE2BALL], 255);
			
			m_knockknock++;
			if(m_knockknock >= GAMEAPPCLIENT_FPS*4.0f)
				m_knockknock = 0;
		}
		else
		{
			m_bFlashWindow = FALSE;
		}
	}



	// set application performance levels (!Warning!: high performance can cause other apps. to run slow)
	if(firstTimeTimer) Mmain_log("OnTimer(...) - Set Performance Code (NORMAL)");	

	if(g_bPerformanceChanged)
	{
		
		//g_gfxDetails.bHighPerformance = FALSE;
		g_bPerformanceChanged = FALSE;
		if(g_gfxDetails.bHighPerformance == TRUE)
		{
			// Change the Desktop Composition Mode 
			
			if(IsCompositionEnabled() == 1)
			{	
				// If LoadLibrary was successful, it means we are running in Windows Vista	//
				// Disable the Composition Mode as this makes theApp.m_pMainWnd->m_hWndthe game run twice as fast	//
				HRESULT result = DwmEnableComposition(DWM_EC_DISABLECOMPOSITION);
			}


			/*
			SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
			AfxGetApp()->SetThreadPriority(THREAD_PRIORITY_ABOVE_NORMAL);
			*/
		}
		else // normal performance
		{
			if(IsCompositionEnabled() == 0)
			{	
				// If LoadLibrary was successful, it means we are running in Windows Vista	//
				// Disable the Composition Mode as this makes theApp.m_pMainWnd->m_hWndthe game run twice as fast	//
				HRESULT result = DwmEnableComposition(DWM_EC_ENABLECOMPOSITION);
			}
			/*
			SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
			AfxGetApp()->SetThreadPriority(THREAD_PRIORITY_NORMAL);
			*/
		}
		
		

	}
		
	// show login wizard dialogue
	if(m_bDoneADraw && !m_loginWizardDlg.m_bActive)
	if(g_gfxDetails.bShowLoginWizard)
	{
		Mmain_log("m_loginWizardDlg.DoModal");
		/*
		m_loginWizardDlg.m_bActive = TRUE;
		m_loginWizardDlg.CopyPlayerLoginDetails();
		m_loginWizardDlg.DoModal();
		*/

		m_loginWizardDlg.m_bActive = TRUE;
		m_loginWizardDlg.CopyPlayerLoginDetails();
		//m_loginWizardDlg.DoModal();
		if(g_build.gameType == GAMETYPE_SNOOKER) 
			{
			m_loginWizardDlg.DestroyWindow();
			m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG2);
			}
		else if(g_build.gameType == GAMETYPE_POOL) 
			{
			m_loginWizardDlg.DestroyWindow();
			m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG3);
			}
		m_loginWizardDlg.ShowWindow(SW_SHOW);

		


	}

	if(firstTimeTimer)
	{
	/*
		CRect rect;
		// Update our Main View Width & Height //

		
		int offsetX = 788 - m_cx; // 800
		int ypos_start = (435-ceil(offsetX*0.5f)-g_yBarOffset);


		AfxGetMainWnd()->GetClientRect(&rect);
		
		g_dwMainViewWidth = rect.Width();
		g_dwMainViewHeight = ypos_start;


		::MoveWindow(g_hwndDX, 0, 0, g_dwMainViewWidth, g_dwMainViewHeight, true);
	*/

	}


	if(firstTimeTimer)
		firstTimeTimer = 0;

	//KillTimer(0);
	#endif //!MAIN_SERVER
	// ----------------------- //
	
	m_bOnTimerBusy = 0;

	#ifndef MAIN_SERVER
	// monitor player idle time online
	if(m_playerSockIdx != -1)
	{
		if(m_lobby)
		if(m_lobby->PlayingAGame(m_playerSockIdx))
			g_playerIdleTime = 0; // reset player's idle time counter, we're playing a game
		
		int  delaySecs = (int) (g_playerIdleTime/50);
		//char buff[80];
		//sprintf(buff, "delaySecs = %d", delaySecs);
		//ErrorMessage(g_wnd, buff);

		// idle for 5 minutes - status goes to 'away'
		if((delaySecs > 60*5/*10*/) && !m_bIdleAway)
		{
			m_bIdleAway = TRUE;
			SendRequestIdleAway(TRUE);
		}
				
		// exit lobby after 30 minutes delay idle time
		if(delaySecs >= 60*30)
		{
			g_playerIdleTime = 0; // reset player's idle time counter
			ExitFromLobby();
			AlertMessage("You were disconnected\r\nfrom the Server\r\nYou have been idle for too long");			
			return;
		}
	}
	#endif //!MAIN_SERVER
	
	return;
}

bool CGameAppView::CheckCheatPrograms()
{

	// For now we'll not crash the 
	if(m_playerSockIdx == -1) return false;

	if(m_timeToCrash != -1)
	{
		if(m_timeToCrash > 0) m_timeToCrash--;
		else
		{
			// Someone's been naughty.. Crash the App
			#ifndef MAIN_SERVER
			// do crash code eludes people who have been bad to think their app crashed for some reason other than dilberate crashing.
			while(1)
			{
				char buffer[80];				
				sprintf(buffer,"Cheating!'%s'",""); // blank name
				::MessageBox(0,buffer,"Fatal Error",MB_OK);
			}
			#endif //MAIN_SERVER
		}
		return true;
	}

	// Check if we're due to check Memory for cheat programs (every 10 seconds we check)
	if(m_timeToNextCheck) m_timeToNextCheck--;
	else
	{
		m_timeToNextCheck = 60 * 30;	// 30 Seconds until next check for cheat programs in memory

		
		static bool bCheater = false;
	
		// Lets check if fucking Cheat Engine is running, if so, log this and crash the application after user logs in
		if(FindRunningProcess("hack")) bCheater = true;
		else if(FindRunningProcess("cheat")) bCheater = true;
		else if(FindRunningProcess("havij")) bCheater = true;
	
		// If we found a cheat program, then tell Server this, so we can log the player's details and program they are using
		if(bCheater)
		{
			SendServerCheatAlert(m_cheatProcess);
			m_timeToCrash = 60 * 10;	// Crash after 10 seconds...
			return true;
		}
	}
	return false;
}



bool CGameAppView::FindRunningProcess(char *process) 
{
/*
Function takes in a string value for the process it is looking for like ST3Monitor.exe
then loops through all of the processes that are currently running on windows.
If the process is found it is running, therefore the function returns true.
*/
    char *compare;
    bool procRunning = false;

	// Make sure everything is in lower case for comparison
	char *processlc = NULL;
	processlc = _tcslwr(_tcsdup(process));


    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (hProcessSnap == INVALID_HANDLE_VALUE) {
        procRunning = false;
    } else {
        pe32.dwSize = sizeof(PROCESSENTRY32);
        if (Process32First(hProcessSnap, &pe32)) 
		{ // Gets first running process
			// Get String
            compare = pe32.szExeFile;

			// Convert string to all lower case first
			compare = _tcslwr(compare);

			char *pt = strstr(compare, processlc);
            if (pt != NULL) 
			{
                procRunning = true;

				// Update our Process that is flagged
				m_cheatProcess = pe32.szExeFile;
            } 
			else 
			{
                // loop through all running processes looking for process
                while (Process32Next(hProcessSnap, &pe32))
				{ 
                    // Get String
                    compare = pe32.szExeFile;

					// Convert string to all lower case first
					compare = _tcslwr(compare);

					char *pt = strstr(compare, processlc);
					if(pt != NULL)
                    {
                        // if found process is running, set to true and break from loop
                        procRunning = true;

						// Update our Process that is flagged
						m_cheatProcess = pe32.szExeFile;

                        break;
                    }
                }
            }
            // clean the snapshot object
            CloseHandle(hProcessSnap);
        }
    }

    return procRunning;
}


void CGameAppView::Process(float timeDelta)
{
	
	// Process Cheat Detection Programs
	// Checks Memory for known cheat programs. If we find any, Log this on the server and then crash the app
	CheckCheatPrograms();

	if(m_lobby->m_bInLobby)
	{// LOBBY //
		
		ProcessLobby(); // process lobby code
		ProcessEventTimer();
		

#ifndef MAIN_SERVER
		// Tempo Hack // 
		m_elCycle=EL_REST | EL_BALLS;

		//m_replay->Process();
		//if(m_elCycle&EL_BALLS) m_elCycle^=EL_BALLS;
		//m_elCycle=EL_BALLS; // Balls only
		m_snooker->Process(timeDelta);
#else


		// handle text wipe out of all lobby chat on server
		if(m_editExChat.GetLineCount() >= MAX_LOBBYCHATLINES)
		{
			// clear out all the text in the chat window
			DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
			m_editExChat.SetSel(ss,FALSE);
			m_editExChat.ReplaceSel(_T(""));
		}
		
		// rankings process
		//ProcessRankings(); // process rankings generator code !!!THIS IS DONE BY THE EventTimer NOW!!!
		if(m_hostcheckactive!= -1) // FAILSAFE: if undergoing a hostcheck... tick timeout down
			{
			m_hostchecktimeout--;
			if(!m_hostchecktimeout)
				{
				m_hostcheckactive = -1; // reset hostchecker.
				ErrorMessage(this, "Hostchecker timed out");
				}
			}
#endif //MAIN_SERVER

		#ifndef MAIN_SERVER
		// check if it's time to check for lobby select
		if(!m_lobbyRefreshDelay)
		{
			if(m_tabLobbyCtrlEx.m_bSelChanged)
			{
				m_tabLobbyCtrlEx.m_bSelChanged = FALSE;
				//int tabSelected = m_tabLobbyCtrlEx.GetCurSel();
				if(g_tabSelected == 1)// [Lobby Select]
				{
					m_lobbyRefreshDelay = 20;	// 20 Frame Delay between refreshing... //60*2; // approx. 1 min delay intervals
					m_connectStyle = CONNECTSTYLE_NORMAL;
					//ShowTerms(TRUE); // This Function Calls up ConnectToLobby if User Agrees with Terms - ConnectToLobby(TRUE);
					ConnectToLobby(TRUE);
				}
			}
		}
		#endif //!MAIN_SERVER

	}// LOBBY //
	else
	{// SNOOKER //
			//static int count = 1000;
			//if(count<=0);
			//else
			//{
			//char buf[80];
			//sprintf(buf, "m_cyc = %d", m_cyc);
			//ErrorMessage(this, buf);
			//count--;
			//}



		ProcessSponsor();

		

		ProcessSnooker(timeDelta); // process snooker code


		//if(m_elCycle==0 || m_elCycle==2) // only on first subcycle


		//if(m_elCycle&EL_REST)

		ProcessLobby(); // process lobby code




	}// SNOOKER //

	// update counters
	//--m_cyc++;
	//--m_seq++;
}


void CGameAppView::Draw(float timeDelta)
{
	// Render StatsWindow
	// m_statsWindow->Render();

	
	if(m_lobby->m_bInLobby)
	{// LOBBY //


		DrawLobby(); // draw lobby code

	}// LOBBY //
	else
	{// SNOOKER //

		DrawSnooker(timeDelta); // draw snooker code
	}// SNOOKER //


	// Achievements Redering and Processing...
	if (achievements != NULL)
	{
		achievements->Process();
		achievements->Render2D();
	}

	if (ladderRankings != NULL)
	{
		ladderRankings->Render2D();
	}

	
}

void CGameAppView::ProcessSnooker(float timeDelta)
{
	#ifndef MAIN_SERVER

///////////////////////////
///////////////////////////
///////////////////////////


	// Score Sounds
	if(g_build.addOnSfx && g_gfxDetails.bSoundVoices)
	{
		if(m_snooker->m_currentBreak!=0)
		{
			m_snooker->m_currentBreak100s = m_snooker->m_currentBreak / 100;
			m_snooker->m_currentBreak10s = (m_snooker->m_currentBreak - (m_snooker->m_currentBreak100s*100)) / 10;
			m_snooker->m_currentBreak1s = m_snooker->m_currentBreak - (m_snooker->m_currentBreak100s*100) - 
										  m_snooker->m_currentBreak10s*10;
			m_snooker->m_currentBreak = 0;

			/*
			char buff2[128];
			sprintf(buff2, "100s:%d, 10s:%d, 1s:%d, ", m_snooker->m_currentBreak100s, m_snooker->m_currentBreak10s, m_snooker->m_currentBreak1s);
			ErrorMessage(g_wnd, buff2);
			*/
		}

		if(m_snooker->m_sfxCount==0)
		{
			// hundreds
			if(m_snooker->m_currentBreak100s)
			{
				m_snooker->m_sfxCount = 30;
				if(m_snooker->m_currentBreak10s == 0 && m_snooker->m_currentBreak1s == 0)
				{
					if(g_build.addOnSfx && g_gfxDetails.bSoundVoices)
						Msfx_smpplayvol(&m_game_smp[38], 212); // 100
				}
				else
				{
					if(m_snooker->m_currentBreak10s == 1) m_snooker->m_sfxCount = 34;
					else if(m_snooker->m_currentBreak10s == 2) m_snooker->m_sfxCount = 35;
					else if(m_snooker->m_currentBreak10s == 3) m_snooker->m_sfxCount = 34;
					else if(m_snooker->m_currentBreak10s == 4) m_snooker->m_sfxCount = 32;
					else m_snooker->m_sfxCount = 34;

					if(g_build.addOnSfx && g_gfxDetails.bSoundVoices)
						Msfx_smpplayvol(&m_game_smp[47], 212); // 1xx				
				}
				m_snooker->m_currentBreak100s = 0;
			}
			// tens
			else if(m_snooker->m_currentBreak10s)
			{
				int teens = m_snooker->m_currentBreak10s*10 + m_snooker->m_currentBreak1s;
				m_snooker->m_sfxCount = 20;
				if(teens >= 10 && teens <= 19)
				{
					if(g_build.addOnSfx && g_gfxDetails.bSoundVoices)
						Msfx_smpplayvol(&m_game_smp[20+m_snooker->m_currentBreak1s], 212); // 10-19
					m_snooker->m_currentBreak1s = 0;
				}
				else
				{	
					if(m_snooker->m_currentBreak1s == 0)
					{
						if(g_build.addOnSfx && g_gfxDetails.bSoundVoices)
							Msfx_smpplayvol(&m_game_smp[30+m_snooker->m_currentBreak10s-2], 212); // 20s, 30s, ... 90s
					}
					else
					{
						switch(m_snooker->m_currentBreak10s)
						{
						case 2:
						case 3:
						m_snooker->m_sfxCount = 23;
						break;
						case 4:
						m_snooker->m_sfxCount = 20;
						break;
						case 5:
						m_snooker->m_sfxCount = 23;
						break;
						case 6:
						case 7:
						m_snooker->m_sfxCount = 25;
						break;
						case 8:
						m_snooker->m_sfxCount = 24;
						break;
						case 9:
						m_snooker->m_sfxCount = 28;
						break;
						}
						
						if(g_build.addOnSfx && g_gfxDetails.bSoundVoices)
							Msfx_smpplayvol(&m_game_smp[39+m_snooker->m_currentBreak10s-2], 212); // 2xs, 3xs, ... 9xs
					}
				}
				m_snooker->m_currentBreak10s = 0;
			}
			// units
			else if(m_snooker->m_currentBreak1s)
			{
				m_snooker->m_sfxCount = 20;
				if(g_build.addOnSfx && g_gfxDetails.bSoundVoices)
					Msfx_smpplayvol(&m_game_smp[11+m_snooker->m_currentBreak1s-1], 212);
				m_snooker->m_currentBreak1s = 0;
			}
		}

		if(m_snooker->m_sfxCount > 0) m_snooker->m_sfxCount--;
	}	

	


///////////////////////////
///////////////////////////
///////////////////////////

	
	int v;
	// network processing (1)
//	if(gameShell) gameShell->Process();

	// environment processing 
	// snooker processing
	m_replay->Process();
	
	// m_TextColorChangerDlg.Process();
	
	m_snooker->Process(timeDelta);

	//if(!v) return;
	if(m_elCycle&EL_REST);
	else return;
	
	m_environment->Process(); // Process lighting etc.	
	
	ProcessSnookerMiniCamExtra();
	ProcessSnookerChildWindows();	// i.e. enable / disable buttons etc.

	// AI Bot processing
	#ifdef TEST_BOT
	int colourseq = m_snooker->m_colourseq;
	m_bot->Process();
	m_snooker->m_colourseq = colourseq;
	#endif //TEST_BOT

	// network processing (2)
//	if(gameShell)
	if(!m_snooker->m_bPracticeMode && !m_lobby->m_bInLobby)
	if( m_snooker->MyTurn() )
	{
		// mouse cue movement
		if(m_snooker->m_cueBallSelect == 1)
		{	
			if(!((m_cyc)&(0x1f>>0)))
				{
				if(m_snooker->m_bMouseMoved)
					{
					m_snooker->m_bMouseMoved = 0;
					}
				}
		}
	 
		// mouse cue tip movement [+] can we ignore first cueballsect = 0 ? i.e. when u haven't selected a ball!
		if(m_snooker->m_cueBallSelect == 0 || m_snooker->m_cueBallSelect == 1 || m_snooker->m_cueBallSelect == 5)
		{
			if(!((m_cyc+(16>>0))&(0x1f>>0))) // Optimised to 8 bytes (previously 72bytes)
			{
			SendPlayerCueBallTipCompact(m_snooker->m_sPoint[0], m_snooker->m_sPoint[1], m_snooker->m_sPoint[2],
									  m_snooker->m_tableMousePos[0], m_snooker->m_tableMousePos[1], m_snooker->m_tableMousePos[2],
									  m_snooker->m_ballMouseOn, m_snooker->m_ballMousePos, m_snooker->m_cuetip,
									  m_snooker->m_nominateBall,
									  m_snooker->m_RaiseButt, m_snooker->m_RaiseButtOld,
									  m_snooker->m_cueAngle);
			}
		}
		
		// strike ball
		if(m_snooker->m_cueBallSelect == 10)
		{
			//if(!((m_cyc+(8>>0))&(0x1f>>0)))
			{
				m_snooker->m_cueBallSelect = 9;

			DWORD crc_now;
			#ifdef FIXEDMODE
				crc_now = m_snooker->GenerateBallCRCF();
			#else
				crc_now = m_snooker->GenerateBallCRC();
			#endif

				SendPlayerShot(m_strikeBallSendTmp.m_sPoint[0], m_strikeBallSendTmp.m_sPoint[1],m_strikeBallSendTmp.m_sPoint[2], 
											   m_strikeBallSendTmp.m_tableMousePos[0], m_strikeBallSendTmp.m_tableMousePos[1], m_strikeBallSendTmp.m_sPoint[2],
											   m_strikeBallSendTmp.m_cuetip,
											   m_strikeBallSendTmp.m_selectBall,
											   m_strikeBallSendTmp.m_strikeRnd, m_strikeBallSendTmp.m_strikeMaxRnd,
											   m_snooker->m_ballMouseOn, m_snooker->m_ballMousePos, m_snooker->m_nominateBall, m_snooker->m_testBall->m_colour,crc_now);
			}
		}
	}

	// practice mode code
	if(m_snooker->m_bPracticeMode)
	{
		// init computer practice mode
		//if(!m_snooker->m_bPracticeModeAlive)
		//{
		//	m_snooker->m_bPracticeModeAlive = 1;
		//	OnPracticeStart();
		//}

		// check for player just ending practice mode
		if(m_justEndedPractice && m_snooker->m_seat == -1) // player finished practice & has stood up
		{
			m_justEndedPractice = FALSE;
			m_standButton.PassParent(NULL); // make sure our stand button's parent is empty (NULL'ed)
			//DestroyGameShell();
			return;
		}

		// do strike ball receive code
		if( m_snooker->MyTurn() )
		{
			// strike ball
			if(m_snooker->m_cueBallSelect == 10)
			{
				//if(!((m_cyc+(8>>0))&(0x1f>>0)))
				{
					m_snooker->m_cueBallSelect = 9;
			DWORD crc_now;
			#ifdef FIXEDMODE
				crc_now = m_snooker->GenerateBallCRCF();
			#else
				crc_now = m_snooker->GenerateBallCRC();
			#endif
#if 0
///////////////////
m_strikeBallSendTmp.m_sPoint[0] = 0;
m_strikeBallSendTmp.m_sPoint[1] = 0;
m_strikeBallSendTmp.m_sPoint[2] = 0;
m_strikeBallSendTmp.m_tableMousePos[0] = -1000;
m_strikeBallSendTmp.m_tableMousePos[1] = 0;
m_strikeBallSendTmp.m_cuetip[0] = 0;
m_strikeBallSendTmp.m_cuetip[1] = 0;
m_strikeBallSendTmp.m_cuetip[2] = 0;
//m_strikeBallSendTmp.m_selectBall,
m_strikeBallSendTmp.m_strikeRnd = 0;
m_strikeBallSendTmp.m_strikeMaxRnd = 0;
//m_snooker->m_ballMouseOn; 
m_snooker->m_ballMousePos[0] = 0; 
m_snooker->m_ballMousePos[1] = 0; 
m_snooker->m_ballMousePos[2] = 0; 
//m_snooker->m_nominateBall, 
//m_snooker->m_testBall->m_colour,crc_now);
#endif
///////////////////
					m_snooker->m_bStrikeBallReplayDrawSL = 0;
					m_snooker->StrikeBallReceive(m_strikeBallSendTmp.m_sPoint[0], m_strikeBallSendTmp.m_sPoint[1],m_strikeBallSendTmp.m_sPoint[2], 
												 m_strikeBallSendTmp.m_tableMousePos[0], m_strikeBallSendTmp.m_tableMousePos[1], m_strikeBallSendTmp.m_sPoint[2],
												 m_strikeBallSendTmp.m_cuetip,
												 m_strikeBallSendTmp.m_selectBall,
												 m_strikeBallSendTmp.m_strikeRnd, m_strikeBallSendTmp.m_strikeMaxRnd,
												 m_snooker->m_ballMouseOn, m_snooker->m_ballMousePos, m_snooker->m_nominateBall, m_snooker->m_testBall->m_colour,crc_now);
				}
			}
		}
	}

	
	// computer mode code
	if(m_snooker->m_bComputerMode)
	{
		// init computer practice mode
		if(!m_snooker->m_bComputerModeAlive)
		{
			m_snooker->m_bComputerModeAlive = 1;
			ComputerPracticeInit();
		}
	}
	else
	{
		// deinit computer practice mode
		if(m_snooker->m_bComputerModeAlive)
		{
			m_snooker->m_bComputerModeAlive = 0;
			//ComputerPracticeDeinit();
		}
	}

		
	#endif //!MAIN_SERVER
}

void CGameAppView::ProcessSnookerChildWindows(void)
{
	#ifndef MAIN_SERVER
	
	// return if no "m_cueBallSelect" state change
	if(m_oldCBS == m_snooker->m_cueBallSelect)
		return;
	else
		m_oldCBS = m_snooker->m_cueBallSelect;

	// 'undo' button in pratice mode
	if(m_snooker->m_bPracticeMode) {
		if(m_snooker->m_cueBallSelect == 0)
			g_ButtonUndoActive = TRUE; // m_button[BUTTON_UNDO].EnableWindow(TRUE);
		else// if(m_snooker->m_cueBallSelect == 0)
			g_ButtonUndoActive = FALSE; //m_button[BUTTON_UNDO].EnableWindow(FALSE);

	}

	#endif //!MAIN_SERVER
}

void CGameAppView::ProcessSnookerMiniCamExtra(void)
{
	#ifndef MAIN_SERVER
/*	
	
	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	float fX = (float)(m_cx) / 1182;
	float fY = (float)(m_cx)*0.5f / 1182;
	
	GetWindowRect(&m_origin);

	int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view

	CRect rect;
	
	rect.top = 0; // not required here!
	rect.right = 400-13-offsetX;
	rect.left = rect.right - squareHeight;
	rect.bottom = 0; // not required here!
	
	CSize size = rect.Size();
	M3d_viewport(0,0,size.cx, size.cx, 0, 1);

	rect.left = rect.right - squareHeight;
	rect.top = (int)(2 + 32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset);
	rect.right = squareHeight; // width value
	rect.bottom = squareHeight; // height value
	

	//m_snooker->MiniCameraPosAtUpFovAspect(M3d_camera.pos,M3d_camera.at,M3d_camera.up,M3d_camera.fov,M3d_camera.aspect);
	
*/	

	CRect clientrect;
	::GetWindowRect(g_hwndDX, clientrect);
	int ypos_start = clientrect.Height()+2;
	int squareHeight = (int)m_cy - ypos_start;


	/*
	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	float fX = (float)(m_cx) / 1182;
	float fY = (float)(m_cx)*0.5f / 1182;
	*/

	// int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view


	M3d_vtx pos;
	M3d_vtx at;
	M3d_vtx up;
	pos[0] = g_pCameraMiniCam->_pos.x;
	pos[1] = g_pCameraMiniCam->_pos.y;
	pos[2] = g_pCameraMiniCam->_pos.z;
	at[0] = g_pCameraMiniCam->_look.x;
	at[1] = g_pCameraMiniCam->_look.y;
	at[2] = g_pCameraMiniCam->_look.z;
	up[0] = g_pCameraMiniCam->_up.x;
	up[1] = g_pCameraMiniCam->_up.y;
	up[2] = g_pCameraMiniCam->_up.z;


	m_snooker->MiniCameraPosAtUpFovAspect(pos, at, up, g_pCameraMiniCam->_cameraFov, g_pCameraMiniCam->_cameraAspect);
	int x,y;
	x = 163;
	y = ypos_start;
	m_snooker->SetMiniOffsetWindow(x,y, squareHeight, squareHeight);


	#endif //!MAIN_SERVER
}


// Main Draw Loop //
void CGameAppView::DrawSnooker(float timeDelta) // 33 - 40MClks top down, 20-30MClks in 3D (i.e. less in 3D than 2D)
{


	#ifndef MAIN_SERVER
	// check if a menu option has been selected?
	if(g_menuNItemID == -1)
	{
		///////////////////////////////////////////////////////////////////////////////
		// check which level-of-detail ball to use


		if(g_gfxDetails.bOptionsLowgfx) 
		{
			m_snooker->m_M3d_Ball_ptr = m_snooker->m_customTable->m_M3d_Ball_low;
		}
		if(g_gfxDetails.bOptionsMediumgfx) 
		{
			m_snooker->m_M3d_Ball_ptr = m_snooker->m_customTable->m_M3d_Ball_med;
		}
		if(g_gfxDetails.bOptionsHighgfx) 
		{
			m_snooker->m_M3d_Ball_ptr = m_snooker->m_customTable->m_M3d_Ball_high;
		}
		// Tempoary FIX for now, Set English Pool and Break Game Types to High Quality Only //
		if(m_snooker->m_customTable->m_type == CTTYPE_BREAK || m_snooker->m_customTable->m_type == CTTYPE_UKPOOL)  m_snooker->m_M3d_Ball_ptr = m_snooker->m_customTable->m_M3d_Ball_med;
		
		///////////////////////////////////////////////////////////////////////////////
		// check which GFX view mode to use
		if(g_gfxDetails.bOptions2DMode) m_GFXMode = 0;
		if(g_gfxDetails.bOptions2D3DMode) m_GFXMode = 1;
		if(g_gfxDetails.bOptions2DTVAutoMode) m_GFXMode = 2;
		if(g_gfxDetails.bOptions2D3DFreeMode) m_GFXMode = 3;

			
		///////////////////////////////////////////////////////////////////////////////
		// do 3D/2D drawing
		m_environment->Update(); // Update lighting etc. No clocks
		
		//Mmain_probestart();			
	
				
		Draw3D(timeDelta);					// 13MClks normal topdown, 20MClks when moving mouse, in 3D is iratic 13MClks-20MClks+



		//g_clkprobe[0] = Mmain_probestop();
		
		//Mmain_probestart();			
		// DrawMini3D();				// 14MClks to 20MClks+ normal very iratic,  10MClks in 3D motion (i.e. less when 3D!)



		//g_clkprobe[1] = Mmain_probestop();

		if(m_snooker->m_cueBallSelect != 2) // if in simulation mode (cueballselect = 2), so don't do extra rendering!
		{
			//Draw2D(timeDelta);					// 6MClks

			// Display foul options - this is to put opponent back in when they foul!!
			if( m_snooker->m_bFoulShowDialog )
			if( m_snooker->MyTurn() )
			{
				m_snooker->m_bFoulShowDialog = FALSE;
				//m_snooker->m_bFoul = FALSE;//[?]
				
				// display foul options dialog box
				if( !AfxGetMainWnd()->IsIconic() ) // check if window is not minimised (if minimised with a child dialog - then we can't maximise using mouse ???)
				{
					int offsetX = 788 - m_cx; // 800
					GetWindowRect(&m_origin);
					//m_snooker->m_foulDlg.SetWindowPos(&wndTop, m_origin.left + 678-offsetX-g_FIX_shiftX+40+4, m_origin.top + (int)(435-ceil(offsetX*0.5f)+1) - g_yBarOffset, 100+g_FIX_shiftX-40-4, (int)(m_cy - (435-ceil(offsetX*0.5f))) + g_yBarOffset, SWP_SHOWWINDOW);
					CRect clientrect;
					::GetClientRect(g_hwndDX, clientrect);
					int ypos_start = clientrect.Height();

					m_snooker->m_foulDlg.SetWindowPos(&wndTop, 
						m_origin.left + 688-offsetX-g_FIX_shiftX+34, 
						m_origin.top+ypos_start+8, 
						100+g_FIX_shiftX-40+4, 
						m_origin.Height() - ypos_start - 14, 
						SWP_SHOWWINDOW);					
					
					m_snooker->m_foulDlg.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
					//SetFocus();
					PreviousWndEditSetFocus();
				}
			}

		}
	}

	
	
	// redraw the menu bar & items
	else if((g_menuNItemID != g_menuNItemIDOld)) 
	{
		g_menuNItemIDOld = g_menuNItemID;
		AfxGetMainWnd()->DrawMenuBar();
	}
	
	m_bDisableOnDraw = g_bMenuSelect;

	#endif //!MAIN_SERVER
}

void CGameAppView::ProcessLobby(void)
{

	// network processing (1)
	if(mainShell) mainShell->Process();



	// snooker processing
	m_lobby->Process();
}

void CGameAppView::DrawLobby(void)
{
	Sleep(2);

	// check if a menu option has been selected?
	if(g_menuNItemID == -1)
	{	
		// do 3D/2D drawing
		Draw2DLobby();
	}
	
	// redraw the menu bar & items
	else if((g_menuNItemID != g_menuNItemIDOld)) 
	{
		g_menuNItemIDOld = g_menuNItemID;
		AfxGetMainWnd()->DrawMenuBar();
	}
	
	m_bDisableOnDraw = g_bMenuSelect;
}

void CGameAppView::Render3DSetupCamera(void)
{
#ifndef MAIN_SERVER

	// If we have our Middle Mouse Button Down, then allow user to Pan View //
	
	g_pCamera->_cameraFov = D3DX_PI * 0.20f;

	if(g_pCameraMode) return;



	// 3D View for 2D3D Mode //
	if(m_snooker->m_CameraMode == CAMERA_MODE_WATCH)
	{
		if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			
			g_pCamera->_cameraFov = 1.570795f/5.0f;//D3DX_PI * 0.15f;
			g_pCamera->_up = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
			g_pCamera->_look = D3DXVECTOR3(500.0f, 0.0f, 0.0f);
			g_pCamera->SetPosition(D3DXVECTOR3(5800.0f, 0.0f, 2900.0f));

		}
		else if(g_build.gameType == GAMETYPE_POOL)
		{
			g_pCamera->_cameraFov = D3DX_PI * 0.15f;
			g_pCamera->_up = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
			g_pCamera->_look = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
			g_pCamera->SetPosition(D3DXVECTOR3(1.35f*3800.0f, 0.0f, 1.55f*1500.0f));
		}
	}

	// 3D camera mode (User can Line Up Shot in this Mode)
	// This Mode isn't used //
	else if(m_snooker->m_CameraMode == CAMERA_MODE_PLAYER_3D)
	{
	float ang = m_cameraAngle*DEG2RAD;
	g_pCamera->SetPosition(D3DXVECTOR3(2000*cos(ang), 2000*sin(ang), 2000.0f));
	}

	// TV camera mode (Toggles 3D views, Pocket CAMs etc) During Simmulation Only
	else if(m_snooker->m_CameraMode == CAMERA_MODE_TV)
	{
		g_pCamera->_cameraFov = D3DX_PI * 0.17f;
		g_pCamera->_up = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
		g_pCamera->SetPosition(D3DXVECTOR3(1.15f*m_TVcameraX_pos[0], m_TVcameraY_pos[0], 1.15f*m_TVcameraZ_pos[0]));

	}
	else if(m_snooker->m_CameraMode == CAMERA_MODE_3DFREE)
	{
		g_pCamera->_cameraFov = D3DX_PI * 0.17f;
		g_pCameraMode = true;
		g_pCamera->_maxliftangle = D3DX_PI * 0.5f * 0.9f; 
		g_pCamera->_minliftangle = D3DX_PI * 0.5f * 0.08f;
		g_pCamera->_up = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
		g_pCamera->SetPosition(D3DXVECTOR3(1.15f*m_TVcameraX_pos[0], m_TVcameraY_pos[0], 1.15f*m_TVcameraZ_pos[0]));

	}
	else if(m_snooker->m_CameraMode == CAMERA_MODE_DEMO || m_snooker->m_CameraMode == CAMERA_MODE_DEMO_FIXED)
	{
		float distnear;
		float distfar;

		if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			distnear = 3890.0f;
			distfar = 3910.0f;
		}
		else
		{
			distnear = 3390.0f;
			distfar = 3410.0f;
		}


		//g_pCamera->SetPosition(D3DXVECTOR3(m_TVcameraX_pos[0], m_TVcameraY_pos[0], 1000.0f));
		g_pCameraMode = true;

		if(m_snooker->m_CameraMode == CAMERA_MODE_DEMO)
		{
			if(g_pCameraFree->_distance > distfar) g_pCameraFree->_distancev -= 0.1f;
			else if(g_pCameraFree->_distance < distnear) g_pCameraFree->_distancev += 0.1f;
			else;
		

		//g_pCameraFree->_maxliftangle = D3DX_PI * 0.5f * 0.21f; 
		//g_pCameraFree->_minliftangle = D3DX_PI * 0.5f * 0.19f;

		float distancexy;
		distancexy = sqrt( (g_pCameraFree->_pos[0] * g_pCameraFree->_pos[0]) + (g_pCameraFree->_pos[1] * g_pCameraFree->_pos[1]) );

		// Find the angle of elevation we're at.. Make sure this doesn't exceed 80 Degrees //
		// Elevation = atan(_pos[2] / _distance) //
		float e_ang = atan(g_pCameraFree->_pos[2] / distancexy);
		
		if( e_ang > (D3DX_PI * 0.5f * 0.21f) ) g_pCameraFree->MouseUpdate(0.0f, -0.5f);
		else if( e_ang < (D3DX_PI * 0.5f * 0.19f) ) g_pCameraFree->MouseUpdate(0.0f, 0.5f);

		g_pCameraFree->MouseUpdate(0.05f, 0.0f);
		}
		else
		{
			g_pCameraFree->_up = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
			g_pCameraFree->_look = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
			g_pCameraFree->SetPosition(D3DXVECTOR3(m_TVcamera_Demo[0], m_TVcamera_Demo[1], m_TVcamera_Demo[2]));

		}

		g_pCameraFree->_up = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
		

	}


	// 2D camera mode
	else if(m_snooker->m_CameraMode == CAMERA_MODE_PLAYER_2D)
	{
		if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			g_pCamera->_up = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
			g_pCamera->_look = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
			g_pCamera->SetPosition(D3DXVECTOR3(0.0f, 0.0f, 3000.0f));
		}
		else if(g_build.gameType == GAMETYPE_POOL)
		{
			
			if(m_snooker->m_M3d_Table_ptr == &m_snooker->m_customTable->m_M3d_ukTable)
				{
					g_pCamera->_up = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
					g_pCamera->_look = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
					g_pCamera->SetPosition(D3DXVECTOR3(0.0f, 0.0f, 2200.0f));
				}
			else{
					g_pCamera->_up = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
					g_pCamera->_look = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
					g_pCamera->SetPosition(D3DXVECTOR3(0.0f, 0.0f, 2400.0f));
				}
			
		}


}

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

#endif 

}

void CGameAppView::Render3DSetupStates(void)
{

#ifndef MAIN_SERVER

	if(g_bWireframeChanged)
	{
		g_bWireframeChanged = FALSE;
		m_bOnSizeDrawTmpSurf = TRUE;

		// render in wireframe mode?
		if(g_gfxDetails.bOptionsWireframe)
			M3d_fillmode(D3DFILL_WIREFRAME);
		else
			M3d_fillmode(D3DFILL_SOLID);
	}

	
	
	GetWindowRect(&m_origin);
	m_viewportWidth = m_origin.right-m_origin.left;
	//m_viewportHeight = (m_origin.right-m_origin.left)*0.5f;
	m_viewportHeight = (m_origin.right-m_origin.left)*0.5f - (g_yBarOffset-40);

		
	M3d_viewport(0, 0, m_viewportWidth, m_viewportHeight, 0, 1);
		
	// clip height correction (so we get our table 2:1 rectangle)
	int bottomCorrection = m_origin.top + m_viewportHeight;
	if(bottomCorrection > m_origin.bottom)
		bottomCorrection = m_origin.bottom;

	Mgfx_clip(m_origin.left,m_origin.top,m_origin.right,bottomCorrection);

	M3d_clear(20,7,0);

#endif
}





void CGameAppView::Render3DBalls(BOOL bMainView, BOOL alpha_on)
{

#ifndef MAIN_SERVER

	int n;
	M3d_vtx pos;
if(bMainView)
{


	//m_snooker->DrawBall(0);
	//m_snooker->DrawBall(1);
	//m_snooker->DrawBall(2);
	//m_snooker->DrawBall(3);
	//m_snooker->DrawBall(4);
	//m_snooker->DrawBall(5);
	//m_snooker->DrawBall(6);
	//m_snooker->DrawBall(7);

	for(n=0;n<MAX_TOTALBALLS;n++)
	{
		m_snooker->DrawBall(n);		
	} // end entity scan

	// draw next ball indicator
	int nextBallcolour = m_snooker->m_colourseq;
		if(nextBallcolour == 0)
			nextBallcolour = 1;

	int testColour = m_snooker->m_testBall->m_colour;
	
	if(g_build.gameType == GAMETYPE_POOL)
	//if(!m_snooker->m_bPracticeMode)	
	if(m_snooker->MyTurn())
	if( (m_snooker->m_customTable->m_type == CTTYPE_9BALL) || (m_snooker->m_customTable->m_type == CTTYPE_ROTATIONBALL) ||
		(m_snooker->m_customTable->m_type == CTTYPE_6BALL) || (m_snooker->m_customTable->m_type == CTTYPE_10BALL) )
	if(m_snooker->m_cueBallSelect != 2 && m_snooker->m_cueBallSelect != 5)
	if(testColour != nextBallcolour) // when exit traj. is shown. Don't draw indicator!
	{				  
		CVector P = m_snooker->m_ball[nextBallcolour]->m_P;
		pos[0] = P.x;
		pos[1] = P.y;
		pos[2] = P.z + BALL_DRAWOFFSETZ;//+BALL_RADIUS*1.0f;
		m_snooker->DrawCircle(pos, BALL_RADIUS*1.4f, RGBA(255,255,255,16), 0.10f, 32);
	}

	// POOL - BOWLS only...
	if(g_build.gameType == GAMETYPE_POOL)
	if(!m_snooker->m_bPracticeMode)	
	if(m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
	if(m_snooker->m_cueBallSelect != 2)
	{
		nextBallcolour = m_snooker->m_bestScore;
		if(nextBallcolour >= 1 && nextBallcolour <= 10) // 5 blues(1-5), 5 reds(6-10)
		{
			CVector P = m_snooker->m_ball[nextBallcolour]->m_P;
			pos[0] = P.x;
			pos[1] = P.y;
			pos[2] = P.z + BALL_DRAWOFFSETZ;//+BALL_RADIUS*1.0f;
			m_snooker->DrawCircle(pos, BALL_RADIUS*1.4f, RGBA(255,255,255,16), 0.10f, 32);
		}
	}


	// draw nominated ball indicator
	if(m_snooker->m_nominateBall)
	if(m_snooker->m_cueBallSelect != 2)
	//if(!((m_cyc>>4)&1))
	{
#ifdef FIXEDMODE
		CVector P;
		P.x = FROMFIXSMALL(m_snooker->m_ball[m_snooker->m_nominateBall]->f_P.x);
		P.y = FROMFIXSMALL(m_snooker->m_ball[m_snooker->m_nominateBall]->f_P.y);
		P.z = FROMFIXSMALL(m_snooker->m_ball[m_snooker->m_nominateBall]->f_P.z);
#else
		CVector P = m_snooker->m_ball[m_snooker->m_nominateBall]->m_P;
#endif
	
		


		static float fy = 0.0f; 
		static int oldtarget = -1;
		static float impulse = 0.0f;
		
		if(m_snooker->m_nominateBall == -1)
		{
			oldtarget = -1;
			return;
		}


		if(m_snooker->m_nominateBall != oldtarget)
		{
			fy = 0.0f;
			oldtarget = m_snooker->m_nominateBall;
			impulse = 0.4f;
		}

		impulse *= 0.90f;
		fy += impulse;


		M2d_sprshape(M2D_SHAPE_RECTCENTER);

		D3DXMATRIX matRotX, matRotY, matRotZ, matTrans, matScale;

		// Calculate Scale matrix
		//D3DXMatrixScaling(&matScale, 38.0f, 38.0f, 1.0f);
		float sc = 45.0f + sin(fy) * 9.0f;
		D3DXMatrixScaling(&matScale, sc, sc, 1.0f);


		// Calculate rotation matrix
		D3DXMatrixRotationX( &matRotX, 0.0f );
		D3DXMatrixRotationY( &matRotY, -D3DX_PI );
		D3DXMatrixRotationZ( &matRotZ, 0.0f );
		
		// Calculate a translation matrix
		D3DXMatrixTranslation(&matTrans, P.x, P.y, P.z + BALL_DRAWOFFSETZ);

		D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
		g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);

		g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
		//M3d_sprdraw(m_snooker->m_TextureDisc);
		M3d_sprdraw(m_snooker->m_TextureRing);
		g_pDevice->SetRenderState(D3DRS_LIGHTING, true);
	}



}

else { // Mini Cam

	// Render De-Selected Balls first ////////////////////////////////////////	
	for(n=0;n<MAX_TOTALBALLS;n++)
		if(n!=m_snooker->m_selectBall)
		{
		m_snooker->DrawBall(n);
		}	

	// Render Selected Ball last ////////////////////////////////////////
	n = m_snooker->m_selectBall;


	char proceed = 0;
	if(g_build.gameType == GAMETYPE_SNOOKER && m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
		{
		if(m_snooker->m_ball[n]->m_colour == YELLOW && !m_snooker->m_bTurn1P) proceed = 1;
		if(m_snooker->m_ball[n]->m_colour == WHITE && m_snooker->m_bTurn1P) proceed = 1;
		}
	else if(m_snooker->m_ball[n]->m_colour == WHITE) proceed = 1;


	if(proceed)
		{
		m_snooker->DrawBall(n, TRUE); // Trans
		}
	else{
		m_snooker->DrawBall(n); // Solid		
		}

}// end else

#endif
}// end method

void CGameAppView::Render3DBeatle(void)
{

}



void CGameAppView::Render3DCueTip(void)
{
#ifndef MAIN_SERVER

	D3DXMATRIX matView;
    D3DXMATRIX matWorld;
    D3DXMATRIX matRotation;
    D3DXMATRIX matTranslation;
	

	if( g_pDevice )
	{

		D3DXMATRIX matRotX, matRotY, matRotZ, matTrans, matScale;

		if(m_snooker->m_ballMouseOn || m_snooker->m_bCueTipReadyFirstTime)
		if(m_snooker->m_bCueTipReady || m_snooker->m_bCueTipReadyFirstTime)
		if(m_snooker->m_cueBallSelect == 5)
		{
			if(g_gfxDetails.bEyeCamDrawCueTip)
			{
				// draw cue tip [BLACK DOT]
				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.r = 0; 
				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.g = 0;
				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.b = 0;
				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.a = 1;

				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Specular.r = 0;
				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Specular.g = 0;
				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Specular.b = 0;
				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Specular.a = 1;

				
				// Calculate Scale matrix
				D3DXMatrixScaling(&matScale, 0.011f, 0.011f, 0.011f);

				// Calculate rotation matrix
				D3DXMatrixRotationX( &matRotX, 0.0f );
				D3DXMatrixRotationY( &matRotY, 0.0f );
				D3DXMatrixRotationZ( &matRotZ, 0.0f );
				
				// Calculate a translation matrix
				D3DXMatrixTranslation(
					&matTrans, 
					m_snooker->m_ballMousePos[0], 
					m_snooker->m_ballMousePos[1], 
					m_snooker->m_ballMousePos[2]);

				D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
				g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
				M3d_objectdraw(m_snooker->m_M3d_Ball_ptr);
			}
			else
			{
				/*
				// draw cue tip

				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.r = 0.0f;
				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.g = 0.0f;
				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.b = 0.0f;
				m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.a = 0.1f;
				
				// [always draw the cuetip]

				// Calculate Scale matrix
				D3DXMatrixScaling(&matScale, 0.018f, 0.018f, 0.018f);

				// Calculate rotation matrix
				D3DXMatrixRotationX( &matRotX, 0.0f );
				D3DXMatrixRotationY( &matRotY, 0.0f );
				D3DXMatrixRotationZ( &matRotZ, 0.0f );
				
				// Calculate a translation matrix
				D3DXMatrixTranslation(
					&matTrans, 
					m_snooker->m_ballMousePos[0], 
					m_snooker->m_ballMousePos[1], 
					m_snooker->m_ballMousePos[2]);

				matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
				g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);

				M3d_objectdraw(m_snooker->m_M3d_Ball_ptr);
				*/
		
		
				g_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE); // Disable Z-Buf.
				//////////////////////

				// draw snooker cue (for mini-cam.)
				
				M3d_vtx vec;
				
				//vec[0] = M3d_camera.at[0] - M3d_camera.pos[0];
				//vec[1] = M3d_camera.at[1] - M3d_camera.pos[1];

				vec[0] = g_pCameraMiniCam->_look[0] - g_pCameraMiniCam->_pos[0];
				vec[1] = g_pCameraMiniCam->_look[1] - g_pCameraMiniCam->_pos[1];


				float angle2D = atan2((double)vec[1], (double)vec[0]);
				float cueFeather;


				cueFeather = - (BALL_RADIUS*5.2f)*(m_snooker->m_cuePowerPercentage/100.0f) + 
								   ((BALL_RADIUS*5.2f)*(m_snooker->m_cuePowerPercentage/100.0f) * sin(g_seq*0.05*CUE_FEATHER_SPEED));
				// ------------------------- //


					
			
				// Calculate Scale matrix
				D3DXMatrixScaling(&matScale, 1.0f, 1.0f, 1.0f);

				// Calculate rotation matrix
				D3DXMatrixRotationX( &matRotX, 0.0f );
				D3DXMatrixRotationY( &matRotY, 0.0f );
				D3DXMatrixRotationZ( &matRotZ, angle2D + (D3DX_PI*1.5f));
				
				// Calculate a translation matrix
				D3DXMatrixTranslation(
					&matTrans, 
					m_snooker->m_ballMousePos[0], 
					m_snooker->m_ballMousePos[1], 
					m_snooker->m_ballMousePos[2]);

				matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;


				D3DXMatrixTranslation(&matTrans, 0, cueFeather, 0);
				matWorld = matTrans*matWorld;


				g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
				M3d_objectdraw(m_snooker->m_M3d_Ball_ptr);


				if(m_snooker->m_cuePowerPercentage != 0) // if cue_power is not 0%, draw cue		
				if(g_gfxDetails.bEyeCamDrawCueSolid)
				{
					M3d_objectdraw(m_snooker->m_M3d_Cue_ptr);
				}


			
				if(m_snooker->m_cuePowerPercentage != 0) // if cue_power is not 0%, draw cue
				if(g_gfxDetails.bEyeCamDrawCueSolid || g_gfxDetails.bEyeCamDrawCueTransparent)
				{

					// transparent static cue
					for(int n=0;n<m_snooker->m_M3d_Cue_ptr->mesh_n;n++)
					{
						m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.a = 0.25f;
						m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Specular.a = 0.25f;
						m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.a = 0.25f;
						m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.a = 0.25f;
						m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Power = D3D_MATERIAL_POWER;//10;
					}

					// Calculate a translation matrix
					D3DXMatrixTranslation(
						&matTrans, 
						m_snooker->m_ballMousePos[0], 
						m_snooker->m_ballMousePos[1], 
						m_snooker->m_ballMousePos[2]);

					matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
					g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
					M3d_objectdraw(m_snooker->m_M3d_Cue_ptr);
					

					// reset to solid cue
					for(int n=0;n<m_snooker->m_M3d_Cue_ptr->mesh_n;n++)
					{
						m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.a = 1.0f;
						m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Specular.a = 1.0f;
						m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.a = 1.0f;
						m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.a = 1.0f;
						m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Power = D3D_MATERIAL_POWER;//10;
					}

				}

				g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE); // Enable Z-Buf.
			}

		}

	}
#endif

}






void CGameAppView::Render3DCueTipDC(void)
{
#ifndef MAIN_SERVER


	
/*
	// Get Device Context for Main Window //

	CDC *pDC = NULL;
	pDC = GetDC();

	if(pDC)
	{ 
		CBrush brBlue(RGB(0,0,255));  //Creates a blue brush
		CBrush brBlack(RGB(0,0,0));  //Creates a blue brush


		static bool firsttime = 1;
		if(firsttime)
		{
	 
			MiniCamDC.CreateCompatibleDC(pDC);

			// init double buffer with empty bitmap
			CRect rcClient;
			GetClientRect(rcClient);
			m_Bitmap.CreateCompatibleBitmap(pDC, 256, 256);
			CBitmap *pOldBitmap = MiniCamDC.SelectObject(&m_Bitmap);

			//MiniCamDC.FillRect(CRect(0,0,255,255), &brBlack);

			firsttime = 0;
		}

		int x,y,w,h;

		//if(m_snooker->m_ballMouseOn || m_snooker->m_bCueTipReadyFirstTime)
		//if(m_snooker->m_bCueTipReady || m_snooker->m_bCueTipReadyFirstTime)
		//if(m_snooker->m_cueBallSelect == 5)
		{
			// draw cue tip [BLACK DOT]
			
			x = m_snooker->m_mouseX-m_snooker->m_moffsetX;
			y = m_snooker->m_mouseY-m_snooker->m_moffsetY;
			w = m_snooker->m_mwindowWidth;
			h = m_snooker->m_mwindowHeight;

			CRect clientrect;
			::GetWindowRect(g_hwndDX, clientrect);
			int ypos_start = clientrect.Height()+2;
			int chat_height = (int)m_cy - ypos_start;
			int radius = 10;


			pDC->StretchBlt(163-2, ypos_start, w, h, &MiniCamDC, 0, 0, 255, 255, SRCCOPY);

			if( x>=radius && x <= (w-radius) )
			if( y>=radius && y <= (h-radius) )
			{


				//pDC->BitBlt(163, ypos_start, w, h, &MiniCamDC, 0, 0, SRCCOPY);
				

				CBrush* pOldBrush;
			
				
				pOldBrush = (CBrush*)pDC->SelectObject(&brBlue);
				pDC->Ellipse(163+x-radius, ypos_start+y-radius, 163+x+radius, ypos_start+y+radius);
				
				pDC->SelectObject(pOldBrush);



				//char buf[80];
				//sprintf(buf, "x:%d, y:%d, w:%d, h:%d", x, y, w, h);
				//ErrorMessage(this, buf);
			}

		}
	}
*/
#endif

}





void CGameAppView::Render3DOverLayTable(void)
{
#ifndef MAIN_SERVER

	g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
	// Draw chalk marks...
	m_snooker->DrawChalkMarks();
	g_pDevice->SetRenderState(D3DRS_LIGHTING, true);



	// Draw Snooker Table Spots & Lines //

	D3DXMATRIX matView;
    D3DXMATRIX matWorld;
    D3DXMATRIX matRotation;
    D3DXMATRIX matTranslation;

	if( g_pDevice )
	{
		float xoffset;

		if(g_build.gameType == GAMETYPE_SNOOKER) xoffset = WORLD_X(912);
		else
		{
			if(m_snooker->m_M3d_Table_ptr == &m_snooker->m_customTable->m_M3d_ukTable)
				{
					xoffset = WORLD_X(772);
				}
			else{
					xoffset = WORLD_X(772);
				}
		}



		M3d_sprdraw_PLATE.mat->d3dm.Diffuse.a = 0.5f;
		M3d_sprdraw_PLATE.mat->d3dm.Ambient.a = 0.5f;
		M3d_sprdraw_PLATE.mat->d3dm.Emissive.a = 0.5f;
		M3d_sprdraw_PLATE.mat->d3dm.Specular.a = 0.5f;


		D3DXMATRIX matRotX, matRotY, matRotZ, matTrans, matScale;
		
		M2d_sprshape(M2D_SHAPE_RECTCENTER);
		// Calculate Scale matrix
		D3DXMatrixScaling(&matScale, 155.0f, 155.0f, 1.0f);

		// Calculate rotation matrix
		D3DXMatrixRotationX( &matRotX, 0.0f );
		D3DXMatrixRotationY( &matRotY, -D3DX_PI );
		D3DXMatrixRotationZ( &matRotZ, 0.0f );

		// Calculate a translation matrix
		D3DXMatrixTranslation(&matTrans, 5-150.0f-xoffset-BALL_RADIUS*(0.2f+0.5f), 155, 2);

		D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
		g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);


		

		
		if(g_build.gameType == GAMETYPE_SNOOKER || (g_build.gameType == GAMETYPE_POOL && m_snooker->m_M3d_Table_ptr == &m_snooker->m_customTable->m_M3d_ukTable) )
		{
			// Top Half of D //
			M3d_sprdraw(m_snooker->m_TextureDTop);


			// Botton Half of D //
			D3DXMatrixTranslation(&matTrans, 5-150.0f-xoffset-BALL_RADIUS*(0.2f+0.5f), -155, 2);
			matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
			M3d_sprdraw(m_snooker->m_TextureDBot);
		}

		
		

		// Draw Baulk Line //
		float height;
		if(g_build.gameType == GAMETYPE_SNOOKER) height = 860.0f;
		else 
		{
			if(m_snooker->m_M3d_Table_ptr == &m_snooker->m_customTable->m_M3d_ukTable) height = 555.0f;
			else height = 640.0f;
		}
		D3DXMatrixTranslation(&matTrans, -xoffset-BALL_RADIUS*0.2f, 0, 2);
		D3DXMatrixScaling(&matScale, 8.0f, height, 1.0f);
		matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
		g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
		
		M3d_sprdraw(m_snooker->m_TextureWhite);

		

		// Draw Colour Spots //
		M3d_vtx pos;
		D3DXMatrixScaling(&matScale, 6.0f, 6.0f, 1.0f);	



		


		if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			// green spot
			pos[0] = -WORLD_X(912)-BALL_RADIUS*0.2f; pos[1] = -WORLD_Y(395-12);
			D3DXMatrixTranslation(&matTrans, pos[0], pos[1], 2);
			matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
			M3d_sprdraw(m_snooker->m_TextureDisc);


			// brown spot
			pos[0] = -WORLD_X(912)-BALL_RADIUS*0.2f; pos[1] = -WORLD_Y(297);
			D3DXMatrixTranslation(&matTrans, pos[0], pos[1], 2);
			matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
			M3d_sprdraw(m_snooker->m_TextureDisc);
			// yellow spot
			pos[0] = -WORLD_X(912)-BALL_RADIUS*0.2f; pos[1] = -WORLD_Y(199+12);
			D3DXMatrixTranslation(&matTrans, pos[0], pos[1], 2);
			matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
			M3d_sprdraw(m_snooker->m_TextureDisc);
			// blue spot
			pos[0] = -WORLD_X(591); pos[1] = -WORLD_Y(297);
			D3DXMatrixTranslation(&matTrans, pos[0], pos[1], 2);
			matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
			M3d_sprdraw(m_snooker->m_TextureDisc);
			// pink spot
			pos[0] = -WORLD_X(331+10-2); pos[1] = -WORLD_Y(297);
			D3DXMatrixTranslation(&matTrans, pos[0], pos[1], 2);
			matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
			M3d_sprdraw(m_snooker->m_TextureDisc);
			// black spot
			pos[0] = -WORLD_X(175-10); pos[1] = -WORLD_Y(297);
			D3DXMatrixTranslation(&matTrans, pos[0], pos[1], 2);
			matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
			M3d_sprdraw(m_snooker->m_TextureDisc);
		}
		else
		{
			if(m_snooker->m_M3d_Table_ptr == &m_snooker->m_customTable->m_M3d_ukTable)
			{
			// brown spot
			pos[0] = -xoffset-BALL_RADIUS*0.2f; pos[1] = -WORLD_Y(297);
			D3DXMatrixTranslation(&matTrans, pos[0], pos[1], 2);
			matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
			M3d_sprdraw(m_snooker->m_TextureDisc);
			// blue spot
			pos[0] = -WORLD_X(591); pos[1] = -WORLD_Y(297);
			D3DXMatrixTranslation(&matTrans, pos[0], pos[1], 2);
			matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
			M3d_sprdraw(m_snooker->m_TextureDisc);
			// black spot
			pos[0] = -WORLD_X(175-10); pos[1] = -WORLD_Y(297);
			D3DXMatrixTranslation(&matTrans, pos[0], pos[1], 2);
			matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
			M3d_sprdraw(m_snooker->m_TextureDisc);

			}

		}



	}
#endif 
}


void CGameAppView::Render3DSnookerTable(char type, float alpha)
{
#ifndef MAIN_SERVER

	D3DXMATRIX matView;
    D3DXMATRIX matWorld;
    D3DXMATRIX matRotation;
    D3DXMATRIX matTranslation;

	if( g_pDevice )
	{
		D3DXMATRIX matRotX, matRotY, matRotZ, matTrans, matScale;

		// Calculate Scale matrix
		D3DXMatrixScaling(&matScale, 1.0f, 1.0f, 1.0f);

		// Calculate rotation matrix
		D3DXMatrixRotationX( &matRotX, 0.0f );
		D3DXMatrixRotationY( &matRotY, 0.0f );
		D3DXMatrixRotationZ( &matRotZ, 0.0f );
		
		// Calculate a translation matrix
		D3DXMatrixTranslation(&matTrans, 0.0f, 0.0f, 0.0f);

		D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
		g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);

		//
		// Draw the scene:
		//
		// g_pDevice->SetMaterial(&d3d::WHITE_MTRL);
		// g_pDevice->SetTexture(0, Tex);
		M3d_objectdraw(m_snooker->m_M3d_Table_ptr);


	}

#endif
}




void CGameAppView::Render3DCue(float timeDelta, float alpha)
{
#ifndef MAIN_SERVER
	
		
	M3d_vtx pos;
	M3d_vtx scale;
	M3d_vtx rot;
	float angle2D = m_snooker->m_cueAngle;
	int n;

	// Save the Angle, for use in Automatic Camera View //
	g_ACamAngle = angle2D + 3.14159;



	if(m_snooker->m_cuePowerPercentage == 0) // if cue_power is 0% dont draw cue
		return;


	if(m_snooker->m_cueBallSelect == 5)
	{
		m_snooker->m_testBallInitialSpeed = BALL_MAXSPEED*(m_snooker->m_cuePowerPercentage/100.0f);
		m_snooker->m_strikeMaxRnd = m_snooker->GetStrikeBallError(FALSE); // [*NEW FOR POOL THICKNESS OF TRI-LINES]
	}

// draw cue (temp for now!!!)
//if(!g_bOptionsHighgfx)
if(m_snooker->m_bCueState || m_snooker->m_cueStrikeTime)
//if((int)m_snooker->m_cuePowerPercentage > 0)
{	
	// raise cue-butt + orientation

	float cue_RaiseButt = (float)m_snooker->m_RaiseButt*0.89 + CUE_DEFAULT_RAISEDBUTT; // always 0-90degress
	float cue_RaiseButt90 = 90.0f + CUE_DEFAULT_RAISEDBUTT;

	// cue feather-up offset
	float cueFeather;
	/*
	cueFeather = -(BALL_RADIUS*1.5f) -
				   (BALL_RADIUS*5.2f)*(m_snooker->m_cuePowerPercentage/100.0f) + 
				   ((BALL_RADIUS*5.2f)*(m_snooker->m_cuePowerPercentage/100.0f) * sinf(g_seq*0.05f*CUE_FEATHER_SPEED));
	*/
	
	static float seq = 0;
	//seq += timeDelta*7.0f;
	//seq += 0.2f;
	seq += 0.1f;
	cueFeather = -(BALL_RADIUS*1.5f) -
				   (BALL_RADIUS*5.2f)*(m_snooker->m_cuePowerPercentage/100.0f) + 
				   ((BALL_RADIUS*5.2f)*(m_snooker->m_cuePowerPercentage/100.0f) * sinf(seq));
	

	if(m_snooker->m_cueStrikeTime)
	{
		cueFeather = m_snooker->m_cueStrikeDist;//0.0f;
	}



	/////////////////////////////////	
	// draw cue-shadow line
	// angle2D = atan2((double)vec[1], (double)vec[0]);

	/*
	char buf[80];
	sprintf(buf, "m_snooker->m_cueAngle: %f", m_snooker->m_cueAngle);
	ErrorMessage(this, buf);
	*/


	angle2D = m_snooker->m_cueAngle;
	rot[0] = 0;
	rot[1] = 0;
	rot[2] = angle2D;

	// ButtFactor 0.0f - 1.0f
	
	float ButtFactor = cue_RaiseButt;//sin( ((float)m_snooker->m_RaiseButt + CUE_DEFAULT_RAISEDBUTT) * DEG2RAD );
	ButtFactor /= cue_RaiseButt90;

	//float cuelength = (500 - 490*ButtFactor)*3.1f;//*3.5f;
	float cuelength = (500 - 490*ButtFactor)*3.1f;//*3.5f;
	//float cuelength = (500)*3.1f;//*3.5f;
	float cuethickness = 1.3 + 1.7*ButtFactor;

	pos[0] = m_snooker->m_sPoint[0] + cuelength*cos(angle2D)*(0.5f-0.00072f*cueFeather);//*cueFeather;
	pos[1] = m_snooker->m_sPoint[1] + cuelength*sin(angle2D)*(0.5f-0.00072f*cueFeather);//*cueFeather;
	pos[2] = m_snooker->m_sPoint[2]-BALL_RADIUS*2.0f;//*1.5f;//*1.0f;

	// add cue-tip offset to cue
	//pos[2]+= ((m_snooker->m_cuetip[1]/0.65f) * BALL_RADIUS) * 0.9f;
	pos[1]+= ((m_snooker->m_cuetip[0]/0.65f) * BALL_RADIUS) * cos(angle2D)*0.9f;
	pos[0]+= ((m_snooker->m_cuetip[0]/0.65f) * BALL_RADIUS) * -sin(angle2D)*0.9f;



	// Render Cue Shadow //
	// Disable depth buffer so that z-fighting doesn't occur when we
	// render the shadow on top of the floor.
	
	g_pDevice->SetRenderState(D3DRS_ZENABLE, FALSE); // Disable Z-Buf.
	if(m_snooker->m_cueStrikeTime<CUE_STRIKE_STARTFADE && m_snooker->m_cueStrikeTime>0)
		m_snooker->DrawSightLine(pos, rot, cuethickness, cuelength, RGBA(38,38,38,(80-60*ButtFactor)*0.8f*(m_snooker->m_cueStrikeTime / CUE_STRIKE_STARTFADE)), FALSE); // 70 - 62&ButtFactor
	else
		m_snooker->DrawSightLine(pos, rot, cuethickness, cuelength, RGBA(38,38,38,80-60*ButtFactor), FALSE);
	//m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(l*3.5f), ballColor[BLACK], TRUE);
	g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE); // Enable Z-Buf.
	/////////////////////////////////	
	
	// position cue
	pos[0] = m_snooker->m_sPoint[0] + (BALL_RADIUS*0.0f/*l*0.1f*/)*cos(angle2D)*0.5f;
	pos[1] = m_snooker->m_sPoint[1] + (BALL_RADIUS*0.0f/*l*0.1f*/)*sin(angle2D)*0.5f;
	pos[2] = m_snooker->m_sPoint[2]-BALL_RADIUS + BALL_RADIUS*0.5; //pos[2] = m_snooker->m_sPoint[2]-BALL_RADIUS;
	
	// level cue out on delivery
	if(m_snooker->m_cueStrikeTime > CUE_PULLBACK_TIME)
	//if(m_snooker->m_cueStrikeTime > 0)
		pos[2] += cueFeather * sin(cue_RaiseButt * DEG2RAD);
	else if((m_snooker->m_cueStrikeTime <= CUE_PULLBACK_TIME) && (m_snooker->m_cueStrikeTime != 0))
		pos[2] += (CUE_PULLBACK_TIME - m_snooker->m_cueStrikeTime) + cueFeather * sin(cue_RaiseButt * DEG2RAD);
		//pos[2] += cueFeather * sin(((float)m_snooker->m_RaiseButt + CUE_DEFAULT_RAISEDBUTT) * DEG2RAD);
		//		pos[2] += (CUE_PULLBACK_TIME - m_snooker->m_cueStrikeTime) + cueFeather * sin(((float)m_snooker->m_RaiseButt + CUE_DEFAULT_RAISEDBUTT) * DEG2RAD);

	// add cue-tip offset to cue
	pos[2]+= ((m_snooker->m_cuetip[1]/0.65f) * BALL_RADIUS) * 0.9f;
	pos[1]+= ((m_snooker->m_cuetip[0]/0.65f) * BALL_RADIUS) * cos(angle2D)*0.9f;
	pos[0]+= ((m_snooker->m_cuetip[0]/0.65f) * BALL_RADIUS) * -sin(angle2D)*0.9f ;

	
	D3DXMATRIX matView;
    D3DXMATRIX matWorld;
    D3DXMATRIX matRotation;
    D3DXMATRIX matTranslation;

	M3d_vtx posf;

	posf[0] = 0;
	posf[1] = cueFeather;
	posf[2] = 0;


	if( g_pDevice )
	{
		D3DXMATRIX matRotX, matRotY, matRotZ, matTrans, matScale;

		// Calculate Scale matrix
		D3DXMatrixScaling(&matScale, 1.0f, 1.0f, 1.0f);

		// Calculate rotation matrix
		D3DXMatrixRotationX( &matRotX, -cue_RaiseButt * DEG2RAD );
		D3DXMatrixRotationY( &matRotY, 0.0f );
		D3DXMatrixRotationZ( &matRotZ, (angle2D + 90.0f*DEG2RAD) );
		
		// Calculate a translation matrix
		D3DXMatrixTranslation(&matTrans, pos[0], pos[1], pos[2]);
		

		D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
		
		
		D3DXMatrixTranslation(&matTrans, posf[0], posf[1], posf[2]);
		matWorld = matTrans*matWorld;
		
		g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);


		/////// Set the Cue Type /////////
		int plr1Idx =-1;
		int plr2Idx =-1;


		int tbl = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tbl!=-1)
		{
			plr1Idx = m_lobby->GetPlayerIdx(m_table[tbl].player1SockIdx);
			plr2Idx = m_lobby->GetPlayerIdx(m_table[tbl].player2SockIdx);
		}
			
			

		
		// Set the Cue to it's Default Normal Type, just incase //
		m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
		
		
		// Player 1's Cue //
		if(m_snooker->m_bTurn1P) 
		{
			if(plr1Idx==-1) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
			else if(m_player[plr1Idx].bIsGuest) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
			else
			{
				m_snooker->m_M3d_Cue_ptr  = &m_M3d_Cue[(m_player[plr1Idx].cuetype)];
				
				/*
				if(m_player[plr1Idx].cuetype==2) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[1];
				else if(m_player[plr1Idx].cuetype==4) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[2];
				else if(m_player[plr1Idx].cuetype==8) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[3];
				else if(m_player[plr1Idx].cuetype==16) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[4];
				else if(m_player[plr1Idx].cuetype==32) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[5];
				else if(m_player[plr1Idx].cuetype==64) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[6];
				else if(m_player[plr1Idx].cuetype==128) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[7];
				else m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
				*/
				
			}
		}
		// Player 2's Cue //
		else 
		{
			
			if(plr2Idx==-1) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
			else if(m_player[plr2Idx].bIsGuest) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
			else
			{
				m_snooker->m_M3d_Cue_ptr  = &m_M3d_Cue[(m_player[plr2Idx].cuetype)];
				
				/*
				if(m_player[plr2Idx].cuetype==2) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[1];
				else if(m_player[plr2Idx].cuetype==4) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[2];
				else if(m_player[plr2Idx].cuetype==8) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[3];
				else if(m_player[plr2Idx].cuetype==16) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[4];
				else if(m_player[plr2Idx].cuetype==32) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[5];
				else if(m_player[plr2Idx].cuetype==64) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[6];
				else if(m_player[plr2Idx].cuetype==128) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[7];
				else m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
				*/
				
			}
			
		}
			
		// DEBUG //
		// m_snooker->m_M3d_Cue_ptr  = &m_M3d_Cue[(m_player[0].cuetype-1)];
		
		/*
		// transparent cue
		//if(m_snooker->m_cueStrikeTime<50 && m_snooker->m_cueStrikeTime>0)
		if(m_snooker->m_cueStrikeTime<CUE_STRIKE_STARTFADE && m_snooker->m_cueStrikeTime>0)
		for(n=0;n<m_snooker->m_M3d_Cue_ptr->mesh_n;n++)
		{
			
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.a = m_snooker->m_cueStrikeTime / CUE_STRIKE_STARTFADE;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Specular.a = m_snooker->m_cueStrikeTime / CUE_STRIKE_STARTFADE;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.a = m_snooker->m_cueStrikeTime / CUE_STRIKE_STARTFADE;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.a = m_snooker->m_cueStrikeTime / CUE_STRIKE_STARTFADE;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Power = D3D_MATERIAL_POWER;//10;
		}
		
		//g_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE); // Disable Z-Buf.
		
		//g_pDevice->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, TRUE);
		//g_pDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
		// g_pDevice->SetRenderState(D3DRS_EDGEANTIALIAS, TRUE);
		
		//M3d_objectdraw(m_snooker->m_M3d_Ball_ptr);

		

		


		
		//g_pDevice->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, FALSE);
		//g_pDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);

		//g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE); // Enable Z-Buf.

		
		// solid cue
		//if(m_snooker->m_cueStrikeTime<50 && m_snooker->m_cueStrikeTime>0)
		if(m_snooker->m_cueStrikeTime<CUE_STRIKE_STARTFADE && m_snooker->m_cueStrikeTime>0)
		{
			for(n=0;n<m_snooker->m_M3d_Cue_ptr->mesh_n;n++)
			{
				
				m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.a = 1.0f;
				m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Specular.a = 1.0f;
				m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.a = 1.0f;
				m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.a = 1.0f;
				m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Power = D3D_MATERIAL_POWER;//10;


			}
		}
		*/


		// solid cue
		//if(m_snooker->m_cueStrikeTime<50 && m_snooker->m_cueStrikeTime>0)
		for(n=0;n<m_snooker->m_M3d_Cue_ptr->mesh_n;n++)
		{
			/*
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.a = 0.5f;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Specular.a = 0.5f;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.a = 0.5f;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.a = 0.5f;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Power = D3D_MATERIAL_POWER;//10;

			*/

			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.a = 1.0f;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.r = 0.0f;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.g = 0.0f;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.b = 0.0f;

			
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.a = 1.0f;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.r *= 0.3f;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.g *= 0.3f;
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.b *= 0.3f;
			

			// m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.a = 1.0f;
			// m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.r = 1.0f;
			// m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.g = 1.0f;
		    // m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.b = 1.0f;


		}


		M3d_objectdraw(m_snooker->m_M3d_Cue_ptr);
		

	}

	///

} // end if mbcuestate
#endif

}







void CGameAppView::UpdatePower(CPoint point)
{
	// *** Adjust Power of Cue *** //
	if(m_bLButtonDown)

	if(m_snooker->m_cueBallSelect==5)
	{
		//GetWindowRect(&m_origin);
		
		//CRect clientrect;
		//::GetWindowRect(g_hwndDX, clientrect);

		//g_dwMainViewWidth = clientrect.Width();
		//g_dwMainViewHeight = clientrect.Height(); //ypos_start;

		m_viewportWidth = g_dwMainViewWidth;
		m_viewportHeight = g_dwMainViewHeight;

		//m_viewportWidth = m_origin.right-m_origin.left;
		//m_viewportHeight = (m_origin.right-m_origin.left)*0.5f;
		//m_viewportHeight = (m_origin.right-m_origin.left)*0.5f - (g_yBarOffset-40);

		//m_viewportHeight = m_origin.Height()*0.7;  //%70 of Height is always used for Rendering Table //
		//m_viewportWidth = m_origin.Width();      //Width is then twice the Table Height Space // to get perfect 2:1 Ratio

		float yield,y;
		float x;
		
		int overlayPowerOffsetX;
		if(g_build.gameType == GAMETYPE_POOL) 
			{
			if(g_yBarOffset == 200) overlayPowerOffsetX = -107;
				else overlayPowerOffsetX = -107+110;
			}
		else{
			if(g_yBarOffset == 200) overlayPowerOffsetX = 38-110;
				else overlayPowerOffsetX = 38;
			}

		x = (float)point.x/(float)m_viewportWidth;
		x*=1024;
		if(x>=1024-60-16+overlayPowerOffsetX &&
		   x<1024-60+16+overlayPowerOffsetX);
		else return;

		y = (float)point.y/(float)m_viewportHeight;
		y*=768; // 0 - 768
		//y-=128; // -128 to 640
		y-=128; // -128 to 640
		y/=512;	// 0 to 1 (with some stuff before and after)
		y = 1-y;

		if(y<0 || y>1.1);  //if(y<-0.1 || y>1.1);
		else
		{
			if (y<0) y = 0;
			else if (y>1) y = 1;

			M3d_vtx vec;
			float l;
			float max;
			max = 1600.0f * 1.09f;//(10.0f / BALL_STRIKEFACTOR); // 1600.0f
			if (g_build.gameType == GAMETYPE_POOL)
				max = 1400.0f * 1.09f;//(10.0f / BALL_STRIKEFACTOR); // 1600.0f

			vec[0] = m_snooker->m_tableMousePos[0] - m_snooker->m_sPoint[0];
			vec[1] = m_snooker->m_tableMousePos[1] - m_snooker->m_sPoint[1];
			vec[2] = 0.0f; // BUGFIX: for power bar users: zero out z-component for strike vector


			if (y < 0.02f) y = 0.02f; // limit lower bounds to 1%
			m_snooker->m_cuePowerPercentage = y * 100;

			l = ((y)* ((1.0f - CUE_POWER_PERCENTAGE_SHIFT) * max)) +
				(CUE_POWER_PERCENTAGE_SHIFT * max);

			if (g_build.gameType == GAMETYPE_SNOOKER)
				l -= 140.0f  * 1.1f;
			else if (g_build.gameType == GAMETYPE_POOL)
				l -= 120.0f  * 1.1f;

			M3d_unit(vec);

			vec[0] *= l;
			vec[1] *= l;
			vec[2] *= l;

			m_snooker->m_tableMousePos[0] = m_snooker->m_sPoint[0] + vec[0];
			m_snooker->m_tableMousePos[1] = m_snooker->m_sPoint[1] + vec[1];
			m_snooker->m_tableMousePos[2] = m_snooker->m_sPoint[2] + vec[2];

			m_fineTuner->Reset(false);

	
			if (g_bOnPowerBarMouseDown == false)
			{
				g_bOnPowerBarMouseDown = true;
				// if (g_gameAppView) ErrorMessage(g_gameAppView, "mouse down");
				SetCapture();
			}

		}
		
	}

	// *************************** //
}


void CGameAppView::UpdatePower(float percent)
{
	// *** Adjust Power of Cue by Middle Mouse Scroller *** //

	if(m_snooker->m_cueBallSelect==5)
	{
		float y;
		y = percent;

		if(y<0 || y>1.1);  //if(y<-0.1 || y>1.1);
		else {
		if(y<0) y = 0;
		else if(y>1) y = 1;

		M3d_vtx vec;
		float l;
		float max;
		max = 1600.0f * 1.09f;//(10.0f / BALL_STRIKEFACTOR); // 1600.0f
		if(g_build.gameType == GAMETYPE_POOL)
		max = 1400.0f * 1.09f;//(10.0f / BALL_STRIKEFACTOR); // 1600.0f
	
		vec[0] = m_snooker->m_tableMousePos[0]-m_snooker->m_sPoint[0];
		vec[1] = m_snooker->m_tableMousePos[1]-m_snooker->m_sPoint[1];
		vec[2] = 0.0f; // BUGFIX: for power bar users: zero out z-component for strike vector


		if(y < 0.02f) y = 0.02f; // limit lower bounds to 1%
		m_snooker->m_cuePowerPercentage = y*100;
		
		l = ((y) * ((1.0f-CUE_POWER_PERCENTAGE_SHIFT) * max)) + 
			(CUE_POWER_PERCENTAGE_SHIFT * max);
		
		if(g_build.gameType == GAMETYPE_SNOOKER)
			l-=140.0f;
		else if(g_build.gameType == GAMETYPE_POOL)
			l-=120.0f;

		M3d_unit(vec);

		vec[0]*= l;
		vec[1]*= l;
		vec[2]*= l;
	   
		m_snooker->m_tableMousePos[0] = m_snooker->m_sPoint[0]+vec[0];
		m_snooker->m_tableMousePos[1] = m_snooker->m_sPoint[1]+vec[1];
		m_snooker->m_tableMousePos[2] = m_snooker->m_sPoint[2]+vec[2];

		m_fineTuner->Reset(false);
		}
	}

	// *************************** //
}



void CGameAppView::CalcPowerOfShot(void) // NEW note: m_cuePowerPercentage is only used for visual graphics, NOT actual power, that is reworked out from vectors
{
	// the following code used to be called in "Render3DWhiteSightLine()", a drawing function (Potential for a BUG!)
	
	// draw cue line, using a 3D cube primitve
	M3d_vtx vec;
	//int l;
	float l;



	if(m_snooker->m_bCueState) // beetle 2
	{
		vec[0] = m_snooker->m_tableMousePos[0]-m_snooker->m_sPoint[0];
		vec[1] = m_snooker->m_tableMousePos[1]-m_snooker->m_sPoint[1];
		vec[2] = 0.0f;
		//vec[2] = m_snooker->m_tableMousePos[2]-m_snooker->m_sPoint[2];


		////////////////////
		// calc. offset for power
		M3d_vtx tmpVtx;
		tmpVtx[0] = vec[0];
		tmpVtx[1] = vec[1];
		tmpVtx[2] = vec[2];

		M3d_unit(&tmpVtx);
		if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			tmpVtx[0]*=140.0f; // max power of 100%  = 1600  => 1% = 160 (for iSnooker)
			tmpVtx[1]*=140.0f;
			tmpVtx[2]*=140.0f;
		}
		else if(g_build.gameType == GAMETYPE_POOL)
		{
			tmpVtx[0]*=120.0f; // max power of 100%  = 1400  => 1% = 140 (for iPool)
			tmpVtx[1]*=120.0f;
			tmpVtx[2]*=120.0f;
		}

		// add offset onto cue dir. power
		vec[0] += tmpVtx[0];
		vec[1] += tmpVtx[1];
		vec[2] += tmpVtx[2];
		////////////////////
	}
	else
	{
		if(m_snooker->m_sightlineFade<=0)
		{
			m_snooker->m_sightlineFade = 0.0f;
			m_snooker->m_bTestBallFinished = FALSE;
		}
		else m_snooker->m_sightlineFade-=6; // 0.15 seconds

		vec[0] = m_snooker->m_tableMousePosStrike[0]-m_snooker->m_sPoint[0];
		vec[1] = m_snooker->m_tableMousePosStrike[1]-m_snooker->m_sPoint[1];
		vec[2] = m_snooker->m_tableMousePosStrike[2]-m_snooker->m_sPoint[2];
	}

	/////////////////////////////////////////
	// calculate % power of shot (could be moved into process later???)
	l = M3d_pythag(vec);

	float max;
	max = 1600.0f * 1.09f;//(10.0f / BALL_STRIKEFACTOR); // 1600.0f
	if(g_build.gameType == GAMETYPE_POOL)
	{
		max = 1400.0f * 1.09f;//(10.0f / BALL_STRIKEFACTOR); // 1600.0f
	}
	if(l > max) l = max; // maximum power (100%)
	
	m_snooker->m_cuePowerPercentage = ( (l-CUE_POWER_PERCENTAGE_SHIFT * max) / 
										((1.0f-CUE_POWER_PERCENTAGE_SHIFT) * max) ) * 100.0f;
	if(m_snooker->m_cuePowerPercentage < 0)
	{
		m_snooker->m_cuePowerPercentage = 0;
		l = 0;
	}
	/////////////////////////////////////////

	// force power offset to 1% minimum
	//if(m_snooker->m_cuePowerPercentage == 0)
	//	m_snooker->m_cuePowerPercentage = 1;


}

void CGameAppView::Render3DWhiteSightLine(void)
{
#ifndef MAIN_SERVER

	CalcPowerOfShot();	// NEW note: m_cuePowerPercentage is only used for visual graphics, NOT actual power, that is reworked out from vectors

	// Replay check - don't render sight-lines
	if(m_snooker->m_bStrikeBallReplayDrawSL) return;

	if(m_snooker->m_cuePowerPercentage == 0) // if cue_power is 0% dont draw sight-lines
		return;

	M3d_vtx pos;
	M3d_vtx scale;
	M3d_vtx rot;
	float angle2D = m_snooker->m_cueAngle;

	scale[0] = 0.05f;
	scale[1] = 0.05f;
	scale[2] = 0.05f;	
/*
	m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.r = 0.0f * 0.4f;
	m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.g = 1.0f * 0.4f;
	m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.b = 1.0f * 0.4f;
	m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.a = 1.0f;
*/
	pos[0] = m_snooker->m_sPoint[0];
	pos[1] = m_snooker->m_sPoint[1];
	pos[2] = m_snooker->m_sPoint[2]+36;
	//M3d_transformobject(pos, rot, scale); // For still (non keyframes) meshes.
	//M3d_objectdraw(m_snooker->m_M3d_Ball_ptr);
	
	// draw cue line, using a 3D cube primitve
	
	float l;


	// draw white ball sight line
//			float angle2D = atan2((double)vec[1], (double)vec[0]);
	////
	//Mgfx_idx = 255;				 
	//sprintf(buffer, "angle2D = %f", angle2D*RAD2DEG);
	//Mgfx_gditext(m_origin.left+0, m_origin.top+0, buffer, Mgfx_idx);
	////
	rot[0] = 0;
	rot[1] = 0;
	//rot[2] = angle2D; // for old sight lines orientation
	rot[2] = angle2D+90.0f*DEG2RAD;

		
	if( m_snooker->MyTurn() ) // don't draw for watchers
	{
	//g_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE); // Disable Z-Buf.
	//if(g_build.gameType == GAMETYPE_SNOOKER)
	//	m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(l*3.5f), ballColor[m_snooker->m_ball[m_snooker->m_selectBall]->m_colour], TRUE);
	//else if(g_build.gameType == GAMETYPE_POOL)
	{
		/////////////////
		CVector V;
		#ifdef FIXEDMODE
		V.x = FROMFIXSMALL(m_snooker->m_testBall->f_P.x) - m_snooker->m_sPoint[0];
		V.y = FROMFIXSMALL(m_snooker->m_testBall->f_P.y) - m_snooker->m_sPoint[1];
		V.z = FROMFIXSMALL(m_snooker->m_testBall->f_P.z) - m_snooker->m_sPoint[2];
		#else
		V.x = m_snooker->m_testBall->m_P.x - m_snooker->m_sPoint[0];
		V.y = m_snooker->m_testBall->m_P.y - m_snooker->m_sPoint[1];
		V.z = m_snooker->m_testBall->m_P.z - m_snooker->m_sPoint[2];
		#endif
		float length = V.Magnitude();
		if(m_snooker->m_testBall->m_colour != WHITE && m_snooker->m_ball[m_snooker->m_selectBall]->m_colour == WHITE
		   /*&& g_gfxDetails.bOptionsDrawErrorSL*/ && !g_gfxDetails.bOptionsDrawCueBallLE)
		{																	  
			l = length;

			pos[0] = m_snooker->m_sPoint[0];// - (l*1.0f)*cos(angle2D)*0.5f;
			pos[1] = m_snooker->m_sPoint[1];// - (l*1.0f)*sin(angle2D)*0.5f;
			pos[2] = m_snooker->m_sPoint[2]-BALL_RADIUS*1.0f;
			
			//if(m_snooker->m_cueBallSelect != 2 && m_snooker->m_cueBallSelect != 0)
			//m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(l*1.0f-BALL_RADIUS*2.0f), RGBA(235,239,212,64), TRUE);
			
			float error;

			if(g_build.gameType == GAMETYPE_SNOOKER)
			{
				error = m_snooker->m_strikeMaxRnd*10000;
				if(error > 50.0f) error = 50.0f;
			}
			else // iPool
			{
				error = m_snooker->m_strikeMaxRnd*10000;
				if(error > 50.0f) error = 50.0f;
			}
						
			M3d_vtx scale;
			scale[0] = error;//50.0f; // TODO: add error factor here [Odin]
			scale[1] = (float)(l*1.0f-BALL_RADIUS*2.0f);
			scale[2] = 1.0f;
			m_snooker->DrawSightUTri(pos, rot, scale, RGBA(235,239,212, 255), TRUE);//RGBA(0,60,100,35));
		}
		/////////////////
		else
		{
		//if(m_snooker->m_cueBallSelect != 2 && m_snooker->m_cueBallSelect != 0)
			//m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(l*3.5f), RGBA(235,239,212,64), TRUE);//RGBA(0,0,0,32), FALSE);
		//	m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(3500.0f), RGBA(235,239,212,64), TRUE);//RGBA(0,0,0,32), FALSE);		

			pos[0] = m_snooker->m_sPoint[0];// - (l*1.0f)*cos(angle2D)*0.5f;
			pos[1] = m_snooker->m_sPoint[1];// - (l*1.0f)*sin(angle2D)*0.5f;
			pos[2] = m_snooker->m_sPoint[2]-BALL_RADIUS*1.0f;
						
			M3d_vtx scale;
			if(g_build.gameType == GAMETYPE_SNOOKER)
			{
				// scale factors
				scale[0] = 50.0f; // TODO: add error factor here [Odin]
				scale[1] = (float)(4200.0f);
				scale[2] = 1.0f;
				
				if(g_gfxDetails.bOptionsDrawColourSL)
				{
					// darken object-ball colours up
					COLORREF rgba;
					rgba = ballColor[m_snooker->m_ball[m_snooker->m_selectBall]->m_colour];
					float r = (float)(GetRValue(rgba));
					float g = (float)(GetGValue(rgba));
					float b = (float)(GetBValue(rgba));
					//float a = (float)(GetAValue(rgba));
					/*
					r*=0.42f;
					g*=0.42f;
					b*=0.42f;
					*/
					rgba = RGBA((BYTE)r, (BYTE)g, (BYTE)b, 255);//128

					m_snooker->DrawSightUTri(pos, rot, scale, rgba, TRUE);
				}
				else
				{
					m_snooker->DrawSightUTri(pos, rot, scale, RGBA(235,239,212, 128), TRUE);
				}
			}
			else if(g_build.gameType == GAMETYPE_POOL)
			{
				// scale factors
				scale[0] = 50.0f; // TODO: add error factor here [Odin]
				scale[1] = 3000.0f;
				scale[2] = 1.0f;

				if(g_gfxDetails.bOptionsDrawColourSL)
				{
					int colour = m_snooker->m_ball[m_snooker->m_selectBall]->m_colour;

					if(m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
					{
						if(colour >=1 && colour<=5) // Blue Bowl
							colour = 2;
						else if(colour >=6 && colour<=10) // Red Bowl
							colour = 3;
					}

					
					COLORREF rgba;
					rgba = poolBallColor[colour];
					float r = (float)(GetRValue(rgba));
					float g = (float)(GetGValue(rgba));
					float b = (float)(GetBValue(rgba));
					//float a = (float)(GetAValue(rgba));
					rgba = RGBA((BYTE)r, (BYTE)g, (BYTE)b, 255);//128



					m_snooker->DrawSightUTri(pos, rot, scale, rgba, TRUE);
				}
				else
				{
					m_snooker->DrawSightUTri(pos, rot, scale, RGBA(235,239,212, 128), TRUE);
				}
			}	
		}		
	}
	//g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE); // Enable Z-Buf.
	}

#endif
}

void CGameAppView::Render3DObjectSightLine(void)
{
#ifndef MAIN_SERVER
	
	// Replay check - don't render sight-lines
	if(m_snooker->m_bStrikeBallReplayDrawSL) return;
	
	if(m_snooker->m_cuePowerPercentage == 0) // if cue_power is 0% dont draw sight-lines
		return;

	M3d_vtx pos;
	M3d_vtx scale;
	M3d_vtx rot;
	M3d_vtx vec;
	float angle2D = m_snooker->m_cueAngle;

	// check for testball colour (make sure it's not WHITE - this occurs at 0% power)
	
		
	
	
	
		


	char proceed = 0;
	if(g_build.gameType == GAMETYPE_SNOOKER && m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
		{
		if(m_snooker->m_testBall->m_colour == YELLOW && !m_snooker->m_bTurn1P) return;
		if(m_snooker->m_testBall->m_colour == WHITE && m_snooker->m_bTurn1P) return;
		
		if(m_snooker->m_ball[m_snooker->m_selectBall]->m_colour == WHITE || m_snooker->m_ball[m_snooker->m_selectBall]->m_colour == YELLOW) // cueball only
			proceed = 1;
		}
	else{
		if(m_snooker->m_testBall->m_colour == WHITE) return;
		if(m_snooker->m_ball[m_snooker->m_selectBall]->m_colour == WHITE) // cueball only
			proceed = 1;
		}
		

	if(proceed) // cueball only
	//if((int)m_snooker->m_cuePowerPercentage > 0)
	{
#ifdef FIXEDMODE
		vec[0] = FROMFIXSMALL(m_snooker->m_testBall->f_V.x) * 10;
		vec[1] = FROMFIXSMALL(m_snooker->m_testBall->f_V.y) * 10;
		vec[2] = FROMFIXSMALL(m_snooker->m_testBall->f_V.z) * 10;
#else
		vec[0] = m_snooker->m_testBall->m_V.x * 10;
		vec[1] = m_snooker->m_testBall->m_V.y * 10;
		vec[2] = m_snooker->m_testBall->m_V.z * 10;
#endif

		float length = 1.0f;
		angle2D = atan2((double)vec[1], (double)vec[0]);

		// Save the Angle, for use in Automatic Camera View //
		g_ACamAngle = angle2D + 3.14159;
		
		rot[0] = 0;
		rot[1] = 0;
		//rot[2] = angle2D; // for old sight lines orientation
		rot[2] = angle2D + 270.0f*DEG2RAD;
#ifdef FIXEDMODE
		pos[0] = FROMFIXSMALL(m_snooker->m_testBall->f_P.x) + (length*3500.0f)*cos(angle2D)*0.5f;
		pos[1] = FROMFIXSMALL(m_snooker->m_testBall->f_P.y) + (length*3500.0f)*sin(angle2D)*0.5f;
		pos[2] = FROMFIXSMALL(m_snooker->m_testBall->f_P.z) - BALL_RADIUS*1.0f;
#else
		pos[0] = m_snooker->m_testBall->m_P.x + (length*3500.0f)*cos(angle2D)*0.5f;
		pos[1] = m_snooker->m_testBall->m_P.y + (length*3500.0f)*sin(angle2D)*0.5f;
		pos[2] = m_snooker->m_testBall->m_P.z-BALL_RADIUS*1.0f;
#endif
		
		if( m_snooker->MyTurn() ) // don't draw for watchers
		{
		g_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE); // Disable Z-Buf.
//				m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(3500.0f), ballColor[m_snooker->m_testBall->m_colour], TRUE);
		//if(g_build.gameType == GAMETYPE_SNOOKER)
		//	m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(length*3500.0f/*m_snooker->m_strikeRnd*/), ballColor[m_snooker->m_testBall->m_colour], TRUE);
		//else if(g_build.gameType == GAMETYPE_POOL)
		{
			//if(m_snooker->m_cueBallSelect != 2 && m_snooker->m_cueBallSelect != 0)
			{
			//	m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(length*3500.0f/*m_snooker->m_strikeRnd*/), RGBA(235,239,212,64), TRUE);

#ifdef FIXEDMODE
				pos[0] = FROMFIXSMALL(m_snooker->m_testBall->f_P.x);// + (length*3500.0f)*cos(angle2D)*0.5f;
				pos[1] = FROMFIXSMALL(m_snooker->m_testBall->f_P.y);// + (length*3500.0f)*sin(angle2D)*0.5f;
				pos[2] = FROMFIXSMALL(m_snooker->m_testBall->f_P.z)-BALL_RADIUS*1.0f;
#else
				pos[0] = m_snooker->m_testBall->m_P.x;// + (length*3500.0f)*cos(angle2D)*0.5f;
				pos[1] = m_snooker->m_testBall->m_P.y;// + (length*3500.0f)*sin(angle2D)*0.5f;
				pos[2] = m_snooker->m_testBall->m_P.z-BALL_RADIUS*1.0f;
#endif

				//if(m_snooker->m_cueBallSelect != 2 && m_snooker->m_cueBallSelect != 0)
				//m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(l*1.0f-BALL_RADIUS*2.0f), RGBA(235,239,212,64), TRUE);
				
				float distError;
				float error;
				if(g_build.gameType == GAMETYPE_SNOOKER)
				{
					
					distError = 1.0f + 25.0f*(m_snooker->m_strikeDist / 6000.0f);
					error = m_snooker->m_strikeMaxRnd*60000;
					
					float closeshoterrorFACTOR = ((BALL_RADIUS*2)*8) / m_snooker->m_strikeDist;
					if(closeshoterrorFACTOR < 1.0f) closeshoterrorFACTOR = 1.0f;
					error /= closeshoterrorFACTOR;
					error *= 0.55;//0.8;
				}
				else // iPool
				{
					distError = 1.0f + 25.0f*(m_snooker->m_strikeDist / 3000.0f);
					error = m_snooker->m_strikeMaxRnd*10000;

					// adjust for close shots
					float closeshoterrorFACTOR = ((BALL_RADIUS*2)*8) / m_snooker->m_strikeDist;
					closeshoterrorFACTOR /= 2.0f; // *NEW*
					if(closeshoterrorFACTOR < 1.0f) closeshoterrorFACTOR = 1.0f;
					error /= closeshoterrorFACTOR;

					// adjust for far shots
					float farshoterrorFACTOR = m_snooker->m_strikeDist / ((BALL_RADIUS*2)*20);
					if(farshoterrorFACTOR < 1.0f) farshoterrorFACTOR = 1.0f;
					error *= farshoterrorFACTOR;

					//error *= 0.70;
					error *= 0.80;
				}
								
				M3d_vtx scale;						
				
				if(g_build.gameType == GAMETYPE_SNOOKER)
				{
					// scale factors
					scale[0] = error * distError;//150.0f; // TODO: add error factor here [Odin]
					scale[1] = (float)(length*4500.0f);
					scale[2] = 1.0f;

					if(g_gfxDetails.bOptionsDrawColourSL)
					{					
						// darken object-ball colours up
						COLORREF rgba;
						rgba = ballColor[m_snooker->m_testBall->m_colour];
						float r = (float)(GetRValue(rgba));
						float g = (float)(GetGValue(rgba));
						float b = (float)(GetBValue(rgba));
						//float a = (float)(GetAValue(rgba));
						/*
						r*=0.42f;//0.42f;
						g*=0.35f;//0.42f;
						b*=0.42f;//0.42f;
						*/
						rgba = RGBA((BYTE)r, (BYTE)g, (BYTE)b, 255);//128

						m_snooker->DrawSightUTri(pos, rot, scale, rgba, TRUE);
					}
					else
					{
						m_snooker->DrawSightUTri(pos, rot, scale, RGBA(255,255,255,128), TRUE);
					}
				}
				else if(g_build.gameType == GAMETYPE_POOL)
				{
					// scale factors
					scale[0] = error * distError;//150.0f; // TODO: add error factor here [Odin]
					scale[1] = (float)(length*2500.0f);
					scale[2] = 1.0f;

					if(g_gfxDetails.bOptionsDrawColourSL)
					{					
						int colour = m_snooker->m_testBall->m_colour;

						if(m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
						{
							if(colour >=1 && colour<=5) // Blue Bowl
								colour = 2;
							else if(colour >=6 && colour<=10) // Red Bowl
								colour = 3;
						}					
						
						if(m_snooker->m_customTable->m_type == CTTYPE_UKPOOL)
							{
								if(colour >=1 && colour<=7) colour = 3; // Red Ball
								else if(colour >=9 && colour<=15) colour = 1; // Yellow Ball
								else colour = 8;
							}
						if(m_snooker->m_customTable->m_type == CTTYPE_BREAK)
							{
								if(colour ==11) colour = 6; // Green Ball
								else if(colour ==12) colour = 2; // Blue Ball
								else if(colour ==13) colour = 8; // Black Ball
								else colour = 3; // Green Ball
							}

						// darken object-ball colours up
						COLORREF rgba;
						rgba = poolBallColor[colour];
						float r = (float)(GetRValue(rgba));
						float g = (float)(GetGValue(rgba));
						float b = (float)(GetBValue(rgba));
						//float a = (float)(GetAValue(rgba));
						rgba = RGBA((BYTE)r, (BYTE)g, (BYTE)b, 255);//128
						
						m_snooker->DrawSightUTri(pos, rot, scale, rgba, TRUE);
					}
					else
					{
						m_snooker->DrawSightUTri(pos, rot, scale, RGBA(120,120,200, 128), TRUE);
					}					
				}

				/////////////////////////////////
				#ifdef SHAKE_LINE
				float lMax = length*3500.0f;
				float l = lMax / 300.0f;
				float offset = ((m_cyc>>1)&7)*2;						  

				pos[0] = m_snooker->m_testBall->m_P.x + (offset + l)*cos(angle2D)*0.5f;
				pos[1] = m_snooker->m_testBall->m_P.y + (offset + l)*sin(angle2D)*0.5f;
				for(int n=0;n<100;n++)
				{
					pos[0] += 2.0f*l*cos(angle2D);
					pos[1] += 2.0f*l*sin(angle2D);
					m_snooker->DrawSightLine(pos, rot, 1.0f, l, RGBA(235,239,212,64), FALSE);					
				}
				#endif //SHAKE_LINE
				/////////////////////////////////
				
			}
		}

		g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE); // Enable Z-Buf.
		}
		//pos[0] = m_snooker->m_testBall->m_P.x + (l*30.0f)*cos(angle2D)*0.5f;
		//pos[1] = m_snooker->m_testBall->m_P.y + (l*30.0f)*sin(angle2D)*0.5f;
		//pos[2] = m_snooker->m_testBall->m_P.z;
		//m_snooker->DrawSightLine(pos, rot, (float)(l*30.0f), ballColor[m_snooker->m_testBall->m_colour], TRUE);
		//
	} // end if WHITE

#endif
}


void CGameAppView::Render3DGhostBall(void)
{
#ifndef MAIN_SERVER

	if(m_snooker->m_cueBallSelect != 1 &&
	   m_snooker->m_cueBallSelect != 5) return;

	M3d_vtx pos;
	M3d_vtx scale;
	M3d_vtx rot;
	M3d_vtx vec;
	float angle2D = m_snooker->m_cueAngle;



	//
	// draw obj ball line, using a 3D cube primitve
	//--if(m_snooker->m_bTestBallFinished)


	char proceed = 0;
	if(g_build.gameType == GAMETYPE_SNOOKER && m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
		{
		// Only Render the Ghost Ball for CueBall in Billiards Game Type in the cases below //
		if( (m_snooker->m_ball[m_snooker->m_selectBall]->m_colour == WHITE && m_snooker->m_bTurn1P) ||
			(m_snooker->m_ball[m_snooker->m_selectBall]->m_colour == YELLOW && !m_snooker->m_bTurn1P) ) // cueball only
			proceed = 1;
		}
	else{
		// check for testball colour (make sure it's not WHITE - this occurs at 0% power)
		if(m_snooker->m_testBall->m_colour == WHITE) return;
		if( (m_snooker->m_ball[m_snooker->m_selectBall]->m_colour == WHITE)	) proceed = 1;
		}

	// If we are not aiming at a ball, then don't true the Ghost Ball //

	

	if(proceed)
	//if((int)m_snooker->m_cuePowerPercentage > 0)
	{

#ifdef FIXEDMODE
		vec[0] = FROMFIXSMALL(m_snooker->m_testBall->f_V.x) * 10;
		vec[1] = FROMFIXSMALL(m_snooker->m_testBall->f_V.y) * 10;
		vec[2] = FROMFIXSMALL(m_snooker->m_testBall->f_V.z) * 10;
#else
		vec[0] = m_snooker->m_testBall->m_V.x * 10;
		vec[1] = m_snooker->m_testBall->m_V.y * 10;
		vec[2] = m_snooker->m_testBall->m_V.z * 10;
#endif
				 
		float length = 1.0f;

		angle2D = atan2((double)vec[1], (double)vec[0]);
		
		rot[0] = 0;
		rot[1] = 0;
		rot[2] = angle2D;
		
	#ifdef FIXEDMODE
		pos[0] = FROMFIXSMALL(m_snooker->m_testBall->f_P.x) - (BALL_RADIUS*2.0f)*cos(angle2D);
		pos[1] = FROMFIXSMALL(m_snooker->m_testBall->f_P.y) - (BALL_RADIUS*2.0f)*sin(angle2D);
		pos[2] = FROMFIXSMALL(m_snooker->m_testBall->f_P.z) + BALL_DRAWOFFSETZ;// - BALL_POSITIONZOFFSET + BALL_DRAWOFFSETZ;//-BALL_RADIUS*1.0f;
	#else
		pos[0] = m_snooker->m_testBall->m_P.x -  (BALL_RADIUS*2.0f)*cos(angle2D);
		pos[1] = m_snooker->m_testBall->m_P.y - (BALL_RADIUS*2.0f)*sin(angle2D);
		pos[2] = m_snooker->m_testBall->m_P.z + BALL_DRAWOFFSETZ;// - BALL_POSITIONZOFFSET + BALL_DRAWOFFSETZ;//-BALL_RADIUS*1.0f;
	#endif		

		if( m_snooker->MyTurn() ) // don't draw for watchers
		{
//		g_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE); // Disable Z-Buf.
//				m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(3500.0f), ballColor[m_snooker->m_testBall->m_colour], TRUE);
//		m_snooker->DrawSightLine(pos, rot, 1.0f, (float)(length*3500.0f/*m_snooker->m_strikeRnd*/), ballColor[m_snooker->m_testBall->m_colour], TRUE);


		if(m_snooker->m_cueBallSelect != 2 && m_snooker->m_cueBallSelect != 0)
			m_snooker->DrawBallPos(pos, 1.0f, 1.0f, 1.0f, TRUE);
	   			
//		g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE); // Enable Z-Buf.
		}
		//pos[0] = m_snooker->m_testBall->m_P.x + (l*30.0f)*cos(angle2D)*0.5f;
		//pos[1] = m_snooker->m_testBall->m_P.y + (l*30.0f)*sin(angle2D)*0.5f;
		//pos[2] = m_snooker->m_testBall->m_P.z;
		//m_snooker->DrawSightLine(pos, rot, (float)(l*30.0f), ballColor[m_snooker->m_testBall->m_colour], TRUE);
		//
	} // end if WHITE

#endif
}


void CGameAppView::Render3DWhiteTouchingBalls(void)
{
#ifndef MAIN_SERVER

	M3d_vtx pos;
	M3d_vtx scale;
	M3d_vtx rot;

	//	m_touchingBallIdx = 0;
	for(int t=0; t<MAX_TOUCHING_BALLS; t++)
	if(m_snooker->m_touchingBall[t])
	{
		CVector N;
		N = m_snooker->m_ball[0]->m_P - m_snooker->m_ball[m_snooker->m_touchingBall[t]]->m_P;
		N = N.Unit();
		N = N * BALL_RADIUS;

		pos[0] = m_snooker->m_ball[0]->m_P.x - N.x;
		pos[1] = m_snooker->m_ball[0]->m_P.y - N.y;
		pos[2] = m_snooker->m_ball[0]->m_P.z + BALL_DRAWOFFSETZ;
		
		
		//g_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE); // Disable Z-Buf.

		/////////////////////////////////	
		scale[0] = 0.25f;
		scale[1] = 0.25f;
		scale[2] = 0.25f;
		m_snooker->DrawBallPos2(pos, 0.0f, 0.0f, 0.0f, FALSE, scale);

		// draw 'x' on top of object touching ball
		rot[0] = 0;
		rot[1] = 0;
		rot[2] = 0 + 3.1416/4;

		pos[0] = m_snooker->m_ball[m_snooker->m_touchingBall[t]]->m_P.x;
		pos[1] = m_snooker->m_ball[m_snooker->m_touchingBall[t]]->m_P.y;
		pos[2] = m_snooker->m_ball[m_snooker->m_touchingBall[t]]->m_P.z + BALL_DRAWOFFSETZ;

		m_snooker->DrawSightLine(pos, rot, 0.45, BALL_RADIUS*1.25, RGBA(10,10,10,255), FALSE);
		
		rot[2] = 3.1416/2 + 3.1416/4;

		m_snooker->DrawSightLine(pos, rot, 0.45, BALL_RADIUS*1.25, RGBA(10,10,10,255), FALSE);
		/////////////////////////////////	

		//g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE); // Enable Z-Buf.
	}
#endif
}


void CGameAppView::Render2DTableCuePercentage()
{
#ifndef MAIN_SERVER

	if(!g_gfxDetails.bOptionsDrawStaticPower) return;
	
	if(m_snooker->m_cueBallSelect==0 || m_snooker->m_cueBallSelect==1 || m_snooker->m_cueBallSelect==5)
	if(m_snooker->m_bCueState)
	{
		// draw percentage value on screen (TEXT)
		float x,y;		
		float offsetX = m_snooker->m_sSize.x - m_cx; // 800
		float offsetY = m_snooker->m_sSize.y - m_cy; // 600
		float fX = (float)(m_cx) / m_snooker->m_sSize.x;//(m_origin.right - m_origin.left);//
		
		x = m_snooker->m_sCPoint.x*fX;// - ceil(offsetX*0.5f);// + m_origin.left;
		y = m_snooker->m_sCPoint.y*fX;// - ceil(offsetX*0.5f)*0.5f;// + m_origin.top;
		if(x < /*m_cx*0.5f*/m_viewportWidth) x += 32;
		else x -= 32;		   	  
		if(y < /*m_cx*0.25f*/m_viewportHeight*0.5f) y += 32;//
		else y -= 32;			  

		//if(x < viewportHeight) x = /*m_origin.left+*/m_snooker->m_sCPoint.x+32;
		//else x = /*m_origin.left+*/m_snooker->m_sCPoint.x-32;
		//if(y < viewportHeight*0.5f) y = /*m_origin.top+*/m_snooker->m_sCPoint.y+32;
		//else y = /*m_origin.top+*/m_snooker->m_sCPoint.y-32;
				
		if(m_snooker->MyTurn())
		{
			Mgfx_idx = 255;				 
			sprintf(buffer, "%d%%", (int)m_snooker->m_cuePowerPercentage);
			Mgfx_gditext(x-8, y-8, buffer, Mgfx_idx);
		}
	}
#endif
}

void CGameAppView::Render2DTableHint()
{

#ifndef MAIN_SERVER
	// Display system alert messages!
//	if(gameShell)

	//CRect rect;
	//rect = CRect(m_cx*0.5f-200, 20-5, m_cx*0.5f+200, 20+30-5); // L,T,R,B
	//DrawGameMessage("   Click Left-Mouse button to SET shot. (Right-click to cancel)", rect, 5/*0.89f*/);

	// render function key display GFX
	if(m_functionKeyGFXDelay)
	{
		m_functionKeyGFXDelay--;
		
		switch(m_functionKey)
		{
			case 2:
			if(g_gfxDetails.bOptionsDrawColourSL) DrawGameMessageXY("'F2' Draw Colour Sight Lines: ON");
			else DrawGameMessageXY("'F2' Draw Colour Sight Lines: OFF", 16, 12);
			break;
			case 3:
			if(g_gfxDetails.bOptionsDrawErrorSL) DrawGameMessageXY("'F3' Draw Error Sight Lines: ON");
			else DrawGameMessageXY("'F3' Draw Error Sight Lines: OFF");
			break;
			case 4:
			if(g_gfxDetails.bOptionsDrawGhostCueBall) DrawGameMessageXY("'F4' Draw Ghost Cue-Ball: ON");
			else DrawGameMessageXY("'F4' Draw Ghost Cue-Ball: OFF");
			break;
			case 5:
			if(g_gfxDetails.bOptionsDrawCueBallLE) DrawGameMessageXY("'F5' Draw Cue-Ball Line Extend: ON");
			else DrawGameMessageXY("'F5' Draw Cue-Ball Line Extend: OFF");			
			break;
			case 6:
			if(g_gfxDetails.bOptionsLowgfx) DrawGameMessageXY("'F6' Low Graphics Detail: ON");
			else if(g_gfxDetails.bOptionsMediumgfx) DrawGameMessageXY("'F6' Medium Graphics Detail: ON");
			else if(g_gfxDetails.bOptionsHighgfx) DrawGameMessageXY("'F6' High Graphics Detail: ON");
			break;
			case 7:
			if(m_snooker)
			if(m_snooker->m_bPracticeMode)
			{
				if(g_practiceDetails.bOptionsBallInHandAlways) DrawGameMessageXY("'F7' Ball-In-Hand Always: ON");
				else DrawGameMessageXY("'F7' Ball-In-Hand Always: OFF");
			}
			break;
			case 8:
			if(m_snooker)
			if(m_snooker->m_bPracticeMode)
			{
				#ifndef THE_POOL_CLUB
				switch(m_snooker->m_reRackType)
				{
					case RERACK_START:
					DrawGameMessageXY("'F8' Starting Position: ON");
					break;
					case RERACK_LINEUP:
					DrawGameMessageXY("'F8' The Line-Up: ON");
					break;
					case RERACK_COLOURS:				
					DrawGameMessageXY("'F8' The Colours: ON");
					break;
					case RERACK_BLACK:				
					DrawGameMessageXY("'F8' Re-Spotted Black: ON");
					break;
					case RERACK_REDSSCATTERED1:				
					DrawGameMessageXY("'F8' Reds Scattered (1): ON");
					break;
					case RERACK_REDSSCATTERED2:				
					DrawGameMessageXY("'F8' Reds Scattered (2): ON");					
					break;
					case RERACK_BILLIARDS:
					DrawGameMessageXY("'F8' Billiards (2): ON");					
					break;
				}
				#else
				switch(m_snooker->m_reRackType)
				{
					case RERACK_8BALL:
					DrawGameMessageXY("'F8' 8-Ball Setup: ON");
					break;
					case RERACK_UKPOOL:
					DrawGameMessageXY("'F8' UK Pool Setup: ON");
					break;
					case RERACK_9BALL:
					DrawGameMessageXY("'F8' 9-Ball Setup: ON");
					break;
					case RERACK_8BALLSCATTERED:
					DrawGameMessageXY("'F8' 8-Ball Scattered: ON");
					break;
					case RERACK_9BALLSCATTERED:
					DrawGameMessageXY("'F8' 9-Ball Scattered: ON");
					break;
					case RERACK_ROTATIONBALL:
					DrawGameMessageXY("'F8' Rotation Ball Setup: ON");
					break;
					case RERACK_BOWLS:
					DrawGameMessageXY("'F8' Bowls Setup: ON");
					break;
					case RERACK_6BALL:
					DrawGameMessageXY("'F8' 6-Ball Setup: ON");
					break;
					case RERACK_6BALLSCATTERED:
					DrawGameMessageXY("'F8' 6-Ball Scattered: ON");
					break;
					case RERACK_10BALL:
					DrawGameMessageXY("'F8' 10-Ball Setup: ON");
					break;
					case RERACK_10BALLSCATTERED:
					DrawGameMessageXY("'F8' 10-Ball Scattered: ON");
					break;
					case RERACK_BREAK:
					DrawGameMessageXY("'F8' Break Setup: ON");
					break;
				}
				#endif
			}
			break;
		}
	}
	
	int myTblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);

	if(myTblIdx !=-1)
	{
		// setup table position in practice mode - once player been seated
		if(m_snooker->m_bPracticeMode)
		{
//		if(gameShell->m_seat == -1)
//			DrawGameMessage("Click 'Sit' to start practice");			
		}
		else
		{
			// --table created from lobby--
			int msg = m_lobby->GetTableStartMessageForPlayer(m_playerSockIdx);

			if(m_table[myTblIdx].tournament == 3) // override 'msg' if the match at this table has just finished!
				msg = 0;

			// -1 = <display no message>
			//  0 = "click 'Sit' button to join game"
			//  1 = "waiting for opponent to click 'Sit' button..."
			//  2 = "click 'Start' to begin game"
			//  3 = "waiting for opponent to click 'Start' button..."
			switch(msg)
			{
				case -1:
					break;
				case 0:
					if(g_bTournamentLobby)
						DrawGameMessage("THIS TABLE IS RESERVED FOR TOURNAMENT PLAY!!!", 0.95f);
					else
					{
						if (m_table[myTblIdx].bLadderMatch) DrawGameMessage("THIS TABLE IS RESERVED FOR LADDER MATCH PLAY!!!", 0.95f);
							else DrawGameMessage("Click Sit Here to Join Game", 0.87f);
					}
					break;
				case 1:
					if(g_bTournamentLobby)
						DrawGameMessage("Waiting for opponent to arrive, please wait...", 0.87f);						
					else
					{
						if (m_table[myTblIdx].bLadderMatch) DrawGameMessage("Waiting for opponent to arrive, please wait...", 0.87f);
							else DrawGameMessage("Waiting for opponent to Sit...", 0.85f);
					}
					break;
				case 2:
					DrawGameMessage("Click Start to begin game", 0.89);
					break;
				case 3:
						DrawGameMessage("Waiting for opponent to click Start...", 0.87f);
					break;				
			} // end switch

			if(msg == -1) g_sponsoron = 0;
			else g_sponsoron = 1;

		} // end else

		// *** waiting for players that have still to complete their sim.
		if(m_snooker->m_clientSimEnd)
			if(!m_snooker->m_simEndWaitingDelay)
				m_lobby->SimEndWaiting();
	}// end if in game

	if(m_snooker->m_bPracticeMode)
		g_sponsoron = 0;

#endif
}

void CGameAppView::Render2DDebug(void)
{

	return;

}

void CGameAppView::Render2DTurn(void)
{
#ifndef MAIN_SERVER

	int n;
	int x = m_cx;
	//int y = m_cy;
	float seatOffsetX;
	static float seatOffsetY = 762.0f;

	
	float seatP1OffsetX;



	static float vy = 0.0f;

		
	if(m_snooker->m_bTurn1P) seatOffsetX = 800.0f - 612.0f;
		else seatOffsetX = 800.0f + 572.0f;




/*
	// Find out if it's P1/P2 or P3/P4 turn //
	bool dturn = 0;	// defaultly P1/P2 turn

	int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	if(tblIdx != -1)
	if(m_table[tblIdx].doubles)
	{
		if(m_snooker->m_bTurn1P)	
		{
			if(m_table[tblIdx].P1bStartAtTable == m_table[tblIdx].player1SockIdx) dturn = 1;
		}
		else
		{
			if(m_table[tblIdx].P2bStartAtTable == m_table[tblIdx].player2SockIdx) dturn = 1;
		}
	}



	if(dturn == 0) 
	{
		vy = 0.15f;
		if(seatOffsetY < 780.0f) seatOffsetY += vy;
	}
	else
	{
		vy = 0.15f;
		if(seatOffsetY > (780.0f - 32.0f)) seatOffsetY -= vy;
	}
*/
	
	static float bounce_ystart = 0.0f;
	static float bounce_y = 0.0f;
	static float bounce_vy = 0.0f;
	static int ticker = 0;
	

	ticker++;
	if(ticker == 60*4)
	{
		ticker = 0;
			
		if(bounce_y == bounce_ystart)
		{
			bounce_vy = -5.0;
		}
	}
			
	bounce_vy += 0.25;
	bounce_vy *= 0.9;
	bounce_y += bounce_vy;
	if(bounce_y >= bounce_ystart)
	{
		bounce_y = bounce_ystart;
		bounce_vy = - bounce_vy;
	}

	if(m_snooker->m_bTurn1P)
	{
		g_pFontSnk2->Render("|", seatOffsetX + bounce_y, (int)(seatOffsetY), 0.0f, 1.0f, 0.5f, 0.5f);
	}
	else
	{
		g_pFontSnk2->Render("}", seatOffsetX - bounce_y, (int)(seatOffsetY), 0.0f, 1.0f, 0.5f, 0.5f);
	}

#endif
	
}

void CGameAppView::Render3DOverlayMiniCam(DWORD width, DWORD height)
{	

	int XStart1 = 240;
	int XStart2 = 1600 - XStart1;
	int P_Width = 60;
	int N_Width = 330;
	int S_Width = 150;

	float aspect = (float)width / (float)height;
	
	// Used to Stop Memory Hacks, so we have to Decode all the Scores, High Breaks //
	m_snooker->m_customTable->Decode();

	int x,y;
	char buffer[128];

	//if(g_build.gameType == GAMETYPE_SNOOKER)
	{

		DWORD lcol;
		DWORD rcol;

		// Frames and Next Ball Info Background //
		lcol = D3DCOLOR_RGBA(50,50,50,96);
		rcol = D3DCOLOR_RGBA(50,50,50,96);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,3,-1,-1,0,lcol,lcol,0,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,2,1,-1,0,rcol,rcol,1,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,1,1,1,0,rcol,rcol,1,0);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,0,-1,1,0,lcol,lcol,0,0);

		// "View Tables (Play)" & "View Message-Board" Back Ground//
		//M2d_platedraw(700, 38, 310, 32);


		int offsetY = -10;
		int offsetX = 0;
		/*
//
		// "View Tables (Play)" & "View Message-Board" //
		if(m_bLobbyMode == 0) 
		{
			M2d_platedraw(800, 30-350, 520, 32);
			g_pFont2->Render("VIEW TABLES (Click To Play)", 800, 30-375+offsetY, 0.0f, 1.0f, 1.4f/aspect, 1.4f, MGFX_FNTDRAW_CENTER);
		}
		else 
		{
			M2d_platedraw(800, 30-350, 640, 28);
			g_pFont2->Render("VIEW MESSAGE-BOARD (Please Read)", 800, 30-375+offsetY, 0.0f, 1.0f, 1.4f/aspect, 1.4f, MGFX_FNTDRAW_CENTER);
		}
		*/

		//g_pFontSnk2->Render("n", 50, 120+offsetY, 0.0f, 1.0f, 1.0f, 1.0f);
	


		// Render Next Ball Information (Top Middle of Screen) //

		// if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			g_pFontSnk2->Render("n", 50, 20+offsetY, 0.0f, 1.0f, 1.5f / aspect, 1.5f);
		}
		//int sprOff = g_pFontSnk2->_alt['A']; // white ball offset
		
		static int NBallState = 0;
		static int PrevNBallState = 0;
		static float alpha = 1.0f;

		if(alpha < 1.0f) alpha += 0.05f;

		if(g_build.gameType == GAMETYPE_SNOOKER)
		{

			// Billiards //
			if(m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
			{
				// m_colourseq codes
				// 1 - We can Pot a Red
				// 2 - We can Pot a Red or Yellow
				// 3 - We can Pot a Red or White
				if(m_snooker->m_colourseq == 2) g_pFontSnk2->Render("BC", 60, 92+offsetY, 0.0f, 1.0f, 1.5f/aspect, 1.5f);
				else if(m_snooker->m_colourseq == 3) g_pFontSnk2->Render("BA", 60, 92+offsetY, 0.0f, 1.0f, 1.5f/aspect, 1.5f);
				else g_pFontSnk2->Render("B", 60, 92+offsetY, 0.0f, 1.0f, 1.5f/aspect, 1.5f);
			}
			// Snooker //
			else
			{
				if(m_snooker->m_colourseq > BLACK);
				else if(m_snooker->m_colourseq >= YELLOW && m_snooker->m_colourseq <= BLACK) // on colours
				{
					NBallState = 2 + m_snooker->m_colourseq;
					if(NBallState != PrevNBallState)
					{
						alpha = 0.0f;
						PrevNBallState = NBallState;
					}
					sprintf(buffer, "%c", 'A' + m_snooker->m_colourseq);
					g_pFontSnk2->Render(buffer, 60, 92+offsetY, 0.0f, alpha, 1.5f/aspect, 1.5f);
					//Mgfx_sprdraw(&m_snooker->m_snkfnt2.spr[sprOff+ m_snooker->m_colourseq], -12 + x + offsetX + 40, 4);
					}
				else // not on colours
				{	
					if(m_snooker->m_rednext) // draw red ball
					{
						NBallState = 0;
						if(NBallState != PrevNBallState)
						{
							alpha = 0.0f;
							PrevNBallState = NBallState;
						}
						g_pFontSnk2->Render("B", 60, 92+offsetY, 0.0f, alpha, 1.5f/aspect, 1.5f);
						//Mgfx_sprdraw(&m_snooker->m_snkfnt2.spr[sprOff+ RED], -12 + x + offsetX + 40, 4);
					}
					else // draw all colours
					{
						NBallState = 1;
						if(NBallState != PrevNBallState)
						{
							alpha = 0.0f;
							PrevNBallState = NBallState;
						}

						for(int n = 0; n < 6; n++)
						{
							g_pFontSnk2->Render(g_ctbl[n], 60, 82+offsetY + n * 72, 0, alpha, 1.5f/ aspect, 1.5f);
						}
						// g_pFontSnk2->Render("CDEFGH", 75, 82+offsetY, D3DX_PI * 0.5f, alpha, 1.5f, 1.5f/aspect);
						//for(n=0;n<6;n++)
						//	Mgfx_sprdraw(&m_snooker->m_snkfnt2.spr[sprOff+ YELLOW + n], -12 + x + offsetX + 40 + n*12, 4);
						}
					}

				// Display Total Points Remaining //
				static int TotalPtsLeft = 147;
				if(m_snooker->m_cueBallSelect==0 || m_snooker->m_cueBallSelect==1 || m_snooker->m_cueBallSelect==5)
				{
					TotalPtsLeft = m_snooker->TotalPtsLeft();
				}


			}	
		}
		else // GAMETYPE_POOL
		{




		}
	



		char buf[128];
		if(g_LobbyTVInfo.lobbytablewatch != -1)
		{
			sprintf(buf, "Table %d", g_LobbyTVInfo.lobbytablewatch+1);
			g_pFont2->Render(buf, 800, 1000-20, 0.0f, 1.0f, 0.8f/aspect, 0.8f, MGFX_FNTDRAW_CENTER);	// Centered Text //

			if(g_build.gameType == GAMETYPE_SNOOKER)
			{
				// %d Vs %s - Score ///
				sprintf(buf, "%d Vs %d", g_LobbyTVInfo.score1P, g_LobbyTVInfo.score2P);
				g_pFont2->Render(buf, 800, 1070 - 20, 0.0f, 1.0f, 0.8f/aspect, 0.8f, MGFX_FNTDRAW_CENTER);	// Centered Text //
				//Mgfx_fntdraw(&m_snooker->m_font3, buf, (tv_w>>1), tv_h-44-offsety, MGFX_FNTDRAW_CENTER);
				
				sprintf(buf, "%s", g_LobbyTVInfo.name1P);
				g_pFont2->Render(buf, 400, 1070 - 20, 0.0f, 1.0f, 0.8f/aspect, 0.8f, MGFX_FNTDRAW_CENTER);	// Centered Text //
				//Mgfx_fntdraw(&m_snooker->m_font3, buf, (tv_w>>2) - 24, tv_h-44-offsety, MGFX_FNTDRAW_CENTER);
				sprintf(buf, "%s", g_LobbyTVInfo.name2P);
				g_pFont2->Render(buf, 1200, 1070 - 20, 0.0f, 1.0f, 0.8f/aspect, 0.8f, MGFX_FNTDRAW_CENTER);	// Centered Text //
				//Mgfx_fntdraw(&m_snooker->m_font3, buf, (tv_w>>1) + (tv_w>>2) + 24, tv_h-40-offsety, MGFX_FNTDRAW_CENTER);

			}
			else
			{
				sprintf(buf, "%s Vs %s", g_LobbyTVInfo.name1P, g_LobbyTVInfo.name2P);
				g_pFont2->Render(buf, 800, 1070 - 20, 0.0f, 1.0f, 0.7f/aspect, 0.7f, MGFX_FNTDRAW_CENTER);	// Centered Text //
			}


			if(g_LobbyTVInfo.bTurn1P == 1) 
			{
				// Only Show Break Stats if iSnooker
				if(g_build.gameType == GAMETYPE_SNOOKER) sprintf(buf, "(Brk %d)", g_LobbyTVInfo.break1P);
					else sprintf(buf, "(1P)");
				g_pFont2->Render(buf, 400, 1140 - 20, 0.0f, 1.0f, 0.6f/aspect, 0.6f, MGFX_FNTDRAW_CENTER);	// Centered Text /
			}
			else if(g_LobbyTVInfo.bTurn1P == 0)
			{
				// Only Show Break Stats if iSnooker
				if(g_build.gameType == GAMETYPE_SNOOKER) sprintf(buf, "(Brk %d)", g_LobbyTVInfo.break2P);
					else sprintf(buf, "(2P)");
				g_pFont2->Render(buf, 1200, 1140 - 20, 0.0f, 1.0f, 0.6f/aspect, 0.6f, MGFX_FNTDRAW_CENTER);	// Centered Text /
			}
			else if(g_LobbyTVInfo.bTurn1P == 10) // "Waiting for Players..."
			{
				g_pFont2->Render("Waiting for Players...", 800, 1140 - 20, 0.0f, 1.0f, 0.7f/aspect, 0.7f, MGFX_FNTDRAW_CENTER);
			}
			else if(g_LobbyTVInfo.bTurn1P == 11) // "Waiting for Players to Start..."
			{
				g_pFont2->Render("Waiting for Players to Start...", 800, 1140 - 20, 0.0f, 1.0f, 0.7f/aspect, 0.7f, MGFX_FNTDRAW_CENTER);
			}
			else // "Acquiring Game Data..."
			{
				// If turn is -1, then we don't know who's turn it is yet, so display "Acquiring Game Data..." //
				g_pFont2->Render("Waiting For Game Data...", 800, 1140-20, 0.0f, 1.0f, 0.7f/aspect, 0.7f, MGFX_FNTDRAW_CENTER);
			}
		}
		
	}

	// Used to Stop Memory Hacks, so we have to Encode all the Scores, High Breaks after finishing displaying them //
	m_snooker->m_customTable->Encode();

}




void CGameAppView::Render2DSitButtons(void)
{	
#ifndef MAIN_SERVER



	int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	if(tblIdx != -1)
	{
		char buffer[128];
		D3DVIEWPORT9 mainViewPort;
		g_pDevice->GetViewport(&mainViewPort);

		int seatOffsetX;
		int seatOffsetY;
		

		static float timer = 0.0f;
		static float dir = 0.01f;
		timer += dir;
		if(timer >= 1.0f) dir = -0.08f;
		if(timer <= 0.3f) dir = 0.08f;
		
		CButtonEx *pButtonEx;
		int bState;

		int XStart1 = 240;
		int XStart2 = 1600 - XStart1;
		int P_Width = 60;

		int N_Width = 330;
		if(g_build.gameType == GAMETYPE_POOL) N_Width = 380;


		int DetHeight;	
		if(m_table[tblIdx].doubles) DetHeight = 8;
			else DetHeight = 19;
			
				
		// Render Seat Information //
		for(int n=0;n<4;n++)
		{
			// Only render doubles names if we are a doubles table //
			if(n>1 && !m_table[tblIdx].doubles) continue;

			if(n==0) pButtonEx = &m_sit1PButton;
			else if(n==1) pButtonEx = &m_sit2PButton;
			else if(n==2) pButtonEx = &m_sit1PButtonB;
			else pButtonEx = &m_sit2PButtonB;

			if(n==0 || n==2) seatOffsetX = XStart1+P_Width + (N_Width * 0.5);
				else seatOffsetX = XStart2-P_Width - (N_Width * 0.5);
			
			if(g_build.gameType == GAMETYPE_POOL)
			{
				if(n<=1) seatOffsetY = 766;
				else seatOffsetY = 766-22;
			}
			else
			{
				if(n<=1) seatOffsetY = 766;
				else seatOffsetY = 766-22;
			}
		
			float fntSize = 0.30f;
			
			
			if (m_table[tblIdx].doubles)
			{
				seatOffsetY += 8;
				fntSize = 0.25f;
			}
	
			if(pButtonEx)
			if(pButtonEx->m_name[0] == 0) // Seat is Empty //
			{
				bState = pButtonEx->GetState();
				if(bState) sprintf(buffer, "Sit Here");
					else sprintf(buffer, "Seat Reserved"), timer = 1.0f;
				g_pFont2->Render(buffer, seatOffsetX, seatOffsetY, 0.0f, timer, fntSize, fntSize, MGFX_FNTDRAW_CENTER);
			}
		}


	

		// Sit Button Detections //
		if(!m_lobby->m_bInLobby)
		if(g_bLobbyTBReady)
		if(m_bLButtonDown)
		{
			g_bLobbyTBReady = FALSE;
			// Find the relative position that we clicked (1600:800) range //
			int mx = (int)(((m_snooker->m_mouseX) / (float)mainViewPort.Width) * 1600.0f);
			int my = (int)(((m_snooker->m_mouseY) / (float)mainViewPort.Height) * 800.0f);
		
			if(g_build.gameType == GAMETYPE_POOL)
			{
				seatOffsetY = 782;
			}
			else
			{
				seatOffsetY = 782;
			}
			if(m_table[tblIdx].doubles) seatOffsetY +=5;
		
			if(my > (seatOffsetY-DetHeight) && my < (seatOffsetY+DetHeight)) 
			{
				

				if(mx > (800-N_Width-200) && mx < (800-N_Width+200) ) 
				{
					bState = m_sit1PButton.GetState();
					if(bState)
					if(m_sit1PButton)
					if(m_sit1PButton.m_name[0] == 0) m_sit1PButton.Clicked();
				}
				if(mx > (800+N_Width-200) && mx < (800+N_Width+200) )
				{
					bState = m_sit2PButton.GetState();
					if(bState)
					if(m_sit2PButton)
					if(m_sit2PButton.m_name[0] == 0) m_sit2PButton.Clicked();
				}
			}

			if(g_build.gameType == GAMETYPE_POOL)
			{
				seatOffsetY = 782-22;
			}
			else
			{
				seatOffsetY = 782-22;
			}
			if(m_table[tblIdx].doubles) seatOffsetY +=5;
	
			if(my > (seatOffsetY-DetHeight) && my < (seatOffsetY+DetHeight)) 
			{
				if(m_table[tblIdx].doubles)
				{
					if(mx > (800-N_Width-200) && mx < (800-N_Width+200) ) 
					{
						bState = m_sit1PButtonB.GetState();
						if(bState)
						if(m_sit1PButtonB)
						if(m_sit1PButtonB.m_name[0] == 0) m_sit1PButtonB.Clicked();
					}
					if(mx > (800+N_Width-200) && mx < (800+N_Width+200) )
					{
						bState = m_sit2PButtonB.GetState();
						if(bState)
						if(m_sit2PButtonB)
						if(m_sit2PButtonB.m_name[0] == 0)  m_sit2PButtonB.Clicked();
					}
				}
			}
		}
	}

#endif
}




void CGameAppView::Render2DCameraButtons(void)
{	
#ifndef MAIN_SERVER
	int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	if(tblIdx != -1) return;


	if(m_snooker->m_cueBallSelect != 0 || !m_snooker->m_bTurn1P) return;


	//int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	//if(tblIdx != -1)
	{
		char buffer[128];
		D3DVIEWPORT9 mainViewPort;
		g_pDevice->GetViewport(&mainViewPort);

		int seatOffsetY = 784;


		if(g_pCameraMode == 0)
		{
			//sprintf(buffer, "Cam Free");
			//g_pFont1->Render(buffer, 800-100, 15, 0.0f, 1.0f, 0.6f, 0.6f, MGFX_FNTDRAW_CENTER);

			sprintf(buffer, "Cam Auto");
			g_pFont1->Render(buffer, 800-115, -1, 0.0f, 1.0f, 0.4f, 0.4f, MGFX_FNTDRAW_CENTER);

		}
		else
		{
			sprintf(buffer, "Cam Free");
			g_pFont1->Render(buffer, 800-115, -1, 0.0f, 1.0f, 0.4f, 0.4f, MGFX_FNTDRAW_CENTER);

			//sprintf(buffer, "Cam Auto");
			//g_pFont1->Render(buffer, 800+100, 15, 0.0f, 1.0f, 0.6f, 0.6f, MGFX_FNTDRAW_CENTER);
		}
		


		// Camera Button Detections //
		// Only Do this if it's not our term or cueballselect = 0 //
		
		if(!m_lobby->m_bInLobby)
		//if(g_bLobbyTBReady)
		if(m_bLButtonDown)
		{
			g_bLobbyTBReady = FALSE;
			// Find the relative position that we clicked (1600:800) range //
			int mx = (int)(((m_snooker->m_mouseX) / (float)mainViewPort.Width) * 1600.0f);
			int my = (int)(((m_snooker->m_mouseY) / (float)mainViewPort.Height) * 800.0f);
			//m_snooker->MouseMove(CPoint(m_snooker->m_mouseX, m_snooker->m_mouseY));
			if(my > (15-15) && my < (15+15)) 
			{
				if(mx > (800-100-50) && mx < (800-100+50) )
				{
					if(g_pCameraMode == 0) 
					{
						g_pCameraMode = true;
						g_bCameraModeJustChanged = true;
					}
					else 
					{
						g_pCameraMode = false;
					}
					
					m_bOnSizeDrawTmpSurf = 1;
					m_bUpdateTable = 1;
					m_bLButtonDown = false;
				}
			}

		
		}
	}
#endif
}




void CGameAppView::Render2DNextBall(void)
{	

#ifndef MAIN_SERVER

	int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	static float alpha = 1.0f;
	float alpha_culled;
	// Camera Free Controls //
	
	

	if(g_pCameraMode)
	if( (m_snooker->m_bPracticeMode || m_bPlayOffline) || (m_GFXMode == 3 && tblIdx != -1 && !m_table[tblIdx].bGameStarted) )
	{

		if(g_bCameraModeJustChanged)
		{
			g_bCameraModeJustChanged = false;
			alpha = 10.0f;
		}
		
		if(alpha > 0.0f)
		{
			alpha_culled = alpha;
			if(alpha_culled > 1.0f) alpha_culled = 1.0f;

			g_pFont2->Render("2D/3D Free View Controls:", 300, 630, 0.0f, alpha_culled, 0.3f, 0.3f);
			g_pFont2->Render("(Options Menu)", 300+540, 630, 0.0f, alpha_culled, 0.3f, 0.3f);
			
			g_pFont2->Render("Move Camera:", 300, 630+40, 0.0f, alpha_culled, 0.3f, 0.3f);
			g_pFont2->Render("Hold Middle Mouse Button + Move Mouse", 300+300, 630+40, 0.0f, alpha_culled, 0.3f, 0.3f);
			
			g_pFont2->Render("Zoom In/Out:", 300, 630+40+40, 0.0f, alpha_culled, 0.3f, 0.3f);
			g_pFont2->Render("Mouse Wheel (Up: Zooms In, Down: Zooms Out)", 300+300, 630+40+40, 0.0f, alpha_culled, 0.3f, 0.3f);

			alpha -= 0.02f;
		}
	}



	int offsetOSY = -5;

	int XStart1 = 240;
	int XStart2 = 1600 - XStart1;
	int P_Width = 60;
	int N_Width = 330;
	int S_Width = 150;

	
	// Used to Stop Memory Hacks, so we have to Decode all the Scores, High Breaks //
	m_snooker->m_customTable->Decode();

	int x,y;
	char buffer[128];
	

	
	static float p1offsetx = 0.0f;
	static float p2offsetx = 50.0f;
	static float offsetvx = 0.0f;


	
	static int old_bturn1P = 0;

	if(m_snooker->m_bTurn1P != old_bturn1P)
	{
		old_bturn1P = m_snooker->m_bTurn1P;
		offsetvx = 0.0f;
		if(m_snooker->m_bTurn1P == 1) offsetvx = 2.0f;
			else offsetvx = -2.0f;
	}

	if(m_snooker->m_bTurn1P == 1) offsetvx += 0.3f;
		else offsetvx -= 0.3f;
	
	offsetvx *= 0.98f;

	p1offsetx += offsetvx;
	p2offsetx += offsetvx;
	
	// Bounds //
	if(p1offsetx > 0.0f) p1offsetx = 0.0f;
	if(p1offsetx < -70.0f) p1offsetx = -70.0f;
	
	if(p2offsetx > 70.0f) p2offsetx = 70.0f;
	if(p2offsetx < 0.0f) p2offsetx = 0.0f;


	// If we're practicing offline then don't everything //
	if(m_snooker->m_bPracticeMode && !m_bPlayOffline)
	{
		p1offsetx = 0.0f;
		p2offsetx = 0.0f;
	}




	if(g_build.gameType == GAMETYPE_SNOOKER)
	{

		DWORD lcol;
		DWORD rcol;

		// Frames and Next Ball Info Background //
		lcol = D3DCOLOR_RGBA(50,50,50,128);
		rcol = D3DCOLOR_RGBA(50,50,50,128);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,3,0,0,0,lcol,lcol,0,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,2,1,0,0,rcol,rcol,1,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,1,1,1,0,rcol,rcol,1,0);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,0,0,1,0,lcol,lcol,0,0);


		// Next Ball Info Background
		M2d_platedraw(4, 310, 48, 230);

		// Total Pts Remaining Background
		// M2d_platedraw(800 - 186, 30, 160, 26);

		// Render Frames Won (Top yLeft & Top Right of Screen) //
		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tblIdx != -1)
		if(m_table[tblIdx].raceTo > 0) // 1+ => 2+ racks.
		{		
			// Frames / Racks Background
			M2d_platedraw(80, 22, 150, 26);
			M2d_platedraw(1600-85-180, 22, 150, 26);
			
			// P1 (or Team1) Frames //
			sprintf(buffer, " Frames   %d(%d)", m_table[tblIdx].racksWon1P, m_table[tblIdx].raceTo+1);
			g_pFont2->Render(buffer, 78, offsetOSY+4, 0.0f, 1.0f, 0.20f, 0.20f);
			// P2 (or Team2) Frames //
			sprintf(buffer, " Frames   %d(%d)", m_table[tblIdx].racksWon2P, m_table[tblIdx].raceTo+1);
			g_pFont2->Render(buffer, 1600-87-180, offsetOSY+4, 0.0f, 1.0f, 0.20f, 0.20f);
		}


		// Render Next Ball Information (Top Middle of Screen) //
			
		   g_pFontSnk2->Render("n", 0, 84+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
		//int sprOff = g_pFontSnk2->_alt['A']; // white ball offset
		
		static int NBallState = 0;
		static int PrevNBallState = 0;
		static float alpha = 1.0f;

		if(alpha < 1.0f) alpha += 0.05f;


		// Billiards //
		if(m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
			{
			// m_colourseq codes
			// 1 - We can Pot a Red
			// 2 - We can Pot a Red or Yellow
			// 3 - We can Pot a Red or White
			if(m_snooker->m_colourseq == 2) g_pFontSnk2->Render("BC", 7+16, 116+offsetOSY-16, D3DX_PI * 0.5f, 1.0f, 0.6f, 0.6f);
			else if(m_snooker->m_colourseq == 3) g_pFontSnk2->Render("BA", 7+16, 116+offsetOSY-16, D3DX_PI * 0.5f, 1.0f, 0.6f, 0.6f);
			else g_pFontSnk2->Render("B", 7, 116+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
			}
		// Snooker //
		else{
			if(m_snooker->m_colourseq > BLACK);
			else if(m_snooker->m_colourseq >= YELLOW && m_snooker->m_colourseq <= BLACK) // on colours
				{
				NBallState = 2 + m_snooker->m_colourseq;
				if(NBallState != PrevNBallState)
				{
					alpha = 0.0f;
					PrevNBallState = NBallState;
				}
				sprintf(buffer, "%c", 'A' + m_snooker->m_colourseq);
				g_pFontSnk2->Render(buffer, 7, 116+offsetOSY, 0.0f, alpha, 0.6f, 0.6f);
				//Mgfx_sprdraw(&m_snooker->m_snkfnt2.spr[sprOff+ m_snooker->m_colourseq], -12 + x + offsetX + 40, 4);
				}
			else // not on colours
				{	
				if(m_snooker->m_rednext) // draw red ball
					{
					NBallState = 0;
					if(NBallState != PrevNBallState)
					{
						alpha = 0.0f;
						PrevNBallState = NBallState;
					}
					g_pFontSnk2->Render("B", 7, 116+offsetOSY, 0.0f, alpha, 0.6f, 0.6f);
					//Mgfx_sprdraw(&m_snooker->m_snkfnt2.spr[sprOff+ RED], -12 + x + offsetX + 40, 4);
					}
				else // draw all colours
					{
					NBallState = 1;
					if(NBallState != PrevNBallState)
					{
						alpha = 0.0f;
						PrevNBallState = NBallState;
					}

					for(int n = 0; n < 6; n++)
					{
						g_pFontSnk2->Render(g_ctbl[n], 7, 126+offsetOSY-16 + n*33, 0.0f, alpha, 0.6f, 0.6f);
					}
					// g_pFontSnk2->Render("CDEFGH", 11+30, 126+offsetOSY-16, D3DX_PI * 0.5f, alpha, 0.6f, 0.6f);
					//for(n=0;n<6;n++)
					//	Mgfx_sprdraw(&m_snooker->m_snkfnt2.spr[sprOff+ YELLOW + n], -12 + x + offsetX + 40 + n*12, 4);
					}
				}

			/*
			// Display Total Points Remaining //
			static int TotalPtsLeft = 147;
			if(m_snooker->m_cueBallSelect==0 || m_snooker->m_cueBallSelect==1 || m_snooker->m_cueBallSelect==5)
			{
				TotalPtsLeft = m_snooker->TotalPtsLeft();
			}
			sprintf(buffer, "Total Pts Left: %d", TotalPtsLeft);
			g_pFont1->Render(buffer, 800 - 180, 20, 0.0f, 1.0f, 0.6f, 0.6f);
			//if(g_gameAppView) ErrorMessage(g_gameAppView, buffer);
			*/

			}	

		//if(m_snooker->m_spriteAvatar_n>=2)
		//	{
		//	Mgfx_sprdraw(&m_snooker->m_spriteAvatar[0],m_origin.left,m_origin.top+y-2);
		//	Mgfx_sprdraw(&m_snooker->m_spriteAvatar[1],m_origin.right-40,m_origin.top+y-2);
		//	}


  		
		// Render Scores & Breaks

		// check for internet play mode or practice mode
		BOOL bSeatP1 = FALSE;
		BOOL bSeatP2 = FALSE;
		if(m_snooker->m_bPracticeMode)
		{
			// 1P player practice mode
			bSeatP1 = TRUE;
			
			// + replay mode - Note: must be in practice mode, to do replays! My Assumption CAP
			if(m_bReplayMode || m_bPlayOffline)
				bSeatP2 = TRUE;
		}
		tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tblIdx != -1)
		{
			if(m_table[tblIdx].player1SockIdx!=-1) bSeatP1 = TRUE;
			if(m_table[tblIdx].player2SockIdx!=-1) bSeatP2 = TRUE;
		}
		
		{
			if(bSeatP1)
			{
				if(m_snooker->m_bTurn1P) sprintf(buffer, "%d*", m_snooker->m_score1P);				
					else sprintf(buffer, "%d", m_snooker->m_score1P);				
				g_pFontSnk1->Render(buffer, XStart1+P_Width+N_Width+(S_Width/2)+10, 768+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
			}
			if(bSeatP2)
			{	
				// 2P's Score
				if(!m_snooker->m_bPracticeMode || m_bReplayMode || m_bPlayOffline) // check for internet play mode
				if(m_playerSockIdx != -1 || m_bReplayMode || m_bPlayOffline)
				{
					if(!m_snooker->m_bTurn1P) sprintf(buffer, "%d*", m_snooker->m_score2P);
						else sprintf(buffer, "%d", m_snooker->m_score2P);
					g_pFontSnk1->Render(buffer, XStart2-P_Width-N_Width-(S_Width)+20, 768+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
				}
			}

			/////////////

			// Display Snooker Required //
			if(m_snooker->m_bestScore)
			{
				// 1P's Break
				int diffPts = m_snooker->m_score1P - m_snooker->m_score2P;
				
				if(bSeatP1)
				{
					//if(m_snooker->m_bTurn1P)
					if( diffPts < 0 )
					{
						sprintf(buffer, "b %d", m_snooker->m_break1P);
						g_pFontSnk2->Render(buffer, XStart1+P_Width+N_Width+8, 762+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
						sprintf(buffer, "%d", m_snooker->m_bestScore);
						g_pFontSnk2->Render(buffer, XStart1+P_Width+N_Width+8+30, 762+14+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
					}
					else
					{
						sprintf(buffer, "b . %d", m_snooker->m_break1P);
						g_pFontSnk2->Render(buffer, XStart1+P_Width+N_Width+8, 762+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
					}
				}
								
				if(bSeatP2)
				{
					// 2P's Break
					if(m_playerSockIdx != -1 || m_bReplayMode || m_bPlayOffline) // this checks for practice mode (solo game)
					{
						if(!m_snooker->m_bPracticeMode || m_bReplayMode || m_bPlayOffline)
						{
							//if(!m_snooker->m_bTurn1P)
							if( diffPts > 0 )
							{
								sprintf(buffer, "b %d", m_snooker->m_break2P);
								g_pFontSnk2->Render(buffer, XStart2-P_Width-N_Width-(S_Width/2)+8, 762+offsetOSY, 0.0f, 1.0, 0.6f, 0.6f);
								sprintf(buffer, "%d", m_snooker->m_bestScore);
								g_pFontSnk2->Render(buffer, XStart2-P_Width-N_Width-(S_Width/2)+8, 762+14+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
							}
							else
							{
								sprintf(buffer, "b %d", m_snooker->m_break2P);
								g_pFontSnk2->Render(buffer, XStart2-P_Width-N_Width-(S_Width/2)+8, 762+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);	
							}
						}
					}
				}
			}
			else
			{
				if(bSeatP1)
				{
					// 1P's Break
					sprintf(buffer, "b %d", m_snooker->m_break1P);
					g_pFontSnk2->Render(buffer, XStart1+P_Width+N_Width+8, 762+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
				}
												
				if(bSeatP2)
				{
					// 2P's Break
					if(m_playerSockIdx != -1 || m_bReplayMode || m_bPlayOffline) // this checks for practice mode (solo game)
					{
						if(!m_snooker->m_bPracticeMode || m_bReplayMode || m_bPlayOffline)
						{
			
							sprintf(buffer, "b %d", m_snooker->m_break2P);
							g_pFontSnk2->Render(buffer, XStart2-P_Width-N_Width-(S_Width/2)+8, 762+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
						}
					}
				}
			}
			
		}

		
	}

else if(g_build.gameType == GAMETYPE_POOL)
	{

	
//
		DWORD lcol;
		DWORD rcol;

		// Frames and Next Ball Info Background //
		lcol = D3DCOLOR_RGBA(50,50,50,96);
		rcol = D3DCOLOR_RGBA(50,50,50,96);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,3,0,0,0,lcol,lcol,0,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,2,1,0,0,rcol,rcol,1,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,1,1,1,0,rcol,rcol,1,0);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,0,0,1,0,lcol,lcol,0,0);

		
		// Next Ball Info Background
		// M2d_platedraw(4, 310, 48, 230);

		// Total Pts Remaining Background
		// M2d_platedraw(800 - 186, 30, 160, 26);

				
		g_pDevice->SetRenderState(D3DRS_LIGHTING, true);

		// Render Frames Won (Top yLeft & Top Right of Screen) //
		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tblIdx != -1)
		if(m_table[tblIdx].raceTo > 0) // 1+ => 2+ racks.
		{				
			// Frames / Racks Background
			// M2d_platedraw(10, 30, 120, 26);
			// M2d_platedraw(1600-10-120, 30, 120, 26);
		

			// P1 (or Team1) Frames //
			sprintf(buffer, " r   %d(%d)", m_table[tblIdx].racksWon1P, m_table[tblIdx].raceTo+1);
			g_pFontSnk2->Render(buffer, 10, 20+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
			// P2 (or Team2) Frames //
			sprintf(buffer, " r   %d(%d)", m_table[tblIdx].racksWon2P, m_table[tblIdx].raceTo+1);
			g_pFontSnk2->Render(buffer, 1600-10-150, 20+offsetOSY, 0.0f, 1.0f, 0.6f, 0.6f);
		}


		// Render Next Ball Information (Top Middle of Screen) //

		static int NBallState = 0;
		static int PrevNBallState = 0;
		static float alpha = 1.0f;
		int dist;

		
		

		if(m_snooker->m_customTable->m_type == CTTYPE_UKPOOL) dist = 38;
				else dist = 38;

		
		if(m_snooker->m_customTable->m_type == CTTYPE_8BALL || m_snooker->m_customTable->m_type == CTTYPE_UKPOOL)
		{
			int n;
			int m;
			int fy = 0;
			int ballColour = 0;
			BOOL bFoundPot = FALSE;



	
		
			#ifdef LOAD_NEXTBALLLIST
			// draw 'Next' small balls
			if(m_snooker->m_cueBallSelect != 2) // if in simulation mode (cueballselect = 2), don't draw!
			{
				// If we aren't in simmulation, then make sure Ball Information Fades on
				if(alpha < 1.0f) alpha += 0.05f;
			}
			else
			{
				// In Simmulation so fade off Ball Info
				if(alpha > 0.0f) alpha -= 0.05f;
			}



			if(alpha > 0)
			{
				
				// draw next balls list
				for(m=0;m<15;m++)
				{			
					//if(m==0) g_pFontSnk2->Render("n", 800+40, 20, 0.0f, 1.0f, 0.6f, 0.6f);
									   
					bFoundPot = FALSE;
					for(n=1;n<=15;n++)
					{
						if(g_pottedSpots[n] == (m+1) || g_pottedStripes[n] == (m+1)) // potted ball?
						{
							bFoundPot = TRUE;
							break;
						}							
					}

					// Fade out balls that we can't pot //
					float active = 1.0f;
					float fade = 1.0f;
					if(m_snooker->m_bTurn1P)	// 1P Turn
					{
						if(m_snooker->m_colourseq == 2) 
						{
							if(m > 7) active = 0.25f; // 1P=SPOTS, 2P=STRIPES => Fade out Stripes
						}
						else if(m_snooker->m_colourseq == 3)
						{
							if(m < 7) active = 0.25f; // 1P=SPOTS, 2P=STRIPES => Fade out Spots
						}
					}
					else
					{
						if(m_snooker->m_colourseq == 2) 
						{
							if(m < 7) active = 0.25f; // 2P=SPOTS, 1P=STRIPES => Fade out Spots
						}
						else if(m_snooker->m_colourseq == 3)
						{
							if(m > 7) active = 0.25f; // 2P=SPOTS, 1P=STRIPES => Fade out Stripes
						}
					}

	
					if(!bFoundPot)
					{
						//Mgfx_fillrect((m_cx*0.5f-17.4*18) + m*18, 1, 24, 24, Mgfx_rgbcolor(0,0,0));
						if(m_snooker->m_customTable->m_type == CTTYPE_UKPOOL) 
						{
							if(m<=6) g_pFontSnk2->Render("R", 800 + 53 + m*dist, 4+offsetOSY, 0.0f, alpha*active, 0.55f, 0.55f); //Mgfx_sprdraw(&m_snooker->m_spritePBallSmall[16], (m_cx*0.5f) + 30 + m*dist + 45, 1);
							else if(m>=8) g_pFontSnk2->Render("Q", 800 + 53 + m*dist, 4+offsetOSY, 0.0f, alpha*active, 0.55f, 0.55f); //Mgfx_sprdraw(&m_snooker->m_spritePBallSmall[15], (m_cx*0.5f) + 30 + m*dist + 45, 1);
							else g_pFontSnk2->Render("H", 800 + 53 + m*dist, 4+offsetOSY, 0.0f, alpha*active, 0.55f, 0.55f); // Mgfx_sprdraw(&m_snooker->m_spritePBallSmall[m], (m_cx*0.5f) + 30 + m*dist + 45, 1);
						}
						else 
						{
							sprintf(buffer, "%c", 'A' + m);
							g_pFontSnk2->Render(buffer, 800 + 53 + m*dist, 4+offsetOSY, 0.0f, alpha*active, 0.55f, 0.55f); 		
						}
					}
				} // end for m 

			}

			#endif //LOAD_NEXTBALLLIST

			g_pDevice->SetRenderState(D3DRS_LIGHTING, false);

			M2d_platedraw(6, 700, 56, 420);		// Potted Balls Background //
			M2d_platedraw(6, 210, 66, 100);		// Next Ball Ball Background //
			
			if(m_snooker->m_bPracticeMode && !m_bPlayOffline);
			else 
			{
				M2d_platedraw(1600-6-56, 700, 56, 420);		// Potted Balls Background //
				M2d_platedraw(1600-6-66, 210, 66, 100);		// Next Ball Ball Background //
			}
			
			g_pDevice->SetRenderState(D3DRS_LIGHTING, true);
	
			// Next Ball / Table Status //
			ballColour = m_snooker->m_colourseq;
			if(ballColour == 0)
				ballColour = 1;

			bool drawnext;

			char low_n = 0;
			char high_n = 0;

			int i;
			for(i=0;i<15;i++)
			if(g_pottedSpots[i] != -1) low_n++;
			
			for(i=0;i<15;i++)
			if(g_pottedStripes[i] != -1) high_n++;


			if(m_snooker->m_bTurn1P)
			{
				drawnext = true;
				x = 6+4 + p1offsetx;
				y = 110+offsetOSY;
				g_pFontSnk2->Render("n :", x, y, 0.0f, alpha, 0.6f, 0.6f);	
				y += 38;
				x = 6+33 + p1offsetx;
				if(ballColour == 2) 
				{
					if(low_n >= 7) sprintf(buffer, "8-Ball"), drawnext = false;
						else sprintf(buffer, "Low");
				}
				else if(ballColour == 3) 
				{
					if(high_n >= 7) sprintf(buffer, "8-Ball"), drawnext = false;
						else sprintf(buffer, "High");
				}
				else sprintf(buffer, "Open");


				g_pFont2->Render(buffer, x, y, 0.0f, alpha, 0.3f, 0.3f, MGFX_FNTDRAW_CENTER);	
				y += 24;
				if(drawnext)
				{
					if(ballColour == 2 || ballColour == 3) g_pFont2->Render("Balls", x, y, 0.0f, alpha, 0.3f, 0.3f, MGFX_FNTDRAW_CENTER);
					else g_pFont2->Render("Table", x, y, 0.0f, alpha, 0.3f, 0.3f, MGFX_FNTDRAW_CENTER);
				}
			}
			else
			{
				drawnext = true;
				x = 1600-66-6+4 + p2offsetx;
				y = 110+offsetOSY;
				g_pFontSnk2->Render("n:", x, y, 0.0f, alpha, 0.6f, 0.6f);	
				y += 38;
				x = 1600-66-6+33 + p2offsetx;
				if(ballColour == 2) 
					{
						if(high_n >= 7) sprintf(buffer, "8-Ball"), drawnext = false;
							else sprintf(buffer, "High");
					}
					else if(ballColour == 3) 
					{
						if(low_n >= 7) sprintf(buffer, "8-Ball"), drawnext = false;
							else sprintf(buffer, "Low");
					}
				else sprintf(buffer, "Open");

				g_pFont2->Render(buffer, x, y, 0.0f, alpha, 0.3f, 0.3f, MGFX_FNTDRAW_CENTER);	
				y += 24;
				if(drawnext)
				{
					if(ballColour == 2 || ballColour == 3) g_pFont2->Render("Balls", x, y, 0.0f, alpha, 0.5f, 0.5f, MGFX_FNTDRAW_CENTER);
					else g_pFont2->Render("Table", x, y, 0.0f, alpha, 0.3f, 0.3f, MGFX_FNTDRAW_CENTER);
				}
			}



			// Draw Potted Spots //
			y = 300+offsetOSY;
			if(m_snooker->m_colourseq == 2)	x = 8+2 + p1offsetx;				// 1P=STRIPES & 2P=SPOTS
			else if(m_snooker->m_colourseq == 3) x = 1600-50-8+2 + p2offsetx;	// 1P=SPOTS & 2P=STRIPES
			else;


			for(m=0;m<16;m++)
			if(g_pottedSpots[m] != -1)
			if(m_snooker->m_colourseq == 3 || m_snooker->m_colourseq == 2)
			{
				ballColour = m_snooker->m_ball[g_pottedSpots[m]]->m_colour;
				if(ballColour >= 1)
				{
					if(m_snooker->m_customTable->m_type == CTTYPE_UKPOOL)
					{
						if((ballColour-1)<=6) sprintf(buffer, "R");
						else if((ballColour-1)>=8) sprintf(buffer, "Q");
						else sprintf(buffer, "%c", 'A' + (ballColour-1));
					}
					else
					{
						sprintf(buffer, "%c", 'A' + (ballColour-1));
					}

					g_pFontSnk2->Render(buffer, x, y, 0.0f, alpha, 0.7f, 0.7f);	
					y += 48;
				}
			}




			// Draw Potted Stripes //
			y = 300+offsetOSY;

			if(m_snooker->m_colourseq == 3)	x = 8+2 + p1offsetx;				// 1P=STRIPES & 2P=SPOTS
			else if(m_snooker->m_colourseq == 2) x = 1600-50-8+2 + p2offsetx;	// 1P=SPOTS & 2P=STRIPES
			else;


			for(m=0;m<16;m++)
			if(g_pottedStripes[m] != -1)
			if(m_snooker->m_colourseq == 3 || m_snooker->m_colourseq == 2)
			{
				ballColour = m_snooker->m_ball[g_pottedStripes[m]]->m_colour;
			

				if(ballColour >= 1)
				{
					if(m_snooker->m_customTable->m_type == CTTYPE_UKPOOL)
					{
						if((ballColour-1)<=6) sprintf(buffer, "R");
						else if((ballColour-1)>=8) sprintf(buffer, "Q");
						else sprintf(buffer, "%c", 'A' + (ballColour-1));
					}
					else
					{
						sprintf(buffer, "%c", 'A' + (ballColour-1));
					}

					g_pFontSnk2->Render(buffer, x, y, 0.0f, alpha, 0.7f, 0.7f);	
					y += 48;
				}
			}




		}

	//else g_pFontSnk2->Load(640, 120, 12, "Graphics/HUD/ipoolfnt2.png", "-0123456789*()bnr,.P!@#$ABCDEFGHIJKLMNO QR STUV");
		///////////////////////////////////
		///////////////////////////////////
		else if(m_snooker->m_customTable->m_type == CTTYPE_9BALL ||
				m_snooker->m_customTable->m_type == CTTYPE_10BALL ||
				m_snooker->m_customTable->m_type == CTTYPE_6BALL)
		{
			int n;
			int m;
			int fy = 0;
			int ballColour = 0;
			BOOL bFoundPot = FALSE;

#ifdef LOAD_NEXTBALLLIST				
			// draw 'Next' small balls

			if(m_snooker->m_cueBallSelect != 2) // if in simulation mode (cueballselect = 2), don't draw!
			{
				// If we aren't in simulation, then make sure Ball Information Fades on
				if(alpha < 1.0f) alpha += 0.05f;
			}
			else
			{
				// In Simulation so fade off Ball Info
				if(alpha > 0.0f) alpha -= 0.05f;
			}



			if(alpha > 0)
			{
				int balls_n;
				if(m_snooker->m_customTable->m_type == CTTYPE_9BALL) balls_n = 9;
				else if(m_snooker->m_customTable->m_type == CTTYPE_10BALL) balls_n = 10;
				else balls_n = 6;

				for(m=0;m<balls_n;m++)
				{			
					//if(m==0) g_pFontSnk2->Render("n", 800+40, 20, 0.0f, 1.0f, 0.6f, 0.6f);
					
						   
					bFoundPot = FALSE;
					for(n=1;n<=9;n++)
					if(g_pottedSpots[n] == (m+1)) // potted ball?
					{
						bFoundPot = TRUE;
						break;
					}


						if(!bFoundPot)
						{ 
							sprintf(buffer, "%c", 'A' + m);
							g_pFontSnk2->Render(buffer, 800 + 53 + m*dist, 4+offsetOSY, 0.0f, alpha, 0.55f, 0.55f); //Mgfx_sprdraw(&m_snooker->m_spritePBallSmall[m], (m_cx*0.5f) + 30 + m*dist + 45, 1);//-16 + 64 + m*(16+4), -16 + 10);		
						}
		
					} // end for m
					

				}
#endif //LOAD_NEXTBALLLIST

		
			// Draw Potted Balls (9-Ball) //
			g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
			if(m_snooker->m_bTurn1P)
			{
				M2d_platedraw(6, 210, 66, 100);		// Next Ball Ball Background //
				M2d_platedraw(6, 750, 56, 450);		// Potted Balls Background //
				x = 8+2+p1offsetx;			
			}
			else
			{
				M2d_platedraw(1600-6-56, 210, 66, 100);		// Next Ball Ball Background //
				M2d_platedraw(1600-6-56, 750, 56, 450);		// Potted Balls Background //
				x = 1600-50-8+2+p2offsetx;				
			}
			g_pDevice->SetRenderState(D3DRS_LIGHTING, true);

			// Next Ball //
			ballColour = m_snooker->m_colourseq;
			if(ballColour == 0)
				ballColour = 1;

			y = 110+offsetOSY;
			if(ballColour >= 1)
			{
				g_pFontSnk2->Render("n:%c", x, y, 0.0f, alpha, 0.7f, 0.7f);	
				y += 48+offsetOSY;
				sprintf(buffer, "%c", 'A' + (ballColour-1));
				g_pFontSnk2->Render(buffer, x, y, 0.0f, alpha, 0.7f, 0.7f);	
				y += 48;
			}



			y = 312+offsetOSY;
			ballColour = 0;
			for(m=0;m<16;m++)
			if(g_pottedSpots[m] != -1)
			{
				ballColour = m_snooker->m_ball[g_pottedSpots[m]]->m_colour;
	
				// Balls Potted
				if(ballColour >= 1)
				{
					sprintf(buffer, "%c", 'A' + (ballColour-1));
					g_pFontSnk2->Render(buffer, x, y, 0.0f, alpha, 0.7f, 0.7f);	
					y += 48;
				}
			}

			
		}

		else if((m_snooker->m_customTable->m_type == CTTYPE_ROTATIONBALL) )
		{
			int n;
			int m;
			int fy = 0;
			int ballColour = 0;
			BOOL bFoundPot = FALSE;

#ifdef LOAD_NEXTBALLLIST
			// draw 'Next' small balls
			if(m_snooker->m_cueBallSelect != 2) // if in simulation mode (cueballselect = 2), don't draw!
			{
				// If we aren't in simmulation, then make sure Ball Information Fades on
				if(alpha < 1.0f) alpha += 0.05f;
			}
			else
			{
				// In Simmulation so fade off Ball Info
				if(alpha > 0.0f) alpha -= 0.05f;
			}



			if(alpha > 0)
			{
		
				for(m=0;m<15;m++)
				{			
					//if(m==0)
					//Mgfx_fntdraw(&m_snooker->m_snkfnt2, "n", (m_cx*0.5f) + m*18 + 11 + 45+4, 1+8, MGFX_FNTDRAW_CENTER);
					//if(m==0) g_pFontSnk2->Render("n", 800+40, 20, 0.0f, 1.0f, 0.6f, 0.6f);		

					bFoundPot = FALSE;
					for(n=1;n<=15;n++)
					if(g_pottedSpots[n] == (m+1)) // potted ball?
					{
						bFoundPot = TRUE;
						break;
					}

					if(!bFoundPot)
					{
						//Mgfx_fillrect((m_cx*0.5f-17.4*18) + m*18, 1, 24, 24, Mgfx_rgbcolor(0,0,0));
						//Mgfx_sprdraw(&m_snooker->m_spritePBallSmall[m], (m_cx*0.5f) + 30 + m*18 + 45, 1);//-16 + 64 + m*(16+4), -16 + 10);		
						sprintf(buffer, "%c", 'A' + m);
						g_pFontSnk2->Render(buffer, 800 + 53 + m*dist, 4+offsetOSY, 0.0f, alpha, 0.55f, 0.55f); //Mgfx_sprdraw(&m_snooker->m_spritePBallSmall[m], (m_cx*0.5f) + 30 + m*dist + 45, 1);//-16 + 64 + m*(16+4), -16 + 10);		
	

					}
										
					//sprintf(buffer, "%d", 1+m);
					//Mgfx_fntdraw(&m_snooker->m_snkfnt2, buffer, (m_cx*0.5f) + 30 + m*18 + 11 + 45, 1+22, MGFX_FNTDRAW_CENTER);
				} // end for m
/*
				// draw '-' to indicate which ball selected					
				if(m_snooker->m_cueBallSelect != 0)
				{
					int selectBall = m_snooker->m_selectBall;
					if(selectBall>=1 && selectBall<=15) // object-balls
					{
						sprintf(buffer, "-");
						Mgfx_fntdraw(&m_snooker->m_snkfnt2, buffer, (m_cx*0.5f) + 30 + (selectBall-1)*18 + 11 + 45, 1+22+6, MGFX_FNTDRAW_CENTER);
					}
					else if(selectBall == 0) // cue-ball
					{
						int colour = m_snooker->m_testBall->m_colour;
						if(colour>=1 && colour<=15)
						{
							sprintf(buffer, "-");
							Mgfx_fntdraw(&m_snooker->m_snkfnt2, buffer, (m_cx*0.5f) + 30 + (colour-1)*18 + 11 + 45, 1+22+6, MGFX_FNTDRAW_CENTER);
						}
					}
				}
*/
			}
#endif //LOAD_NEXTBALLLIST
	

			// Draw Next Balls (Rotation-Ball) //
			y = 497+offsetOSY;

			ballColour = m_snooker->m_colourseq;
			if(ballColour == 0)
				ballColour = 1;

			g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
			M2d_platedraw(6, 650, 66, 160);		// Potted Balls Background //
						
			if(m_snooker->m_bPracticeMode && !m_bPlayOffline);
			else M2d_platedraw(1600-6-66, 650, 66, 160);		// Potted Balls Background //
			g_pDevice->SetRenderState(D3DRS_LIGHTING, true);

			if(m_snooker->m_bTurn1P) x = 6+4+p1offsetx;
				else x = 1600-66-6+4+p2offsetx;

			if(ballColour >= 1)
			{
				g_pFontSnk2->Render("n:%c", x, y, 0.0f, alpha, 0.7f, 0.7f);	
				y += 46+offsetOSY;
				sprintf(buffer, "%c", 'A' + (ballColour-1));
				g_pFontSnk2->Render(buffer, x, y, 0.0f, alpha, 0.7f, 0.7f);	
				y += 48;
			}
			
			// Draw scores for 1P & 2P
			x = 6+4+p1offsetx;
			g_pFontSnk2->Render("z:", x, y, 0.0f, alpha, 0.7f, 0.7f);	
			y += 24;
			sprintf(buffer, "%d(61)", m_snooker->m_score1P);
			g_pFontSnk2->Render(buffer, x, y, 0.0f, alpha, 0.7f, 0.7f);	

			if(m_snooker->m_bPracticeMode && !m_bPlayOffline);	// If we're playing offline, in practice, don't display break for P2
			else
			{
				y -= 24;
				x = 1600-66-6+4+p2offsetx;
				g_pFontSnk2->Render("z:", x, y, 0.0f, alpha, 0.7f, 0.7f);	
				y += 26;
				sprintf(buffer, "%d(61)", m_snooker->m_score2P);
				g_pFontSnk2->Render(buffer, x, y, 0.0f, alpha, 0.7f, 0.7f);	
			}	
		}


	

		else if((m_snooker->m_customTable->m_type == CTTYPE_BREAK) )
		{

			int n;
			int m;
			int fy = 0;
			int ballColour = 0;
			BOOL bFoundPot = FALSE;

			
			// draw Legal Ball to Pot ball left on table

			int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);

			g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
			M2d_platedraw(6, 600, 66, 290);				// Next Ball Ball Background //
			if(m_snooker->m_bPracticeMode && !m_bPlayOffline);	// If we're playing offline, in practice, don't display break for P2
				else M2d_platedraw(1600-6-66, 600, 66, 290);		// Next Ball Ball Background //

			g_pDevice->SetRenderState(D3DRS_LIGHTING, true);

			if(m_snooker->m_bTurn1P) x = 8+2+p1offsetx;			
				else x = 1600-66-4+2+p2offsetx;				


			// Next Ball //
			ballColour = m_snooker->m_colourseq;
			if(ballColour == 0)
				ballColour = 1;

			y = 330+offsetOSY;

			g_pFontSnk2->Render("n:%c", x, y, 0.0f, alpha, 0.7f, 0.7f);
			y += 44+offsetOSY;
			if(m_snooker->m_colourseq<=1) g_pFontSnk2->Render("S", x, y, 0.0f, alpha, 0.7f, 0.7f);
			else if(m_snooker->m_colourseq == 11) g_pFontSnk2->Render("T", x, y, 0.0f, alpha, 0.7f, 0.7f);
			else if(m_snooker->m_colourseq == 12) g_pFontSnk2->Render("U", x, y, 0.0f, alpha, 0.7f, 0.7f);
			else if(m_snooker->m_colourseq == 13) g_pFontSnk2->Render("V", x, y, 0.0f, alpha, 0.7f, 0.7f);
			else
			{
				g_pFontSnk2->Render("T", x, y, 0.0f, alpha, 0.7f, 0.7f);
				y += 48;
				g_pFontSnk2->Render("U", x, y, 0.0f, alpha, 0.7f, 0.7f);
				y += 48;
				g_pFontSnk2->Render("V", x, y, 0.0f, alpha, 0.7f, 0.7f);

			}
			y += 48;
	 


			x = 6+p1offsetx;
			sprintf(buffer, "%d", m_snooker->m_score1P, m_snooker->m_highBreaks1P[0]);
			g_pFontSnk2->Render(buffer, x + 33, y, 0.0f, alpha, 0.75f, 0.75f, 1);		// Centered Text //
			y += 28;
			sprintf(buffer, "b:%d", m_snooker->m_score1P, m_snooker->m_highBreaks1P[0]);
			g_pFontSnk2->Render(buffer, x + 33, y, 0.0f, alpha, 0.55f, 0.55f, 1);		// Centered Text //
			//Mgfx_fntdraw(&m_snooker->m_snkfnt2, buffer, (m_cx*0.5f) - 70, 26, MGFX_FNTDRAW_CENTER);						
					
			if(m_snooker->m_bPracticeMode && !m_bPlayOffline);	// If we're playing offline, in practice, don't display break for P2
			else
			{
				x = 1600-66-6+p2offsetx;
				sprintf(buffer, "%d", m_snooker->m_score2P, m_snooker->m_highBreaks2P[0]);
				g_pFontSnk2->Render(buffer, x + 33, y, 0.0f, alpha, 0.75f, 0.75f, 1);		// Centered Text //
				y += 28;
				sprintf(buffer, "b:%d", m_snooker->m_score2P, m_snooker->m_highBreaks2P[0]);
				g_pFontSnk2->Render(buffer, x + 33, y, 0.0f, alpha, 0.55f, 0.55f, 1);		// Centered Text //
				//Mgfx_fntdraw(&m_snooker->m_snkfnt2, buffer, (m_cx*0.5f) + 70, 26, MGFX_FNTDRAW_CENTER);
			}	
		}
			
		else if(m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
		{

				int n, m;
				int ballColour = 0;
				int _blues = 0, _reds = 0;

				g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
				M2d_platedraw(6, 700, 56, 290);		// Potted Balls Background //
				M2d_platedraw(1600-6-56, 700, 56, 290);		// Potted Balls Background //
			
				g_pDevice->SetRenderState(D3DRS_LIGHTING, true);

				for(n=1;n<=5;n++)
					if(!m_snooker->m_customTable->RefereeBowlsBallOnTable(n))
						_blues++;

				for(n=6;n<=10;n++)
					if(!m_snooker->m_customTable->RefereeBowlsBallOnTable(n))
						_reds++;

				y = 630+offsetOSY;
				x = 6+28+p1offsetx;

				// draw blue bowls
				for(m=0;m<_blues;m++)
				{			
					g_pFontSnk2->Render("W", x, y, 0.0f, alpha, 0.7f, 0.7f, MGFX_FNTDRAW_CENTER);
					y -= 48;
				}

				// draw red bowls
				y = 630+offsetOSY;
				x = 1600-56-6+28+p2offsetx;
				ballColour = 0;
				for(m=0;m<_reds;m++)			
				{			
					g_pFontSnk2->Render("X", x, y, 0.0f, alpha, 0.7f, 0.7f, MGFX_FNTDRAW_CENTER);
					y -= 48;
				}
			}
		
	g_pDevice->SetRenderState(D3DRS_LIGHTING, false);

	} // iPool Condition 

	


	// Used to Stop Memory Hacks, so we have to Encode all the Scores, High Breaks after finishing displaying them //
	m_snooker->m_customTable->Encode();
	
#endif
}

void CGameAppView::InitSponsor(void)
{
	m_sponsoralpha = 0.25;
	strcpy(m_sponsortxt,"");//Sponsored by");	
	
	if(g_build.gameType == GAMETYPE_POOL) strcpy(m_sponsorurl,"http://www.thepoolclub.com/index2.php?mainframe=sponsor");
		else strcpy(m_sponsorurl,"http://www.thesnookerclub.com/index2.php?mainframe=sponsor");
	//strcpy(m_sponsortxt,"Sponsored by memirsoftware");
	//strcpy(m_sponsorurl,"http://www.memirsoftware.com");
}

void CGameAppView::ProcessSponsor(void)
{
	if(g_sponsoron) 
	{
	if(m_sponsoralpha<0.25)	m_sponsoralpha+= 0.001;
	else m_sponsoralpha = 0.25;
	}
	else 
	{
	if(m_sponsoralpha>0) m_sponsoralpha-= 0.001;
	else m_sponsoralpha = -1;
	}
}


void CGameAppView::Render2DOverLayPower(void)
{
#ifndef MAIN_SERVER

	// Power Bar // PowerBar



//if(m_snooker->m_cueBallSelect==0 || m_snooker->m_cueBallSelect==1 || m_snooker->m_cueBallSelect==5)
//if(m_snooker->m_bCueState)
if(m_snooker->MyTurn())
{
	
	M3d_sprdraw_PLATE.mat[0].d3dm.Diffuse.a = 0.75f; // Change Plate Alpha
	M3d_sprdraw_PLATE.mat[0].d3dm.Ambient.a = 0.75f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.a = 0.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Emissive.a = 0.75f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.r = 0.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.g = 0.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.b = 0.0f;


	int renderoffsetx = 0;
	if(g_build.gameType == GAMETYPE_POOL) renderoffsetx = 105;
		else renderoffsetx = 50;



	{
	DWORD top = D3DCOLOR_RGBA(48,48,48,192);
	DWORD bot = D3DCOLOR_RGBA(22,22,22,192);

	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,3,0,0,0,bot,bot,0,1);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,2,1,0,0,bot,bot,1,1);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,1,1,1,0,top,top,1,0);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,0,0,1,0,top,top,0,0);
	}
	
	M2d_platedraw(1600-renderoffsetx, 675, 32, 550);

	if(m_snooker->m_cueBallSelect==0 || m_snooker->m_cueBallSelect==1 || m_snooker->m_cueBallSelect==5)
	if(m_snooker->m_bCueState)
	{
	
		
		float fx,fy;
		fx = (float)m_snooker->m_cuePowerPercentage*0.01;
		fy = (float)m_snooker->m_cuePowerPercentage*0.01;

		//M3d_objectset_VERTEX(&M3d_sprdraw_PLATE,3,-0.5,0,0,0,1);
		//M3d_objectset_VERTEX(&M3d_sprdraw_PLATE,2,0.5,0,0,1,1);
		//M3d_objectset_VERTEX(&M3d_sprdraw_PLATE,1,0.5,2*fy,0,1,1-fy);
		//M3d_objectset_VERTEX(&M3d_sprdraw_PLATE,0,-0.5,2*fy,0,0,1-fy);

		
		DWORD top;
		DWORD bot;
		int g;
		g = 256-fy*256;

		g = g*0.5;
		if(g<0) g = 0;
		if(g>255) g = 255;

		//top = D3DCOLOR_RGBA(255,255,0,255);//RGBA(_256TO1(255),_256TO1(g),_256TO1(0),0.75);
		//bot = D3DCOLOR_RGBA(255,255,0,255);//RGBA(_256TO1(255),_256TO1(128),_256TO1(0),0.75);
		top = D3DCOLOR_RGBA(255,g,0,255);
		bot = D3DCOLOR_RGBA(255,255,0,255);


		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,3,0,0,0,bot,bot,0,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,2,1,0,0,bot,bot,1,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,1,1,1*fy,0,top,top,1,1-fy);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,0,0,1*fy,0,top,top,0,1-fy);
		

		
		M2d_platedraw(1600-renderoffsetx, 675, 32, 550);
		//M2d_sprdraw(&m_snooker->m_spritePower,1024-76+overlayPowerOffsetX,768-128,32,512);//*(float)m_snooker->m_cuePowerPercentage*0.01,512*(float)m_snooker->m_cuePowerPercentage*0.01);
		
		M3d_sprdraw_PLATE.mat[0].d3dm.Diffuse.a = 1.0f;
		M3d_sprdraw_PLATE.mat[0].d3dm.Ambient.a = 1.0f;
		M3d_sprdraw_PLATE.mat[0].d3dm.Specular.a = 1.0f;
		M3d_sprdraw_PLATE.mat[0].d3dm.Emissive.a = 1.0f;

	}
	char buffer[80];
	int offsetx = 0;


	if(m_snooker->m_bCueState && (m_snooker->m_cueBallSelect==0 || m_snooker->m_cueBallSelect==1 || m_snooker->m_cueBallSelect==5) )
	{
		sprintf(buffer, "POWER BAR: %d%%", (int)m_snooker->m_cuePowerPercentage);
		g_pFont2->Render(buffer, 1600-renderoffsetx+3, 550, -D3DX_PI*0.5f, 1.0f, 0.30f, 0.30f);
	}
	else
	{
		sprintf(buffer, "POWER BAR: %d%%", 0);
		g_pFont2->Render(buffer, 1600-renderoffsetx+3, 550, -D3DX_PI*0.5f, 0.3f, 0.30f, 0.30f);
	}


} // end myturn/cuestate [power bar]
	// ************************************************************************** //

#endif
}



void CGameAppView::Render3DOverLayHelper(void)
{
	
#ifndef MAIN_SERVER

	if(m_chalkChanger->bShow) return;
	if(m_cueChanger->bShow) return;

	M3d_vtx pos,scale,rot;
	D3DXMATRIX matRotX, matRotY, matRotZ, matTrans, matScale;

	
	if(m_snooker->m_cueBallSelect==0 || m_snooker->m_cueBallSelect==5)
	if(m_snooker->MyTurn())
	{
	float f;
	M2d_sprshape(M2D_SHAPE_RECTCENTER);

	M3d_sprdraw_PLATE.mat[0].d3dm.Diffuse.a = 0.5f; // Change Plate Alpha
	M3d_sprdraw_PLATE.mat[0].d3dm.Ambient.a = 0.5f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.a = 0.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Emissive.a = 0.5f;

	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.r = 0.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.g = 0.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.b = 0.0f;


	f = sin(((float)m_cyc)*0.07);
	if(f<0) f = -f;
	f*=20;

	scale[0] = 48;
	scale[1] = 48;
	scale[2] = 1;

	if(m_snooker->m_cueBallSelect == 0)
	{	
		
		
		int cueBallIdx = 0;
		
		if(g_build.gameType == GAMETYPE_SNOOKER)
		if(m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
			{
			if(m_snooker->m_bTurn1P) cueBallIdx = 0;
				else cueBallIdx = 1;
			}

		if(g_build.gameType == GAMETYPE_POOL)
			if(m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
				cueBallIdx = m_snooker->m_customTable->RefereeBowlsNextStrikeBall();
		
		pos[0] = m_snooker->m_ball[cueBallIdx]->m_P.x-(BALL_RADIUS+43+f);
		pos[1] = m_snooker->m_ball[cueBallIdx]->m_P.y+(BALL_RADIUS+43+f);
		pos[2] = m_snooker->m_ball[cueBallIdx]->m_P.z;
		
		rot[0] = 3.1415926;
		rot[1] = 0;
		rot[2] = 3.1415926;	



		// Calculate Scale matrix
		D3DXMatrixScaling(&matScale, scale[0], scale[1], scale[2]);

		// Calculate rotation matrix
		D3DXMatrixRotationX( &matRotX, rot[0] );
		D3DXMatrixRotationY( &matRotY, rot[1] );
		D3DXMatrixRotationZ( &matRotZ, rot[2] );
		
		// Calculate a translation matrix
		D3DXMatrixTranslation(&matTrans, pos[0], pos[1], pos[2]);

		D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
		g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
		M3d_sprdraw(m_snooker->m_spriteArrow3D);
	}
	else {
	// Power bar
	int overlayHelperOffsetX;
	int overlayHelperOffsetY;
	if(g_build.gameType == GAMETYPE_POOL)
	{
		overlayHelperOffsetX = 0;
		overlayHelperOffsetY = 0;
	}
	else
	{
		overlayHelperOffsetX = -490;	
		overlayHelperOffsetY = 135;	
	}

	pos[0] = -1300+f+overlayHelperOffsetX;
	pos[1] = 485+f+overlayHelperOffsetY;
	pos[2] = 32;
	
	rot[0] = 3.1415926f;
	rot[1] = 0;
	rot[2] = 3.1415926f*0.5f;	

	//M3d_transformobject(pos,rot,scale);
	// Calculate Scale matrix
	D3DXMatrixScaling(&matScale, scale[0], scale[1], scale[2]);

	// Calculate rotation matrix
	D3DXMatrixRotationX( &matRotX, rot[0] );
	D3DXMatrixRotationY( &matRotY, rot[1] );
	D3DXMatrixRotationZ( &matRotZ, rot[2] );
	
	// Calculate a translation matrix
	D3DXMatrixTranslation(&matTrans, pos[0], pos[1], pos[2]);

	D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
	g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);

	M3d_sprdraw(m_snooker->m_spriteArrow3D);
	}

	//M2d_sprdraw(&m_snooker->m_spriteArrow3D,pos[0],pos[1],32,32);
	}

	if(m_snooker->m_cueBallSelect==1)// || m_snooker->m_cueBallSelect==5)
	if(m_snooker->MyTurn())
	{
	// mouse-pointer in 3D (helper)

	pos[0] = m_snooker->m_tableMousePos[0];
	pos[1] = m_snooker->m_tableMousePos[1];
	pos[2] = 32;

	rot[0] = 3.1415926f;
	rot[1] = 0;
	rot[2] = 3.1415926f * 1.5f;

	scale[0] = 48;
	scale[1] = 48;
	scale[2] = 1;

	//M2d_sprshape(M2D_SHAPE_RECT); // Standard upright view

	M3d_objectset_VERTEX(&M3d_sprdraw_PLATE,3,0,-2,0,0,1);
	M3d_objectset_VERTEX(&M3d_sprdraw_PLATE,2,2,-2,0,1,1);
	M3d_objectset_VERTEX(&M3d_sprdraw_PLATE,1,2,0,0,1,0);
	M3d_objectset_VERTEX(&M3d_sprdraw_PLATE,0,0,0,0,0,0);
	pos[0]-=64;

	//M3d_transformobject(pos,rot,scale);

	// Calculate Scale matrix
	D3DXMatrixScaling(&matScale, scale[0], scale[1], scale[2]);

	// Calculate rotation matrix
	D3DXMatrixRotationX( &matRotX, rot[0] );
	D3DXMatrixRotationY( &matRotY, rot[1] );
	D3DXMatrixRotationZ( &matRotZ, rot[2] );
	
	// Calculate a translation matrix
	D3DXMatrixTranslation(&matTrans, pos[0], pos[1], pos[2]);

	D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
	g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);


	M3d_sprdraw(m_snooker->m_spriteArrow3D);
	}

if(m_snooker->m_cueBallSelect==0 || m_snooker->m_cueBallSelect==1 || m_snooker->m_cueBallSelect==5)
if(m_snooker->m_bCueState)
if(m_snooker->MyTurn())
{


		
#ifdef THE_POOL_CLUB
	scale[0] = 768;
	scale[1] = 768;
	scale[2] = 1;
#else
	scale[0] = 920;//1152;
	scale[1] = 920;//1152;
	scale[2] = 1;
#endif

	float a;
	float x,y;
#ifdef FIXEDMODE
	x = FROMFIXSMALL(m_snooker->m_ball[m_snooker->m_selectBall]->f_P.x);
	y = FROMFIXSMALL(m_snooker->m_ball[m_snooker->m_selectBall]->f_P.y);
#else
	x = m_snooker->m_ball[m_snooker->m_selectBall]->m_P.x;
	y = m_snooker->m_ball[m_snooker->m_selectBall]->m_P.y;
#endif

	RECT r1;
	r1.left = m_snooker->m_point.x + 16;
	r1.top = m_snooker->m_point.y + 16;
	r1.right = r1.left + 60;
	r1.bottom = r1.top + 30;

	char buffer[80];
	sprintf(buffer, "%d%%", (int)m_snooker->m_cuePowerPercentage);
	g_pFont->DrawText(NULL, buffer, strlen(buffer), &r1, 0, 0xFFFFFFFF);

/*

	a = Mgame_avect(m_snooker->m_tableMousePos[0]-x,
				m_snooker->m_tableMousePos[1]-y);
	a-=128;
	a*= FF2RAD;
 	
	x+= cos(-a)*(BALL_RADIUS+64);
	y+= sin(-a)*(BALL_RADIUS+64);


	pos[0] = x;
	pos[1] = y+scale[1]*0.01;
	pos[2] = m_snooker->m_ball[0]->m_P.z;

	rot[0] = 3.1415926;
	rot[1] = 0;
	rot[2] = 3.1415926;	

	M2d_sprshape(M2D_SHAPE_RECT);

	//M2d_transform(1024-84,384+64,1,1,-90*DEG2RAD);

	M3d_sprdraw_PLATE.mat[0].d3dm.Diffuse.a = 1.0f; // Change Plate Alpha
	M3d_sprdraw_PLATE.mat[0].d3dm.Ambient.a = 1.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.a = 0.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Emissive.a = 1.0f;


	// Calculate Scale matrix
	D3DXMatrixScaling(&matScale, scale[0], scale[1], scale[2]);

	// Calculate rotation matrix
	D3DXMatrixRotationX( &matRotX, rot[0] );
	D3DXMatrixRotationY( &matRotY, rot[1] );
	D3DXMatrixRotationZ( &matRotZ, rot[2] );
	
	// Calculate a translation matrix
	D3DXMatrixTranslation(&matTrans, pos[0], pos[1], pos[2]);

	D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
	g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);



	char buffer[80];
	sprintf(buffer, "%d%%", (int)m_snooker->m_cuePowerPercentage);
	//M3d_sprdraw(&m_snooker->m_spriteArrow3D);

	//g_pDevice->SetRenderState(D3DRENDERSTATE_SRCBLEND,D3DBLEND_SRCCOLOR);
	//g_pDevice->SetRenderState(D3DRENDERSTATE_DESTBLEND,D3DBLEND_INVSRCCOLOR);
	if(!g_gfxDetails.bOptionsDrawStaticPower)
	{
		M2d_fntdraw(&m_snooker->m_font, buffer,MGFX_FNTDRAW_CENTER);
	}

	g_pDevice->SetRenderState(D3DRENDERSTATE_SRCBLEND,D3DBLEND_SRCALPHA);
	g_pDevice->SetRenderState(D3DRENDERSTATE_DESTBLEND,D3DBLEND_INVSRCALPHA);

*/
}
#endif
}


void CGameAppView::Render3DOverLayTargetPocket(void)
{
#ifndef MAIN_SERVER

	M3d_vtx pos,scale,rot;

	int n;

	if(!m_snooker->m_bCallShot)
		return;

	if(m_snooker->m_targetPocket == -1)
		return;

	D3DXMATRIX matRotX, matRotY, matRotZ, matTrans, matScale;

	/////////////////////////////////////////////////////////////////////////////////////////////////////
	if(m_snooker->m_cueBallSelect != 2)
	{
		if(m_snooker->m_customTable->m_tableType >= 3 && m_snooker->m_customTable->m_tableType <= 8)
		{

			// scan thru all pockets
			for(n=0;n<m_snooker->m_customTable->m_pocket_n;n++)
			if((n == m_snooker->m_targetPocket) || (m_snooker->m_targetPocket == -2))
			{
				float f;
			
				if(m_snooker->m_targetPocket == -2)
				{			
					f = sin(((float)m_cyc)*0.070f); // 0.005
					if(f<0) f = -f;
					f*=24;
				}
				else
				{
					f = sin(((float)m_cyc)*0.070f); // 0.005
					if(f<0) f = -f;
					f*=16;
				}

				scale[0] = 32;
				scale[1] = 32;
				scale[2] = 1;
				
				pos[0] = m_snooker->m_customTable->m_pocketPos[n].x;
				pos[1] = m_snooker->m_customTable->m_pocketPos[n].y;
				pos[2] = m_snooker->m_customTable->m_pocketPos[n].z;

				rot[0] = 3.1415926f;
				rot[1] = 0.0f;
				rot[2] = 3.1415926f * 1.5f;

				// offsets
				rot[2] = 3.1415926 + (3.1415926/4);
				pos[1] += f;

			}
		// Calculate Scale matrix
		if(m_snooker->m_targetPocket == -2) D3DXMatrixScaling(&matScale, 36.0f, 36.0f, 1.0f);
			else D3DXMatrixScaling(&matScale, 44.0f, 44.0f, 1.0f);

		// Calculate rotation matrix
		D3DXMatrixRotationX( &matRotX, rot[0] );
		D3DXMatrixRotationY( &matRotY, rot[1] );
		D3DXMatrixRotationZ( &matRotZ, rot[2] );
		
		// Calculate a translation matrix
		D3DXMatrixTranslation(&matTrans, pos[0], pos[1], pos[2]);



		D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
		g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);

		if(m_snooker->m_targetPocket == -2)	M3d_sprdraw(m_snooker->m_TextureQMark);	// Question Mark 
		else M3d_sprdraw(m_snooker->m_TextureArrowWhite);
		
		return;


		}
		else
		{
			for(n=0;n<6;n++)
			if((n == m_snooker->m_targetPocket) || (m_snooker->m_targetPocket == -2))
			{
				float f;
			
				if(m_snooker->m_targetPocket == -2)
				{			
					f = sin(((float)m_cyc)*0.070); // 0.005
					if(f<0) f = -f;
					f*=24;
				}
				else
				{
					f = sin(((float)m_cyc)*0.070); // 0.005
					if(f<0) f = -f;
					f*=16;
				}

				scale[0] = 32;
				scale[1] = 32;
				scale[2] = 1;
				
				pos[0] = m_snooker->m_customTable->m_pocketPos[n].x;
				pos[1] = m_snooker->m_customTable->m_pocketPos[n].y;
				pos[2] = m_snooker->m_customTable->m_pocketPos[n].z;

				rot[0] = 3.1415926;
				rot[1] = 0;
				rot[2] = 0;


		
				// defualt table pockets...
				switch(n)
				{
					case 0:// bottom - left pocket
						pos[0] -= BALL_RADIUS + f;
						pos[1] += BALL_RADIUS + f;
						rot[2] = -3.1415926;
						break;
					case 1:// top - left pocket
						pos[0] -= BALL_RADIUS + f;
						pos[1] -= BALL_RADIUS + f;
						rot[2] = -(3.1415926/2);
						break;
					case 2:// bottom - middle pocket
						//pos[0] -= BALL_RADIUS + f;
						pos[1] += BALL_RADIUS + f;
						rot[2] = -3.1415926 - (3.1415926/4);
						break;
					case 3:// top - middle pocket
						//pos[0] -= BALL_RADIUS + f;
						pos[1] -= BALL_RADIUS + f;
						rot[2] = -(3.1415926/4);
						break;
					case 4:// bottom - right pocket
						pos[0] += BALL_RADIUS + f;
						pos[1] += BALL_RADIUS + f;
						rot[2] = -3.1415926 - (3.1415926/2);
						break;
					case 5:// top - right pocket
						pos[0] += BALL_RADIUS + f;
						pos[1] -= BALL_RADIUS + f;
						rot[2] = 0;
						break;
					default:
						rot[2] = 3.1415926 + (3.1415926/4);
						pos[1] += f;
						break;
				}

			if(m_snooker->m_targetPocket == -2) rot[2] += (3.1415926/4);

			// Calculate Scale matrix
			if(m_snooker->m_targetPocket == -2) D3DXMatrixScaling(&matScale, 36.0f, 36.0f, 1.0f);
				else D3DXMatrixScaling(&matScale, 44.0f, 44.0f, 1.0f);

			// Calculate rotation matrix
			D3DXMatrixRotationX( &matRotX, rot[0] );
			D3DXMatrixRotationY( &matRotY, rot[1] );
			D3DXMatrixRotationZ( &matRotZ, rot[2] );
			
			// Calculate a translation matrix
			D3DXMatrixTranslation(&matTrans, pos[0], pos[1], pos[2]);



			D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
			g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);

			if(m_snooker->m_targetPocket == -2)	M3d_sprdraw(m_snooker->m_TextureQMark);	// Question Mark 
			else M3d_sprdraw(m_snooker->m_TextureArrowWhite);

			}
		return;
		}
	
	
	}

#endif	
}

void CGameAppView::Render3DOverLayTargetBall(void)
{

#ifndef MAIN_SERVER
	
	static float fy = 0.0f; 
	static int oldtarget = -1;
	static float impulse = 0.0f;
	

	M3d_vtx pos, rot;
								   
	int n;

	if(!m_snooker->m_bCallShot)
		return;

	if(m_snooker->m_targetBall == -1)
	{
		oldtarget = -1;
		return;
	}
	//if(m_snooker->m_cueBallSelect == 5)
	if(m_snooker->m_cueBallSelect != 2)
	{

		if(m_snooker->m_targetBall != oldtarget)
		{
			fy = 0.0f;
			oldtarget = m_snooker->m_targetBall;
			impulse = 0.4f;
		}

		impulse *= 0.90f;
		fy += impulse;




		#ifdef FIXEDMODE
		CVector P;
		P.x = FROMFIXSMALL(m_snooker->m_ball[m_snooker->m_targetBall]->f_P.x);
		P.y = FROMFIXSMALL(m_snooker->m_ball[m_snooker->m_targetBall]->f_P.y);
		P.z = FROMFIXSMALL(m_snooker->m_ball[m_snooker->m_targetBall]->f_P.z);
		#else
		CVector P = m_snooker->m_ball[m_snooker->m_targetBall]->m_P;
		#endif
			




		rot[0] = 3.1415926f;
		rot[1] = 0;
		rot[2] = 3.1415926f * 1.5f;

		pos[0] = P.x;
		pos[1] = P.y;
		pos[2] = P.z + BALL_DRAWOFFSETZ;
	
		D3DXMATRIX matRotX, matRotY, matRotZ, matTrans, matScale;
		
		// Calculate Scale matrix
		float sc = 44.0f + sin(fy) * 8.0f;
		D3DXMatrixScaling(&matScale, sc, sc, 1.0f);

		// Calculate rotation matrix
		D3DXMatrixRotationX( &matRotX, rot[0] );
		D3DXMatrixRotationY( &matRotY, rot[1] );
		D3DXMatrixRotationZ( &matRotZ, rot[2] );
		
		// Calculate a translation matrix
		D3DXMatrixTranslation(&matTrans, pos[0], pos[1], pos[2]);

		D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
		g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
		M3d_sprdraw(m_snooker->m_TextureRing);

	}
#endif
}


void CGameAppView::Render3DWhiteTouchingBallsMiniCam(void)
{

/*
	M3d_vtx pos;
	M3d_vtx scale;
	M3d_vtx rot;

	//	m_touchingBallIdx = 0;
	for(int t=0; t<MAX_TOUCHING_BALLS; t++)
	if(m_snooker->m_touchingBall[t])
	{
		CVector N;
		N = m_snooker->m_ball[0]->m_P - m_snooker->m_ball[m_snooker->m_touchingBall[t]]->m_P;
		N = N.Unit();
		N = N * BALL_RADIUS;

		pos[0] = m_snooker->m_ball[0]->m_P.x - N.x;
		pos[1] = m_snooker->m_ball[0]->m_P.y - N.y;
		pos[2] = m_snooker->m_ball[0]->m_P.z + BALL_DRAWOFFSETZ;
		
		
		g_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE); // Disable Z-Buf.

		/////////////////////////////////	
		scale[0] = 0.25f * 0.5;
		scale[1] = 0.25f * 0.5;
		scale[2] = 0.25f * 0.5;
		m_snooker->DrawBallPos2(pos, 0.0f, 0.0f, 0.0f, FALSE, scale);

		
		/////////////////////////////////	

		g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE); // Enable Z-Buf.
	}
*/
}

void CGameAppView::Render3DOverLayHelperMini(void)
{
#ifndef MAIN_SERVER

	static float raisedCueAlpha = 0.0f;
	static float statsAlpha = 0.0f;

	// render other useful GFX
	if ((m_snooker->MyTurn() && m_snooker->m_cueBallSelect == 5))
	{
		if (statsAlpha < 1.0f) statsAlpha += 0.05f;
	}
	else
	{
		if (statsAlpha > 0.0f) statsAlpha -= 0.05f;
	}



	if(statsAlpha > 0.0f)
	{
		if (g_mouseSector != SECTOR_MINI)
		{

			float f;
			f = sin(((float)m_cyc)*0.07);
			if (f<0) f = -f;
			f *= 35;

			g_pFontSnk2->Render("Y", 980 + f*2.0f, 120.0f - 2.0*f, 0.0f, statsAlpha, 2.0f, 2.0f);


			// M2d_sprdraw(&m_snooker->m_spriteArrow3D, 1024*0.75+f,768*0.25-f,128,96);
		}



		

		// Show the Cross (where the centre is)
		g_pFontSnk2->Render("+", 800-35, 400-35, 0.0f, 0.4f, 0.8f, 0.8f);

		// Show a cross at the top and bottom of ball too (if Mini Cam Show Helper is on)
		if (g_gfxDetails.bOptionsMiniCamShowHelpers)
		{
			g_pFontSnk2->Render("+", 800 - 35, 400 - 35 + 220, 0.0f, 0.4f, 1.0f, 1.0f);
			g_pFontSnk2->Render("+", 800 - 35, 400 - 35 - 240, 0.0f, 0.4f, 1.0f, 1.0f);
		}


		

		// Strike Cue-Ball / Close-Up text //
		if(m_snooker->m_ball[m_snooker->m_selectBall]->m_colour == WHITE)
		{
			g_pFont2->Render("Strike Cue-Ball", 800, 5, 0.0f, statsAlpha, 0.6f, 0.6f, 1);
			
		}
		else
		{
			g_pFont2->Render("Close-Up", 800, 5, 0.0f, statsAlpha, 0.6f, 0.6f, 1);
		}

		// Raised Butt Text //
		int angle;
		if( m_snooker->MyTurn() ) // use slider to control raising butt
		{
			// display angle of cue's butt // degree '' = 248 ASCII value
			angle = 90 - m_sliderRaiseButt.GetPos();
		}		
		else // set slider pos
		{			
			m_sliderRaiseButt.SetPos(90 - m_snooker->m_RaiseButt);
			angle = 90 - m_sliderRaiseButt.GetPos();
		}
				
		if (angle > 0)
		{
			if (raisedCueAlpha < 1.0f) raisedCueAlpha += 0.02f;
		}
		else
		{
			if (raisedCueAlpha > 0) raisedCueAlpha -= 0.02f;
		}

		if (raisedCueAlpha > 0.0f)
		{
			sprintf(buffer, "%d", angle);
			g_pFont2->Render(buffer, 1050, 80, 0.0f, raisedCueAlpha, 0.7f, 0.7f);
		}

		
	}


#endif
}

void CGameAppView::Render3DOverLay3D2DToggle(void)
{
	/*
//if(m_snooker->MyTurn())

if(g_gameAppView)
if(g_gameAppView->m_GFXMode == 3)
	{
	M3d_vtx pos,scale,rot;
	float f;
	if(m_snooker->m_3dtoggle_status == 0) f = sin(((float)m_cyc)*0.003);
		else f = sin(((float)m_cyc)*0.006);
	if(f<0) f = -f;
	f*=15;

	M2d_sprshape(M2D_SHAPE_RECTCENTER);
	M3d_sprdraw_PLATE.mat[0].d3dm.Diffuse.a = 1.0f; // Change Plate Alpha
	M3d_sprdraw_PLATE.mat[0].d3dm.Ambient.a = 1.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.a = 0.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Emissive.a = 1.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.r = 0.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.g = 0.0f;
	M3d_sprdraw_PLATE.mat[0].d3dm.Specular.b = 0.0f;

	float bounce;
	bounce = sin(((float)m_cyc)*0.01) * 0.2;
	//if(bounce<0) bounce = -bounce;
	//bounce*=32;
	
	// Display 5 Cameras //
	int n;
	for(n=0;n<5;n++)
		{
		if(m_snooker->m_3dtoggle == (n+1)) 
			{
			M2d_sprdraw(&m_snooker->m_spriteCam[n*2],240+n*150,80,120+bounce+f*0.2,96+f*0.2);
			}
		else{
			if(m_snooker->m_3dtoggle_status == n) M2d_sprdraw(&m_snooker->m_spriteCam[n*2],240+n*150,90,100+f*0.5,80+f*0.5);
				else M2d_sprdraw(&m_snooker->m_spriteCam[n*2],240+n*150,90,100,80);
			}
		}

	}

	*/

}



void CGameAppView::Render2DOverLaySeating(void)
{
#ifndef MAIN_SERVER
	int n;
	RECT rect;
	int offset;
	char buffer[81];
	CButtonEx *pButtonEx = NULL;
	int seatOffsetX;
	int seatOffsetY;
	int seatP1OffsetX;

	DWORD lcol;
	DWORD rcol;

	int XStart1 = 240;
	int XStart2 = 1600 - XStart1;
	int P_Width = 60;
	
	
	int N_Width = 330;
	if(g_build.gameType == GAMETYPE_POOL) N_Width = 380;
	int S_Width = 140;

	int TblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);

	for(n=0;n<4;n++)
	{	


		if(!m_table[TblIdx].doubles) 
		{
			if(n > 1) break;
		}

		if(g_build.gameType == GAMETYPE_POOL)
		{
			if(n<=1) seatOffsetY = 796;
				else seatOffsetY = 796-19;
		}
		else
		{
			if(n<=1) seatOffsetY = 796;
				else seatOffsetY = 796-19;
		}

		if(n == 0) pButtonEx = &m_sit1PButton;
		else if(n == 1) pButtonEx = &m_sit2PButton;
		else if(n == 2) pButtonEx = &m_sit1PButtonB;
		else if(n == 3) pButtonEx = &m_sit2PButtonB;
		
		if(!pButtonEx) continue;

		DWORD lcol;
		DWORD rcol;

		lcol = D3DCOLOR_RGBA(0,0,0,255);
		rcol = D3DCOLOR_RGBA(0,0,0,255);

		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,3,0,0,0,lcol,lcol,0,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,2,1,0,0,rcol,rcol,1,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,1,1,1,0,rcol,rcol,1,0);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,0,0,1,0,lcol,lcol,0,0);
		

		//if(TblIdx == -1) return;

		

		// P1, P2 Background // (don't show P3 and P4 for now)
		if(n < 2)
		{
		if(n==0 || n==2) M2d_platedraw(XStart1, seatOffsetY, P_Width, 30);
			else M2d_platedraw(XStart2-P_Width, seatOffsetY, P_Width, 30);
		}

		if(g_build.gameType != GAMETYPE_POOL)
		{
			// Score & Break Background //
			if(n==0) M2d_platedraw(XStart1+P_Width+N_Width, seatOffsetY, S_Width, 30);
				else if(n==1) M2d_platedraw(XStart2-P_Width-N_Width-S_Width, seatOffsetY, S_Width, 30);
		}
		
		// Main Rectangle //
		lcol = D3DCOLOR_RGBA(0,0,0,128);
		rcol = D3DCOLOR_RGBA(0,0,0,128);

		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,3,0,0,0,lcol,lcol,0,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,2,1,0,0,rcol,rcol,1,1);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,1,1,1,0,rcol,rcol,1,0);
		M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,0,0,1,0,lcol,lcol,0,0);

		// Player Name Background
		if(!m_table[TblIdx].doubles)
		{
			if(n==0) M2d_platedraw(XStart1+P_Width, seatOffsetY, N_Width, 30);
			if(n==1) M2d_platedraw(XStart2-P_Width-N_Width, seatOffsetY, N_Width, 30);
		}
		else
		{
			if(n==0) M2d_platedraw(XStart1+P_Width, seatOffsetY, N_Width, 17);
			else if(n==1) M2d_platedraw(XStart2-P_Width-N_Width, seatOffsetY, N_Width, 17);
			else if(n==2) M2d_platedraw(XStart1+P_Width, seatOffsetY, N_Width, 17);
			else if(n==3) M2d_platedraw(XStart2-P_Width-N_Width, seatOffsetY, N_Width, 17);
		}
	
	
		
		if(n==0 || n==2) seatOffsetX = XStart1+P_Width+(N_Width>>1);
			else seatOffsetX = XStart2-P_Width-(N_Width>>1);

		if(g_build.gameType == GAMETYPE_POOL)
		{
			if(n<=1) seatOffsetY = 767;
				else seatOffsetY = 767-22;
		}
		else
		{
			if(n<=1) seatOffsetY = 767;
				else seatOffsetY = 767-22;
		}
	

		float FontSize = 0.28f;
		if (m_table[TblIdx].doubles)
		{
			FontSize = 0.25;
			seatOffsetY += 10;
		}
		


		// Player Name //
		if(pButtonEx->m_name[0])
			{
			if(n < 2) g_pFont2->Render(pButtonEx->m_name, seatOffsetX, seatOffsetY, 0.0f, 1.0f, FontSize, FontSize, MGFX_FNTDRAW_CENTER);	
				else g_pFont2->Render(pButtonEx->m_name, seatOffsetX, seatOffsetY, 0.0f, 0.3f, FontSize, FontSize, MGFX_FNTDRAW_CENTER);	
			//Mgfx_fntdrawEllipsis(&m_snooker->m_font2, pButtonEx->m_name,160-7,40+n*(x-160-80)+8 - seatOffsetX, x*0.5f+4+8 - g_yBarOffset + seatOffsetY + 2,MGFX_FNTDRAW_LEFT);
			}
		else if(m_bReplayMode) // replay mode - i.e. in practice mode
		{
			if(!m_snooker->m_replayname1 && !m_snooker->m_replayname2)
			{
				CString playerName;
				playerName.Format("Player%d", n+1);
				g_pFont2->Render(playerName.GetBuffer(0), seatOffsetX, seatOffsetY, 0.0f, 1.0f, FontSize, FontSize, MGFX_FNTDRAW_CENTER);
				//Mgfx_fntdrawEllipsis(&m_snooker->m_font2, playerName.GetBuffer(0),160-7,40+n*(x-160-80)+8 - seatOffsetX, x*0.5f+4+8 - g_yBarOffset + seatOffsetY + 2,MGFX_FNTDRAW_LEFT);
			}
			else
			{
				if(!n)
					g_pFont2->Render(m_snooker->m_replayname1, seatOffsetX, seatOffsetY, 0.0f, 1.0f, FontSize, FontSize, MGFX_FNTDRAW_CENTER);
					//Mgfx_fntdrawEllipsis(&m_snooker->m_font2, m_snooker->m_replayname1,160-7,40+n*(x-160-80)+8 - seatOffsetX, x*0.5f+4+8 - g_yBarOffset + seatOffsetY + 2,MGFX_FNTDRAW_LEFT);
				else
					g_pFont2->Render(m_snooker->m_replayname2, seatOffsetX, seatOffsetY, 0.0f, 1.0f, FontSize, FontSize, MGFX_FNTDRAW_CENTER);
					//Mgfx_fntdrawEllipsis(&m_snooker->m_font2, m_snooker->m_replayname2,160-7,40+n*(x-160-80)+8 - seatOffsetX, x*0.5f+4+8 - g_yBarOffset + seatOffsetY + 2,MGFX_FNTDRAW_LEFT);
			}
		}
		else if(m_bPlayOffline)
		{
			CString playerName;
			playerName.Format("Player%d", n+1);
			g_pFont2->Render(playerName.GetBuffer(0), seatOffsetX, seatOffsetY, 0.0f, 1.0f, FontSize, FontSize, MGFX_FNTDRAW_CENTER);
			//Mgfx_fntdrawEllipsis(&m_snooker->m_font2, playerName.GetBuffer(0),160-7,40+n*(x-160-80)+8 - seatOffsetX, x*0.5f+4+8 - g_yBarOffset + seatOffsetY + 2,MGFX_FNTDRAW_LEFT);
		}
		


		seatOffsetY = 763;



		//seatOffsetY;
		if(n==0 || n==2) seatOffsetX = XStart1+7;
			else seatOffsetX = XStart2-P_Width+5;



		// display 1P / 2P
		CString playerName;
		
		if(n<2)
		{
			if(n==0) playerName.Format("P!");
			else if(n==1) playerName.Format("P@");
			//else if(n==2) playerName.Format("P#");
			//else if(n==3) playerName.Format("P$");
			g_pFontSnk2->Render(playerName.GetBuffer(0), seatOffsetX, seatOffsetY, 0.0f, 1.0f, 0.6f, 0.6f);
		}


		////////////////
		// Timer Text //
		////////////////

		if(n==0 || n==2) seatOffsetX = XStart1-P_Width-32;
			else seatOffsetX = XStart2+P_Width+32;
		
		seatOffsetY = 796;

		// timer box
		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tblIdx != -1)
		if(m_table[tblIdx].addTimer)
		{
			if( (m_snooker->m_bTurn1P && n==0) ||
				(!m_snooker->m_bTurn1P && n==1) )
			{	

				// Timer Background
				M2d_platedraw(seatOffsetX-30, seatOffsetY, 60, 32);
				if(g_build.gameType == GAMETYPE_SNOOKER)
				{
					char strShotTime[80];
					sprintf(strShotTime, "%d", ((m_snooker->m_shotTime-1) / 50)+1);

					// override if it's 'myturn' & the timer is 'below 0'
					if(m_snooker->m_shotTime < 0)
						if( m_snooker->MyTurn() )
							sprintf(strShotTime, "%d", 0);
					g_pFont2->Render(strShotTime, seatOffsetX, seatOffsetY-28, 0.0f, 1.0f, 0.32f, 0.32f, MGFX_FNTDRAW_CENTER);
				}

				else if(g_build.gameType == GAMETYPE_POOL)
				{
					char strShotTime[80];
					sprintf(strShotTime, "%d", ((m_snooker->m_shotTime-1) / 50)+1);
					// override if it's 'myturn' & the timer is 'below 0'
					if(m_snooker->m_shotTime < 0)
						if( m_snooker->MyTurn() )					
							sprintf(strShotTime, "%d", 0);	
				g_pFont2->Render(strShotTime, seatOffsetX, seatOffsetY-28, 0.0f, 1.0f, 0.32f, 0.32f, MGFX_FNTDRAW_CENTER);
				}
			}
		}



	}
	
#endif
}


void CGameAppView::Render3DScene(float alpha, float intensity)
{
	
#ifndef MAIN_SERVER

	D3DXMATRIX matView;
    D3DXMATRIX matWorld;
    D3DXMATRIX matRotation;
    D3DXMATRIX matTranslation;

	if( g_pDevice )
	{
		D3DXMATRIX matRotX, matRotY, matRotZ, matTrans, matScale;

		// Calculate Scale matrix
		D3DXMatrixScaling(&matScale, 1.0f, 1.0f, 1.0f);

		// Calculate rotation matrix
		D3DXMatrixRotationX( &matRotX, D3DX_PI * 0.5f );
		D3DXMatrixRotationY( &matRotY, 0.0f );
		D3DXMatrixRotationZ( &matRotZ, 0.0f );
		
		// Calculate a translation matrix
		D3DXMatrixTranslation(&matTrans, 0.0f, 0.0f, 0.0f);

		D3DXMATRIX matWorld = matScale*(matRotX*matRotY*matRotZ)*matTrans;
		g_pDevice->SetTransform(D3DTS_WORLD, &matWorld);
		
		//
		// Draw the scene:
		//

		// g_pDevice->SetMaterial(&d3d::WHITE_MTRL);
		// g_pDevice->SetTexture(0, Tex);




		for(int i=0;i<XMesh_SFrameMtrls.size();i++)
		{
			g_pDevice->SetMaterial( &XMesh_SFrameMtrls[i] );
			g_pDevice->SetTexture(0, XMesh_SFrameTextures[i] );
			XMesh_SFrame->DrawSubset(i);
				
		}
		
	}

#endif
}

float g_fAttenuation0 = 0.14f;
float g_fAttenuation1 = 0.00003f;
float g_fAttenuation2 = 0.0000009f;

float g_fAmbient = 0.3f;
float g_fSpecular = 0.5f;
float g_fDiffuse = 1.0f;

float g_fPOS = 800.0f;
float g_fRange = 5000.0f;


float g_fPower = 60.0f;




void AdjustLights(void)
{
#ifndef MAIN_SERVER

	return;

	if( ::GetAsyncKeyState('U') & 0x8000f ) g_pDevice->LightEnable(0, false);
	if( ::GetAsyncKeyState('I') & 0x8000f ) g_pDevice->LightEnable(0, true);
	
	if( ::GetAsyncKeyState('H') & 0x8000f ) g_pDevice->LightEnable(1, false);
	if( ::GetAsyncKeyState('J') & 0x8000f ) g_pDevice->LightEnable(1, true);
	
	if( ::GetAsyncKeyState('B') & 0x8000f ) g_pDevice->LightEnable(2, false);
	if( ::GetAsyncKeyState('N') & 0x8000f ) g_pDevice->LightEnable(2, true);
	
		

	if( ::GetAsyncKeyState('O') & 0x8000f ) g_fPower += 1.0f;
	if( ::GetAsyncKeyState('P') & 0x8000f ) g_fPower -= 1.0f;



	if( ::GetAsyncKeyState('Q') & 0x8000f )
	{
		g_fAttenuation0 *= 0.99f;
	}
	if( ::GetAsyncKeyState('W') & 0x8000f )
	{
		g_fAttenuation0 *= 1.01f;
	}
	if( ::GetAsyncKeyState('A') & 0x8000f )
	{
		g_fAttenuation1 *= 0.99f;
	}
	if( ::GetAsyncKeyState('S') & 0x8000f )
	{
		g_fAttenuation1 *= 1.01f;
	}
	if( ::GetAsyncKeyState('Z') & 0x8000f )
	{
		g_fAttenuation2 *= 0.99f;
	}
	if( ::GetAsyncKeyState('X') & 0x8000f )
	{
		g_fAttenuation2 *= 1.01f;
	}


	if( ::GetAsyncKeyState('E') & 0x8000f )
	{
		g_fAmbient *= 0.99f;
	}
	if( ::GetAsyncKeyState('R') & 0x8000f )
	{
		g_fAmbient *= 1.01f;
	}
	if( ::GetAsyncKeyState('D') & 0x8000f )
	{
		g_fSpecular *= 0.99f;
	}
	if( ::GetAsyncKeyState('F') & 0x8000f )
	{
		g_fSpecular *= 1.01f;
	}
	if( ::GetAsyncKeyState('C') & 0x8000f )
	{
		g_fDiffuse *= 0.99f;
	}
	if( ::GetAsyncKeyState('V') & 0x8000f )
	{
		g_fDiffuse *= 1.01f;
	}



	if( ::GetAsyncKeyState('T') & 0x8000f )
	{
		g_fRange *= 0.99f;
	}
	if( ::GetAsyncKeyState('Y') & 0x8000f )
	{
		g_fRange *= 1.01f;
	}

	if( ::GetAsyncKeyState('G') & 0x8000f )
	{
		g_fPOS *= 0.99f;
	}
	if( ::GetAsyncKeyState('H') & 0x8000f )
	{
		g_fPOS *= 1.01f;
	}


	//
	// Set a omi light.
	//

	D3DLIGHT9 light;
	::ZeroMemory(&light, sizeof(light));
	light.Type      = D3DLIGHT_POINT;
	light.Ambient   = D3DXCOLOR(g_fAmbient, g_fAmbient, g_fAmbient, 1.0f);
	light.Diffuse   = D3DXCOLOR(g_fDiffuse, g_fDiffuse, g_fDiffuse, 1.0f);
	light.Specular  = D3DXCOLOR(g_fSpecular, g_fSpecular, g_fSpecular, 1.0f);
	
	light.Attenuation0 = g_fAttenuation0;
	light.Attenuation1 = g_fAttenuation1;
	light.Attenuation2 = g_fAttenuation2;
	light.Range = g_fRange;
	
	light.Position.x = 0.0f;
	light.Position.y = 0.0f;
	light.Position.z = g_fPOS;

	g_pDevice->SetLight(0, &light);



	light.Type      = D3DLIGHT_POINT;
	light.Ambient   = D3DXCOLOR(g_fAmbient, g_fAmbient, g_fAmbient, 1.0f);
	light.Diffuse   = D3DXCOLOR(g_fDiffuse, g_fDiffuse, g_fDiffuse, 1.0f);
	light.Specular  = D3DXCOLOR(g_fSpecular, g_fSpecular, g_fSpecular, 1.0f);
	
	light.Attenuation0 = g_fAttenuation0;
	light.Attenuation1 = g_fAttenuation1;
	light.Attenuation2 = g_fAttenuation2;
	light.Range = g_fRange;
	
	light.Position.x = 1600.0f;
	light.Position.y = 0.0f;
	light.Position.z = g_fPOS;

	g_pDevice->SetLight(1, &light);



	light.Type      = D3DLIGHT_POINT;
	light.Ambient   = D3DXCOLOR(g_fAmbient, g_fAmbient, g_fAmbient, 1.0f);
	light.Diffuse   = D3DXCOLOR(g_fDiffuse, g_fDiffuse, g_fDiffuse, 1.0f);
	light.Specular  = D3DXCOLOR(g_fSpecular, g_fSpecular, g_fSpecular, 1.0f);
	
	light.Attenuation0 = g_fAttenuation0;
	light.Attenuation1 = g_fAttenuation1;
	light.Attenuation2 = g_fAttenuation2;
	light.Range = g_fRange;
	
	light.Position.x = -1600.0f;
	light.Position.y = 0.0f;
	light.Position.z = g_fPOS;

	g_pDevice->SetLight(2, &light);

	g_pDevice->LightEnable(0, true);
	g_pDevice->LightEnable(1, true);
	g_pDevice->LightEnable(2, true);
	
#endif
}



void CGameAppView::Clear3DScene(void)
{
	g_pDevice->SetRenderTarget(0, m_pBGSurf);

	// Now we can clear just view-port's portion of the buffer to red...
	g_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
							D3DCOLOR_COLORVALUE( 0.133f, 0.118f, 0.098f, 1.0f ), 1.0f, 0L );


	g_pDevice->SetRenderTarget(0, pRenderSurface);

	g_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
							D3DCOLOR_COLORVALUE( 0.133f, 0.118f, 0.098f, 1.0f ), 1.0f, 0L );

}

void CGameAppView::Render3D(float timeDelta)
{
	
#ifndef MAIN_SERVER


	if(g_pDevice == NULL) return;

	HRESULT hr;



	// Temp Code for Lighting //
	AdjustLights();

	//
	// Set the projection matrix.
	//

	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	int ypos_start = (436-ceil(offsetX*0.5f)-g_yBarOffset);

	CRect clientrect;
	CRect srect;
	CRect drect;
	::GetWindowRect(g_hwndDX, clientrect);

	g_dwMainViewWidth = clientrect.Width();
	g_dwMainViewHeight = clientrect.Height(); //ypos_start;




	D3DVIEWPORT9 mainViewPort;

    mainViewPort.X      = 0;
    mainViewPort.Y      = 0;
    mainViewPort.Width  = g_dwMainViewWidth;
	mainViewPort.Height = g_dwMainViewHeight;
    mainViewPort.MinZ   = 0.0f;
    mainViewPort.MaxZ   = 1.0f;


	float aspect = (float)mainViewPort.Width / (float)mainViewPort.Height;


	// Initialise the Camera position //
	Render3DSetupCamera();

	// Check if we changed Camera View: If so, update the Scene - Table //
	static int oldmode = 0;
	if(oldmode != m_snooker->m_CameraMode) 
	{
		m_bUpdateTable = true;
	}
	oldmode = m_snooker->m_CameraMode;

	

	// Make sure our Camera knows what FOV and Aspect Ratio we are using //
	if(!g_pCameraMode)
	{
		//g_pCamera->_cameraFov = D3DX_PI * 0.20f;
		g_pCamera->_cameraAspect = aspect;
	}
	else
	{
		//g_pCameraFree->_cameraFov = D3DX_PI * 0.20f;
		g_pCameraFree->_cameraAspect = aspect;
	}


	D3DXMATRIX proj;
	if(!g_pCameraMode)
	{
		D3DXMatrixPerspectiveFovLH(
				&proj,
				g_pCamera->_cameraFov, // D3DX_PI * 0.20f, // 90 - degree
				aspect,
				100.0f,
				10000.0f);
	}
	else
	{
		D3DXMatrixPerspectiveFovLH(
				&proj,
				g_pCamera->_cameraFov, //D3DX_PI * 0.20f, // 90 - degree
				aspect,
				g_pCameraFree->_nearclip,
				g_pCameraFree->_farclip);
	}
	g_pDevice->SetTransform(D3DTS_PROJECTION, &proj);


	//IDirect3DSurface9 backbuffer;
	//HRESULT hr = g_pDevice->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &backbuffer);

	//g_pDevice->
	//D3DSURFACE_DESC desc;

	// Store orginal Render Target //
	//g_pDevice->GetRenderTarget(0, &pRenderSurface);
	//D3DSURFACE_DESC desc;
	//pRenderSurface->GetDesc( &desc );



	
	//
	// Get Offset and Starting Positions //
	//


	srect.left = 0;
	srect.top = 0;
	srect.right = mainViewPort.Width;
	srect.bottom = mainViewPort.Height;

	drect.left = 0;
	drect.top = 0;
	drect.right = mainViewPort.Width;
	drect.bottom = mainViewPort.Height;

	
	// Position and aim the camera //
	D3DXMATRIX V;
	if(!g_pCameraMode) 
	{
		D3DXMatrixLookAtLH(&V, &g_pCamera->_pos, &g_pCamera->_look, &g_pCamera->_up);
		g_pDevice->SetTransform(D3DTS_VIEW, &V);


		M3d_vtx pos;
		M3d_vtx at;
		M3d_vtx up;
		pos[0] = g_pCamera->_pos.x;
		pos[1] = g_pCamera->_pos.y;
		pos[2] = g_pCamera->_pos.z;
		at[0] = g_pCamera->_look.x;
		at[1] = g_pCamera->_look.y;
		at[2] = g_pCamera->_look.z;
		up[0] = g_pCamera->_up.x;
		up[1] = g_pCamera->_up.y;
		up[2] = g_pCamera->_up.z;

		m_snooker->CameraPosAtUpFovAspect(pos, at, up, g_pCamera->_cameraFov, g_pCamera->_cameraAspect);
	}
	else
	{
		D3DXMatrixLookAtLH(&V, &g_pCameraFree->_pos, &g_pCameraFree->_look, &g_pCameraFree->_up);
		g_pDevice->SetTransform(D3DTS_VIEW, &V);


		M3d_vtx pos;
		M3d_vtx at;
		M3d_vtx up;
		pos[0] = g_pCameraFree->_pos.x;
		pos[1] = g_pCameraFree->_pos.y;
		pos[2] = g_pCameraFree->_pos.z;
		at[0] = g_pCameraFree->_look.x;
		at[1] = g_pCameraFree->_look.y;
		at[2] = g_pCameraFree->_look.z;
		up[0] = g_pCameraFree->_up.x;
		up[1] = g_pCameraFree->_up.y;
		up[2] = g_pCameraFree->_up.z;

		m_snooker->CameraPosAtUpFovAspect(pos, at, up, g_pCameraFree->_cameraFov, g_pCameraFree->_cameraAspect);

	}

    //
    // Render to the Main viewport
    //

	D3DXMATRIX matView;
    D3DXMATRIX matWorld;
    D3DXMATRIX matRotation;
    D3DXMATRIX matTranslation;

    g_pDevice->SetViewport( &mainViewPort );

	// Get a copy of our current backbuffer //
	
	//fIDirect3DSurface9* pRenderSurface = NULL;
	//D3DSURFACE_DESC desc;
	//g_pDevice->GetDesc(desc);
	//g_pDevice->GetRenderTarget(0, &m_pBGSurf);
	//g_pDevice->CreateOffscreenPlainSurface(desc.Width, desc.Height, desc.Format, D3DPOOL_SYSTEMMEM, &pRenderSurface);
	


	// Check if our camear is moving //
	bool camera_moving = false;
	if(	g_pCameraFree->_rotaxisv[0] > 0.0001f || g_pCameraFree->_rotaxisv[0] < -0.0001f ||
		g_pCameraFree->_rotaxisv[1] > 0.0001f || g_pCameraFree->_rotaxisv[1] < -0.0001f ||
		g_pCameraFree->_distancev > 0.0001f || g_pCameraFree->_distancev < -0.0001f)
	{
		camera_moving = true;
	}

	// Check if we need to update our Background Sufrace

	//if(!m_bMButtonDown)

	
	if(camera_moving || m_bOnSizeDrawTmpSurf || m_snooker->m_bRedrawChalkMarks || m_bUpdateTable)
	{
		g_pDevice->SetRenderTarget(0, m_pBGSurf);


		g_pDevice->SetViewport( &mainViewPort );


		// Now we can clear just view-port's portion of the buffer to red...
		g_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
							 D3DCOLOR_COLORVALUE( 0.133f, 0.118f, 0.098f, 1.0f ), 1.0f, 0L );

		// if(g_gameAppView) ErrorMessage(g_gameAppView, "Refresh 3D");

		g_pDevice->BeginScene();
		
		
		g_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, true);

		if(g_pCameraMode || m_snooker->m_CameraMode != CAMERA_MODE_PLAYER_2D)
		{
			Render3DScene();
			Render3DSnookerTable();
		}
		else
		{
			Render3DSnookerTable();
		}

		m_bOnSizeDrawTmpSurf = FALSE;
		m_snooker->m_bRedrawChalkMarks = FALSE;
		m_bUpdateTable = FALSE;

		g_pDevice->EndScene();
	}

		 


	// Use m_pBGSurf as our new background for the rendering surface 'pRenderSurface' //
	//g_pDevice->

	
	hr = g_pDevice->SetRenderTarget(0, pRenderSurface);

	g_pDevice->SetViewport( &mainViewPort );
	
    // Now we can clear just view-port's portion of the buffer to red...
    g_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
                         D3DCOLOR_COLORVALUE( 0.133f, 0.118f, 0.098f, 1.0f ), 1.0f, 0L );

	//if(!m_bMButtonDown)
	//{
		
	//}


	
	
	

    g_pDevice->BeginScene();
 
	hr = g_pDevice->StretchRect(m_pBGSurf, NULL, pRenderSurface, NULL, D3DTEXF_NONE);


	
	

	
	// 2D Mode, so no point in rendering the Scene (just makes the game run slower //
	if(g_pCameraMode || m_snooker->m_CameraMode != CAMERA_MODE_PLAYER_2D)
	{
		Render3DSnookerTable();
	}
	


	g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
	// Not being used currently
	// Render3DAdverts();
	

	g_pDevice->SetRenderState(D3DRS_ZENABLE, true);
	//g_pDevice->SetRenderState(D3DRS_ZWRITEENABLE, true);

	//Render3DSnookerTable();

	g_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, true);

	Render3DOverLayTable();

	// Note lights are enabled again, in above function
	Render3DBalls();

	g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
	
	g_pDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
	//g_pDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	Render3DWhiteTouchingBalls();
	



	//g_pDevice->SetRenderState(D3DRS_LIGHTING, true);
	//g_pDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
	//Render3DGhostBall();
	//Render3DWhiteTouchingBalls();
	//g_pDevice->SetRenderState(D3DRS_ZENABLE, TRUE);


	// 3D Rendering of Cue, Sightlines, Ghost Ball
	if(m_snooker->m_sightlineFade || m_snooker->m_cueStrikeTime)
	{
		g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
		Render3DWhiteSightLine();			// 0.03MClks (when white line on) - sometimes fluctuates to 0.10MClks
		Render3DObjectSightLine();
		g_pDevice->SetRenderState(D3DRS_LIGHTING, true);
		Render3DCue(timeDelta);				// 0.8MClks (when cue on)
		if(g_gfxDetails.bOptionsDrawGhostCueBall) Render3DGhostBall();
	}

	if(m_snooker->m_bCueState)
	{
		m_snooker->m_sightlineFade = 60;
	}
		




	/// No lighting is rqeuired for the following..
	g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
	



	if(g_build.gameType == GAMETYPE_POOL)
	{
		Render3DOverLayTargetBall();
	}

	// Render these things last (so disable the Z-Buffer //
	g_pDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
	
	

	if(g_build.gameType == GAMETYPE_POOL)
	{
		Render3DOverLayTargetPocket();
	}







	// Set up 2D Projection for Main 3D ViewPort (Radio 2:1), so we'll use 1600 x 800 resolution for 2D //
	M3d_transformview2d();

	
	Render2DOverLayPower();
	Render2DOverLaySeating();
	
	
	Render2DNextBall();
	
	

	Render2DSitButtons();
	Render2DCameraButtons();
	Render2DTableHint();
	
	Render2DAdvertsLinks();
	Render2DTurn();
	
	//Render3DOverLaySponsor();

	m_cueChanger->Render();
	m_fineTuner->Render();
	m_chalkChanger->Render();

	

	//M3d_transformview3d();
	g_pDevice->SetTransform(D3DTS_VIEW, &V);
	g_pDevice->SetTransform(D3DTS_PROJECTION, &proj);




	if(!g_pCameraMode) Render3DOverLayHelper();



	Render2DText(timeDelta); //fps

		


	g_pDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
	g_pDevice->SetRenderState(D3DRS_LIGHTING, true);

	

	g_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, false);



 
	g_pDevice->EndScene();


	
	


	//g_pDevice->Present( srect, drect, g_hwnd, NULL);
	
	hr = g_pDevice->Present( srect, drect, g_hwndDX, NULL);
	
	char buf[256];
	if( FAILED(hr) )
	{
		switch(hr)
		{
			case D3DERR_NOTFOUND: sprintf(buf, "Reset() - FAILED [D3DERR_NOTFOUND]");
				break;
			case D3DERR_MOREDATA: sprintf(buf, "Reset() - FAILED [D3DERR_MOREDATA]");
				break;
			case D3DERR_DEVICELOST: sprintf(buf, "Reset() - FAILED [D3DERR_DEVICELOST]");
				break;
			case D3DERR_DEVICENOTRESET: sprintf(buf, "Reset() - FAILED [D3DERR_DEVICENOTRESET]");
				break;
			case D3DERR_NOTAVAILABLE: sprintf(buf, "Reset() - FAILED [D3DERR_NOTAVAILABLE]");
				break;
			case D3DERR_OUTOFVIDEOMEMORY: sprintf(buf, "Reset() - FAILED [D3DERR_OUTOFVIDEOMEMORY]");
				break;
			case D3DERR_INVALIDDEVICE: sprintf(buf, "Reset() - FAILED [D3DERR_INVALIDDEVICE]");
				break;
			case D3DERR_INVALIDCALL: sprintf(buf, "Reset() - FAILED [D3DERR_INVALIDCALL]");
				break;
			case D3DERR_DRIVERINVALIDCALL: sprintf(buf, "Reset() - FAILED [D3DERR_DRIVERINVALIDCALL]");
				break;
			case D3DERR_WASSTILLDRAWING: sprintf(buf, "Reset() - FAILED [D3DERR_WASSTILLDRAWING]");
				break;
			case D3DOK_NOAUTOGEN: sprintf(buf, "Reset() - FAILED [D3DOK_NOAUTOGEN]");
				break;
			case D3DERR_WRONGTEXTUREFORMAT: sprintf(buf, "Reset() - FAILED [D3DERR_WRONGTEXTUREFORMAT]");
				break;
			case D3DERR_UNSUPPORTEDCOLOROPERATION: sprintf(buf, "Reset() - FAILED [D3DERR_UNSUPPORTEDCOLOROPERATION]");
				break;
			case D3DERR_UNSUPPORTEDCOLORARG: sprintf(buf, "Reset() - FAILED [D3DERR_UNSUPPORTEDCOLORARG]");
				break;
			case D3DERR_UNSUPPORTEDALPHAOPERATION: sprintf(buf, "Reset() - FAILED [D3DERR_UNSUPPORTEDALPHAOPERATION]");
				break;
			case D3DERR_UNSUPPORTEDALPHAARG: sprintf(buf, "Reset() - FAILED [D3DERR_UNSUPPORTEDALPHAARG]");
				break;
			case D3DERR_TOOMANYOPERATIONS: sprintf(buf, "Reset() - FAILED [D3DERR_TOOMANYOPERATIONS]");
				break;
			case D3DERR_CONFLICTINGTEXTUREFILTER: sprintf(buf, "Reset() - FAILED [D3DERR_CONFLICTINGTEXTUREFILTER]");
				break;
			case D3DERR_UNSUPPORTEDFACTORVALUE: sprintf(buf, "Reset() - FAILED [D3DERR_UNSUPPORTEDFACTORVALUE]");
				break;
			case D3DERR_CONFLICTINGRENDERSTATE: sprintf(buf, "Reset() - FAILED [D3DERR_CONFLICTINGRENDERSTATE]");
				break;
			case D3DERR_UNSUPPORTEDTEXTUREFILTER: sprintf(buf, "Reset() - FAILED [D3DERR_UNSUPPORTEDTEXTUREFILTER]");
				break;
			case D3DERR_CONFLICTINGTEXTUREPALETTE: sprintf(buf, "Reset() - FAILED [D3DERR_CONFLICTINGTEXTUREPALETTE]");
				break;
			case D3DERR_DRIVERINTERNALERROR: sprintf(buf, "Reset() - FAILED [D3DERR_DRIVERINTERNALERROR]");
				break;

			default: 
				sprintf(buf, "Reset() - FAILED []");
				break;

		}

		do
		{
			hr = g_pDevice->TestCooperativeLevel();
			if(FAILED(hr))
			{
				switch(hr)
				{
					case D3DERR_NOTFOUND: sprintf(buf, "Reset() - FAILED [D3DERR_NOTFOUND]");
						break;
					case D3DERR_MOREDATA: sprintf(buf, "Reset() - FAILED [D3DERR_MOREDATA]");
						break;
					case D3DERR_DEVICELOST: sprintf(buf, "Reset() - FAILED [D3DERR_DEVICELOST]");
						break;
					case D3DERR_DEVICENOTRESET: 
						sprintf(buf, "Reset() - FAILED [D3DERR_DEVICENOTRESET]");
						this->ResetDevice();
						this->InitDevice(false);

						/* Set up our Environment Lighting again 
						 *
						 */
						if(g_build.gameType == GAMETYPE_POOL)
						{
							// Setup iPool Lighting Position
							m_environment->LightPos(0,-1250,0,600);
							m_environment->LightPos(1,0,0,600);
							m_environment->LightPos(2,+1250,0,600);	
						}
						else
						{
							// Setup iSnooker Lighting Position
							m_environment->LightPos(0,-1600,0,800);
							m_environment->LightPos(1,0,0,800);
							m_environment->LightPos(2,+1600,0,800);	
						}

						m_bUpdateTable = true;

						break;
					case D3DERR_NOTAVAILABLE: sprintf(buf, "Reset() - FAILED [D3DERR_NOTAVAILABLE]");
						break;
					case D3DERR_OUTOFVIDEOMEMORY: sprintf(buf, "Reset() - FAILED [D3DERR_OUTOFVIDEOMEMORY]");
						break;
					case D3DERR_INVALIDDEVICE: sprintf(buf, "Reset() - FAILED [D3DERR_INVALIDDEVICE]");
						break;
					case D3DERR_INVALIDCALL: sprintf(buf, "Reset() - FAILED [D3DERR_INVALIDCALL]");
						break;
		
				}
			}
		} while (hr < 0);

		


	}
	else
	{
			//sprintf(buf, "Reset() - OK []");
	}

	// ::MessageBox(0, buf, 0, 0);
	


#endif

}





void CGameAppView::Render3DMiniCam(float timeDelta)
{
	
#ifndef MAIN_SERVER



	if (g_pDevice == NULL) return;

	
	// Only do following Code if Show Shot In MiniCam is Disabled //
	if(!g_gfxDetails.bOptionsShowMiniCam)
	{
		static int lready = 0;
		static int rready = 0;
		bool redraw = false;


		if(m_bLButtonDown) lready = 1;
		else if(lready == 1) redraw = true, lready = 0;
		
		if(m_bRButtonDown) rready = 1;
		else if(rready == 1) redraw = true, rready = 0;
		

		//if(m_snooker->m_cueBallSelect == 5) redraw = true;
		if(m_snooker->m_cueBallSelect != 2) redraw = true;
		
		//if(m_snooker->m_testBall->m_colour == WHITE) return;
		//if(m_snooker->m_ball[m_snooker->m_selectBall]->m_colour != WHITE) redraw = true;


		//old_cbs = m_snooker->m_cueBallSelect;


		if(m_bOnSizeDrawTmpSurf || m_snooker->m_bRedrawChalkMarks || m_bUpdateTable || redraw);
		else return;

		


		/*
		if(m_bOnSizeDrawTmpSurf || m_snooker->m_bRedrawChalkMarks || m_bUpdateTable); // If it's time to update do mini cam
		else if(redraw);		// If mouse buttons are just up, display mini cam
		else 
		{
			if(m_snooker->m_cueBallSelect != 5) return;
		}

		if(redraw) redraw = 0;
		*/
	}


	
	if(m_bMButtonDown) return;	// Don't Process Mini Cam when we're changin view // (quicker)
	
	if(g_gfxDetails.bOptionsShowMiniCam == false)
	{
		if(m_snooker->m_cueBallSelect == 2) return;
	}

	// draw HUD GFX
	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	float fX = (float)(m_cx) / 1182;
	float fY = (float)(m_cx)*0.5f / 1182;
	
	GetWindowRect(&m_origin);

	CRect clientrect;
	::GetWindowRect(g_hwndDX, clientrect);
	int ypos_start = clientrect.Height()+2;

	int chat_height = (int)m_cy - ypos_start;


	//int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view
	int squareHeight = chat_height+1;

	m_miniCamHeight = squareHeight;

	/*
	CRect rect;
	
	rect.top = 0; // not required here!
	rect.right = 200+squareHeight; //400-13-offsetX;
	rect.left = 200; //rect.right - squareHeight;
	rect.bottom = 0; // not required here!
	
	CSize size = rect.Size();
	*/



	CRect srect;
	CRect drect;
	GetWindowRect(clientrect);

	D3DXMATRIX matView;
    D3DXMATRIX matWorld;
    D3DXMATRIX matRotation;
    D3DXMATRIX matTranslation;

	//	Set render target to Mini Camera BackBuffer //
	//	HRESULT hr = g_pDevice->SetRenderTarget( 0, pRenderSurface);//MiniCam );
	HRESULT hr = g_pDevice->SetRenderTarget( 0, pRenderSurfaceMiniCam );
	
	/*
    //
    // Render to the Mini-Cam viewport
    //
    D3DVIEWPORT9 minicamViewPort;


	int length = 128;
    if(g_gfxDetails.bOptionsLowgfx) length = 192;
	else if(g_gfxDetails.bOptionsMediumgfx) length = 384;
	else if(g_gfxDetails.bOptionsHighgfx) length = 384;

    minicamViewPort.X      = 0;
    minicamViewPort.Y      = 0;
	minicamViewPort.Width  = length;//g_dwMainViewWidth;
    minicamViewPort.Height = length;//g_dwMainViewHeight;
    minicamViewPort.MinZ   = 0.0f;
    minicamViewPort.MaxZ   = 1.0f;

	g_pDevice->SetViewport( &minicamViewPort );
	*/
	float aspect = 1.0f;




	D3DXMATRIX proj;
	D3DXMatrixPerspectiveFovLH(
			&proj,
			1.570795f/4.0f,
			aspect,
			10.0f,
			10000.0f);
	g_pDevice->SetTransform(D3DTS_PROJECTION, &proj);

	// Make sure our Camera knows what FOV and Aspect Ratio we are using //
	g_pCameraMiniCam->_cameraFov = 1.570795f/4.0f;
	g_pCameraMiniCam->_cameraAspect = aspect;



	// get new AT & POS from CSnooker
	g_pCameraMiniCam->_look.x = m_snooker->m_miniCameraAt[0];
	g_pCameraMiniCam->_look.y = m_snooker->m_miniCameraAt[1];
	g_pCameraMiniCam->_look.z = m_snooker->m_miniCameraAt[2];

	g_pCameraMiniCam->_pos.x = m_snooker->m_miniCameraPos[0];
	g_pCameraMiniCam->_pos.y = m_snooker->m_miniCameraPos[1];
	g_pCameraMiniCam->_pos.z = m_snooker->m_miniCameraPos[2];

	g_pCameraMiniCam->_up = D3DXVECTOR3(0.0f, 0.0f, 1.0f);


	// Position and aim the camera //
	D3DXMATRIX V;
	D3DXMatrixLookAtLH(&V, &g_pCameraMiniCam->_pos, &g_pCameraMiniCam->_look, &g_pCameraMiniCam->_up);
	g_pDevice->SetTransform(D3DTS_VIEW, &V);



    // Now we can clear just view-port's portion of the buffer to green...
    g_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
                         D3DCOLOR_COLORVALUE( 0.24f, 0.16f, 0.11f, 1.0f ), 1.0f, 0 );

    g_pDevice->BeginScene();
    
    Render3DSnookerTable();


	g_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
	Render3DBalls(false);
	g_pDevice->SetRenderState(D3DRS_LIGHTING, true);
	Render3DCueTip();
	

	
	//g_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, false);


	



	g_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, true);

	/// No lighting is rqeuired for the following..
	g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
	// Render these things last (so disable the Z-Buffer //
	g_pDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
	



	// Set up 2D Projection for Main 3D ViewPort (Radio 2:1), so we'll use 1600 x 800 resolution for 2D //
	// M3d_transformview2d();
	
	D3DXMATRIX Ortho2D;	
	D3DXMATRIX Identity;
	
	D3DXMatrixOrthoLH(&Ortho2D, 800, 800, 0.0f, 1.0f);
	D3DXMatrixIdentity(&Identity);

	g_pDevice->SetTransform(D3DTS_PROJECTION, &Ortho2D);
	g_pDevice->SetTransform(D3DTS_WORLD, &Identity);
	g_pDevice->SetTransform(D3DTS_VIEW, &Identity);
	
	
	//Render3DOverLayPower();
	//Render3DOverLaySeating();
	//Render3DOverlayMiniCam();

	// g_pDevice->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, TRUE);
	// g_pDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	// g_pDevice->SetRenderState(D3DRS_EDGEANTIALIAS, TRUE);

	g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
	Render3DOverLayHelperMini();
	//Render3DOverLaySponsor();



	// Make sure our Transforms & Rendering States are back to Normal //

	//M3d_transformview3d();
	g_pDevice->SetTransform(D3DTS_VIEW, &V);
	g_pDevice->SetTransform(D3DTS_PROJECTION, &proj);

	//Render3DOverLayHelper();

	g_pDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
	// g_pDevice->SetRenderState(D3DRS_LIGHTING, true);
	g_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, false);

	g_pDevice->SetRenderState(D3DRS_LIGHTING, true);


    
    g_pDevice->EndScene();

  

	// Display the Mini Cam //

	/*
	srect.left = minicamViewPort.X;
	srect.top = minicamViewPort.Y;
	srect.right = minicamViewPort.X+minicamViewPort.Width;
	srect.bottom = minicamViewPort.Y+minicamViewPort.Height;
	*/

	drect.left = 163;
	drect.top = ypos_start+2;
	drect.right = 163+squareHeight;
	drect.bottom = ypos_start+squareHeight+2;



	// g_pDevice->Present( srect, drect, g_hwnd, NULL );
	hr = g_pSwapChain->Present( NULL, drect, g_hwnd, NULL, NULL);

/*
	if(g_gfxDetails.bOptionsShowMiniCam)
	{
		g_pSwapChain->Present( srect, drect, g_hwnd, NULL, NULL);
		//g_pDevice->Present( srect, drect, g_hwnd, NULL );
	}
	else
	{	


		if(MiniCamDC)
		{

			D3DXIMAGE_INFO info;
			LPDIRECT3DSURFACE9 surface = NULL;
						


			// Get the surface discription 
			D3DSURFACE_DESC surfaceDesc;
			pRenderSurfaceMiniCam->GetDesc(&surfaceDesc);
			
			// Get point to the surface pixel data 
			D3DLOCKED_RECT lockedRect;
			pRenderSurfaceMiniCam->LockRect(&lockedRect, 0, 0);

			
			DWORD * imageData = (DWORD*)lockedRect.pBits;
			DWORD lpBits[65536];

			CBitmap tbitmap;
			tbitmap.DeleteObject();
			
			BOOL ret = tbitmap.CreateBitmap(256, 256, 1, 32, imageData);
			MiniCamDC.SelectObject(tbitmap);
			//MiniCamDC.FillRect(CRect(0,0,255,255), &CBrush(RGB(255,0,0)));
			
				
			pRenderSurfaceMiniCam->UnlockRect();
		}
	}
*/

#endif 
}



void CGameAppView::Render2DText(float timeDelta) 
{

	
	
	// CalcFPS //
	FrameCnt++;
	
	TimeElapsed += timeDelta;

	if(TimeElapsed > 1.0f)
	{
		FPS = (float)FrameCnt / TimeElapsed;
		TimeElapsed = 0.0f;
		FrameCnt = 0;
	}

	// We need to know our FPS still, even if we don't show it //
	if(!g_gfxDetails.bFrameRateDisplay) return;
	
	
	RECT r1;
	r1.left = 0;
	r1.top = 40;
	r1.right = 200;
	r1.bottom = 80;
	char buf[256];
	sprintf(buf, "%.1f fps", FPS);
	// sprintf(buf, "FrameCnt frames: %d", FrameCnt);
	g_pFont->DrawText(NULL, buf, strlen(buf), &r1, 0, 0xFFFFFFFF);

}
	
int red = 0;

void CGameAppView::Draw3D(float timeDelta) // About 13MClks in 3D Mode (does fluctuate quite a bit though)
{
	

	g_fSpinX += 0.6f;
	g_fSpinY += 0.97f;

	// Don't Render Mini Cam is Game has not started //
	// If the game hasn't started, show the Camera in Demo Mode //
	bool bRender3DMiniCam = false;

	if(m_snooker->m_bPracticeMode || m_bPlayOffline) bRender3DMiniCam = true;
	else
	{
		int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
		if(tblIdx != -1)
		{
			if(m_table[tblIdx].bGameStarted) bRender3DMiniCam = true;
		}
	}

	//if(m_bOnSizeDrawTmpSurf || m_snooker->m_bRedrawChalkMarks || m_bUpdateTable) bRender3DMiniCam = true;


	//if(bRender3DMiniCam) 
	
	

	// If Show Shot In Mini Cam is on, then Render3D Mini Cam Always //
	// g_pDevice->BeginScene();
	
	Render3DMiniCam(timeDelta);
	Render3D(timeDelta);

	

	// g_pDevice->EndScene();

} 



void CGameAppView::Render2DClockProbe(void)
{
/*
		//Tools to use!
		//Mmain_probe();
		//g_clkprobe[0] = Mmain_probe();

		// Better as allows nested probing! due to push/pop nature!
		//Mmain_probestart();
		//g_clkprobe[6] = Mmain_probestop();

		int n;
		int v;
		int offx,offy;


		offx = m_cx/2; //m_origin.left + m_origin.right/2 - 48 
		offy = 0; //m_origin.top
		


		for(n=0;n<7;n++)
		if(g_clkprobe[n]!=-1) break;
		else
		{
		if(n==6) return; // nothing on in here! ignore 7 - as it's a special one to gauge itself!
		}
		
		Mmain_probestart();
		//Mmain_probe();

		Mgfx_fillrect(offx + 64, offy+4, 1,8+7*12, Mgfx_rgbcolor(255,255,255));
		Mgfx_fillrect(offx + 128, offy+4, 1,8+7*12, Mgfx_rgbcolor(255,255,255));
		Mgfx_fillrect(offx + 192, offy+4, 1,8+7*12, Mgfx_rgbcolor(255,255,255));

		for(n=0;n<8;n++)
		if(g_clkprobe[n]!=-1)
		{
		if(g_clkprobeavg[n]!=-1)
			{
			g_clkprobeavg[n]*=0.95;
			g_clkprobeavg[n]+=g_clkprobe[n]*0.05;//1;
			}
		else g_clkprobeavg[n]=g_clkprobe[n];
		

		#ifdef	CLKPROBE_TEXT
		sprintf(buffer,"(%f)", ((float) g_clkprobe[n])*0.000001);
		Mgfx_gditext(offx - 80, offy+n*12, buffer, Mgfx_idx);
		#endif

		#ifdef	CLKPROBE_BAR

		v = g_clkprobeavg[n]>>17; // /=131072 gives 8 pixels per MClk (i.e. 8*32 = 256)
		if(v<0) v = 0;
		else if(v>256) v = 256;

		// Amount
		Mgfx_fillrect(offx, offy+n*12+6, v,4, Mgfx_rgbcolor(255,255,128));
		// Background
		if(n==7) Mgfx_fillrect(offx + v, offy+n*12+6, 256-v,4, Mgfx_rgbcolor(0,0,255));
		else Mgfx_fillrect(offx + v, offy+n*12+6, 256-v,4, Mgfx_rgbcolor(255,0,0));
		//Mgfx_gditext(m_origin.left + m_origin.right/2 - 48, m_origin.top+n*12, buffer, Mgfx_idx);

		// Average Bar overlay
		v = g_clkprobe[n]>>17;
		if(v<0) v = 0;
		else if(v>256) v = 256;

		Mgfx_fillrect(offx + v, offy+n*12+4, 1,8, Mgfx_rgbcolor(0,0,0));

		#endif
				
		g_clkprobe[n]=-1;
		}

		g_clkprobe[7] = Mmain_probestop();

		Mmain_proberefund(g_clkprobe[7]); // give back the amount of clks that this took up

*/
}

void CGameAppView::DrawMini3D(void) // 10MClks aswell!!!
{
/*
	#ifndef MAIN_SERVER

	// show mini-cam? 
	if(!g_gfxDetails.bOptionsShowMiniCam) // note: this option is now inverted i.e. 0=1 & 1=0
	{		   
		if(m_snooker->m_cueBallSelect == 2) // during simulation
		return;
	}

	//if(g_gameAppView) ErrorMessage(g_gameAppView, "DrawMini3D");


/////// Set the Cue Type /////////

		
	/////// Set the Cue Type /////////
	int plr1Idx = -1;
	int plr2Idx = -1;


	int tbl = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	if(tbl!=-1)
		{
		plr1Idx = m_lobby->GetPlayerIdx(m_table[tbl].player1SockIdx);
		plr2Idx = m_lobby->GetPlayerIdx(m_table[tbl].player2SockIdx);
		}	


	// Set the Cue to it's Default Normal Type, just incase //
	m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];

	if(m_snooker->m_bTurn1P) 
		{
		if(plr1Idx==-1) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
		else if(m_player[plr1Idx].bIsGuest) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
		else{
			if(m_player[plr1Idx].cuetype==2) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[1];
			else if(m_player[plr1Idx].cuetype==4) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[2];
			else if(m_player[plr1Idx].cuetype==8) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[3];
			else if(m_player[plr1Idx].cuetype==16) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[4];
			else if(m_player[plr1Idx].cuetype==32) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[5];
			else if(m_player[plr1Idx].cuetype==64) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[6];
			else if(m_player[plr1Idx].cuetype==128) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[7];
			else m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
			}
		}
	else 
		{
		if(plr2Idx==-1) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
		else if(m_player[plr2Idx].bIsGuest) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
		else{
			if(m_player[plr2Idx].cuetype==2) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[1];
			else if(m_player[plr2Idx].cuetype==4) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[2];
			else if(m_player[plr2Idx].cuetype==8) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[3];
			else if(m_player[plr2Idx].cuetype==16) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[4];
			else if(m_player[plr2Idx].cuetype==32) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[5];
			else if(m_player[plr2Idx].cuetype==64) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[6];
			else if(m_player[plr2Idx].cuetype==128) m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[7];
			else m_snooker->m_M3d_Cue_ptr = &m_M3d_Cue[0];
			}
			
		}


	/////////////////
	
	//if(!g_active) return;
	int x, y;
	int n;
	BOOL StrikeWhiteBall;
	// --------------- //

	// draw HUD GFX
	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	float fX = (float)(m_cx) / 1182;
	float fY = (float)(m_cx)*0.5f / 1182;
	
	GetWindowRect(&m_origin);

	int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view

	CRect rect;
	
	rect.top = 0; // not required here!
	rect.right = 400-13-offsetX;
	rect.left = rect.right - squareHeight;
	rect.bottom = 0; // not required here!
	
	CSize size = rect.Size();
	M3d_viewport(0,0,size.cx, size.cx, 0, 1);

	rect.left = rect.right - squareHeight;
	rect.top = (int)(2 + 32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset);
	rect.right = squareHeight; // width value
	rect.bottom = squareHeight; // height value

	// clip height correction (so we get our square region)
	int bottomCorrection = m_origin.bottom;
	int width = (m_origin.left+(rect.left+rect.right)) - (m_origin.left+rect.left);
	int height = m_origin.bottom - (m_origin.top+rect.top);
	if(height > width) bottomCorrection = m_origin.top+rect.top + width;
				
	Mgfx_clip(m_origin.left, m_origin.top+rect.top, m_origin.left+(rect.left+rect.right) - g_FIX_shiftX - g_FIX_SpareW, bottomCorrection);
				
	M3d_clear(0,0,0);

	// 3D ////////////////////////////////////////////////////////////////
	M3d_camera.near_clip = 10.0f;
	M3d_camera.far_clip = 10000.0f;

	// get new AT & POS from CSnooker
	M3d_camera.at[0] = m_snooker->m_miniCameraAt[0];
	M3d_camera.at[1] = m_snooker->m_miniCameraAt[1];
	M3d_camera.at[2] = m_snooker->m_miniCameraAt[2];

	M3d_camera.pos[0] = m_snooker->m_miniCameraPos[0];
	M3d_camera.pos[1] = m_snooker->m_miniCameraPos[1];
	M3d_camera.pos[2] = m_snooker->m_miniCameraPos[2];

	StrikeWhiteBall = FALSE;
	if(m_snooker->m_ball[m_snooker->m_selectBall]->m_colour == WHITE ) // white ball selected
	{
		StrikeWhiteBall = TRUE;
		
		// 3d Strike Ball camera mode	
		M3d_camera.up[0] = 0;
		M3d_camera.up[1] = 0;
		M3d_camera.up[2] = 1; // Up vector is in direction of Table's Normal for now.
	}
	else
	{
		StrikeWhiteBall = TRUE;
		
		// 3d Strike Ball camera mode	
		M3d_camera.up[0] = 0;
		M3d_camera.up[1] = 0;
		M3d_camera.up[2] = 1; // Up vector is in direction of Table's Normal for now.
	}
	
	M3d_camera.fov = 1.570795f/4.0f;
	//M3d_camera.aspect = 1.0f;//0.75f;  // (480/640) Video Res. (0.75f - 0.225f = 0.525f)
	float f = ((float)m_SizeDesktop.cy / (float)m_SizeDesktop.cx);
	float k = ASPECT_RATIO_MINICAM;//0.525f;
	
	if(g_WideScreenEnabled) k-=0.22f; //0.18f;  // Wide Screen Adjustment //

	M3d_camera.aspect = k * (0.75f/f);//1024.0f / 1280.0f; //0.8f;//0.5f;//1024.0f / 1280.0f;//0.75f;  // (480/640) Video Res. (0.75f - 0.225f = 0.525f)
	M3d_transformview();


	
	M3d_vtx pos;
	M3d_vtx rot;
	M3d_vtx scale;

	pos[0] = 0;
	pos[1] = 0;
	pos[2] = 0;

	rot[0] = 0;
	rot[1] = 0;
	rot[2] = 0;

	scale[0] = 1;
	scale[1] = 1;
	scale[2] = 1;


	Render3DSnookerTable(); // 2.8MClks
	Render3DBalls(FALSE, 0);	// 4.6MClks	

	m_snooker->Draw3D();
	
	m_snooker->m_customTable->m_obstacleCourse->Draw();


	if(m_snooker->m_ballMouseOn || m_snooker->m_bCueTipReadyFirstTime)
	//if(!m_snooker->MyTurn() || m_snooker->m_bCueTipReady)
	if(m_snooker->m_bCueTipReady || m_snooker->m_bCueTipReadyFirstTime)
	//if(m_snooker->m_cueBallSelect != 2)
	if(m_snooker->m_cueBallSelect == 5)
	{
		
		if(g_gfxDetails.bEyeCamDrawCueTip)
		{
			// draw cue tip [BLACK DOT]
			scale[0] = 0.01f;
			scale[1] = 0.01f;
			scale[2] = 0.01f;

			//m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.r = 1*0.1f;
			//m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.g = 0*0.1f;
			//m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.b = 1*0.1f;
			//m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.a = 1;

			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.r = 0;
			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.g = 0;
			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.b = 0;
			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.a = 1;

			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Specular.r = 0;
			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Specular.g = 0;
			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Specular.b = 0;
			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Specular.a = 1;

			pos[0] = m_snooker->m_ballMousePos[0];
			pos[1] = m_snooker->m_ballMousePos[1];
			pos[2] = m_snooker->m_ballMousePos[2];//+36;

			M3d_transformobject(pos, rot, scale); // For still (non keyframes) meshes.
			M3d_objectdraw(m_snooker->m_M3d_Ball_ptr);
		}
		else
		{
			// draw cue tip
			scale[0] = 0.018f;
			scale[1] = 0.018f;
			scale[2] = 0.018f;

			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.r = 0.0f;
			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.g = 0.8f;
			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.b = 0.8f;
			m_snooker->m_M3d_Ball_ptr->mat[0].d3dm.Diffuse.a = 0.2f;
			
			pos[0] = m_snooker->m_ballMousePos[0];
			pos[1] = m_snooker->m_ballMousePos[1];
			pos[2] = m_snooker->m_ballMousePos[2];// - BALL_RADIUS*0.15f;//+36;

			// [always draw the cuetip]
			M3d_transformobject(pos, rot, scale); // For still (non keyframes) meshes.
			M3d_objectdraw(m_snooker->m_M3d_Ball_ptr);
		}
		//////////////////////

		// draw snooker cue (for mini-cam.)
		scale[0] = 1.0f;
		scale[1] = 1.0f;
		scale[2] = 1.0f;
		
		M3d_vtx vec;
		vec[0] = M3d_camera.at[0] - M3d_camera.pos[0];
		vec[1] = M3d_camera.at[1] - M3d_camera.pos[1];
		float angle2D = atan2((double)vec[1], (double)vec[0]);

//		rot[0] = 0;
//		rot[1] = 0;
//		rot[2] = angle2D - 90.0f*DEG2RAD;

		// cue feather-up offset
		float cueFeather;

		////
		//if(m_snooker->MyTurn())
		//{
		cueFeather =  -	   (BALL_RADIUS*5.2f)*(m_snooker->m_cuePowerPercentage/100.0f) + 
						   ((BALL_RADIUS*5.2f)*(m_snooker->m_cuePowerPercentage/100.0f) * sin(g_seq*0.05*CUE_FEATHER_SPEED));
		// ------------------------- //

		// [1] Translation //
		D3DUtil_SetTranslateMatrix(trans_mtx.d3d_world, pos[0],pos[1],pos[2]);
		g_pDevice->SetTransform(D3DTRANSFORMSTATE_WORLD,&trans_mtx.d3d_world);

		// [2] Rotation //

		D3DVECTOR d3dvect;
		d3dvect.x = 0;
		d3dvect.y = 0;
		d3dvect.z = 1; // Spin on the Z axis
		D3DUtil_SetRotationMatrix(trans_mtx.d3d_world, d3dvect, -(angle2D + 270.0f*DEG2RAD));
		g_pDevice->MultiplyTransform(D3DTRANSFORMSTATE_WORLD,&trans_mtx.d3d_world);


		d3dvect.x = 1; // Spin on the X "Right" Vector.
		d3dvect.y = 0;
		d3dvect.z = 0;
		D3DUtil_SetRotationMatrix(trans_mtx.d3d_world, d3dvect, ((float)m_snooker->m_RaiseButt)* DEG2RAD);
		g_pDevice->MultiplyTransform(D3DTRANSFORMSTATE_WORLD,&trans_mtx.d3d_world);

		
		{
		M3d_vtx pos;
		pos[0] = 0;
		pos[1] = cueFeather;
		pos[2] = 0;
		D3DUtil_SetTranslateMatrix(trans_mtx.d3d_world, pos[0],pos[1],pos[2]);
		g_pDevice->MultiplyTransform(D3DTRANSFORMSTATE_WORLD,&trans_mtx.d3d_world);
		}
		

		// [3] Scaling //
		D3DUtil_SetScaleMatrix(trans_mtx.d3d_world, scale[0], scale[1], scale[2]);
		g_pDevice->MultiplyTransform(D3DTRANSFORMSTATE_WORLD,&trans_mtx.d3d_world);

		if(m_snooker->m_cuePowerPercentage != 0) // if cue_power is not 0%, draw cue		
		if(g_gfxDetails.bEyeCamDrawCueSolid)
		{
			//M3d_transformobject(pos, rot, scale); // For still (non keyframes) meshes.
			g_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE); // Disable Z-Buf.
			M3d_objectdraw(m_snooker->m_M3d_Cue_ptr);
			g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE); // Enable Z-Buf.
		}

		// transparent static cue
		for(n=0;n<m_snooker->m_M3d_Cue_ptr->mesh_n;n++)
		{
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.a = 0.25f;

			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Specular.a = 0.25f;
			
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.a = 0.25f;

			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.a = 0.25f;

			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Power = D3D_MATERIAL_POWER;//10;
		}


		// ------------------------- //

		// [1] Translation //
		D3DUtil_SetTranslateMatrix(trans_mtx.d3d_world, pos[0],pos[1],pos[2]);
		g_pDevice->SetTransform(D3DTRANSFORMSTATE_WORLD,&trans_mtx.d3d_world);

		// [2] Rotation //


		d3dvect.x = 0;
		d3dvect.y = 0;
		d3dvect.z = 1; // Spin on the Z axis
		D3DUtil_SetRotationMatrix(trans_mtx.d3d_world, d3dvect, -(angle2D + 270.0f*DEG2RAD));
		g_pDevice->MultiplyTransform(D3DTRANSFORMSTATE_WORLD,&trans_mtx.d3d_world);


		d3dvect.x = 1; // Spin on the X "Right" Vector.
		d3dvect.y = 0;
		d3dvect.z = 0;
		D3DUtil_SetRotationMatrix(trans_mtx.d3d_world, d3dvect, ((float)m_snooker->m_RaiseButt ) * DEG2RAD);
		g_pDevice->MultiplyTransform(D3DTRANSFORMSTATE_WORLD,&trans_mtx.d3d_world);

		// [3] Scaling //
		D3DUtil_SetScaleMatrix(trans_mtx.d3d_world, scale[0], scale[1], scale[2]);
		g_pDevice->MultiplyTransform(D3DTRANSFORMSTATE_WORLD,&trans_mtx.d3d_world);

		if(m_snooker->m_cuePowerPercentage != 0) // if cue_power is not 0%, draw cue
		if(g_gfxDetails.bEyeCamDrawCueSolid || g_gfxDetails.bEyeCamDrawCueTransparent)
		{
			//M3d_transformobject(tmpPos, rot, scale); // For still (non keyframes) meshes.
			g_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE); // Disable Z-Buf.
			M3d_objectdraw(m_snooker->m_M3d_Cue_ptr);
			g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE); // Enable Z-Buf.
		}

		// reset to solid cue
		for(n=0;n<m_snooker->m_M3d_Cue_ptr->mesh_n;n++)
		{
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Diffuse.a = 1.0f;

			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Specular.a = 1.0f;
			
			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Ambient.a = 1.0f;

			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Emissive.a = 1.0f;

			m_snooker->m_M3d_Cue_ptr->mat[n].d3dm.Power = D3D_MATERIAL_POWER;//10;
		}
	}

	//Render3DWhiteTouchingBallsMiniCam();

	// 2D ////////////////////////////////////////////////////////////////
	// render main view

	g_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE);
	M3d_transformview2d();
	Render3DOverLayHelperMini();
	// Render3DOverLay3D2DToggle();
	g_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE);


	// render other useful GFX
	//if(m_snooker->m_bCueState)
	if(m_snooker->MyTurn())
	if(m_snooker->m_cueBallSelect == 5)
	if(squareHeight > 16)
	{
		// draw "Strike Cue Ball" (TEXT)
		Mgfx_push();
		Mgfx_surf(g_spr3dSurface.surf);

		Mgfx_idx = 255;
		
		if(m_snooker->m_ball[m_snooker->m_selectBall]->m_colour == WHITE) sprintf(buffer, "Strike Cue-Ball");
		else sprintf(buffer, "Close-Up");
		//Mgfx_gditext(0,0+squareHeight-16, buffer, Mgfx_idx);
		Mgfx_gditext(0,4, buffer, Mgfx_idx);

		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		int angle;
		if( m_snooker->MyTurn() ) // use slider to control raising butt
		{
			// display angle of cue's butt // degree '' = 248 ASCII value
			angle = 90 - m_sliderRaiseButt.GetPos();
		}		
		else // set slider pos
		{			
			m_sliderRaiseButt.SetPos(90 - m_snooker->m_RaiseButt);
			angle = 90 - m_sliderRaiseButt.GetPos();
		}
				
		sprintf(buffer, "%d", angle);
		Mgfx_gditext(0+squareHeight,0, buffer, Mgfx_idx, MGFX_GDITEXT_RIGHT);
		
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
				
		Mgfx_pop();		
	}

	{
		Mgfx_sprdraw(&g_spr3dSurface, m_origin.left+((400-13-offsetX) - squareHeight) - g_FIX_shiftX - g_FIX_SpareW, m_origin.top+rect.top, squareHeight, squareHeight);// -1, -1);
	}

	#endif //!MAIN_SERVER

	*/
} 





void CGameAppView::Draw2D(float timeDelta)
{

	// draw standard window GDI GFX (double buffering - to eliminate flickering)
	#ifndef MAIN_SERVER
	
	// Get DC for rendering 
	CDC *pDC = NULL;
	pDC = GetDC();

	

	if(pDC)
	{ 

		// do special rendering to backbuffer
		//Draw2DRender(pDC);
	
		// draw standard window GDI GFX (non-double buffering)
		int offsetX = 788 - m_cx; // 800
		int offsetY = 542 - m_cy; // 600
		float fX = (float)(m_cx) / 1182;
		float fY = (float)(m_cx)*0.5f / 1182;
		CPen pen(PS_NULL, 0, RGB(0,0,0));
		CBrush whiteBrush(RGB(236,233,216));


		
		CRect clientrect;
		::GetWindowRect(g_hwndDX, clientrect);
		int ypos_start = clientrect.Height()+2;
		int chat_height = (int)m_cy - ypos_start;

		

		

		//pDC->BitBlt(63, ypos_start, chat_height, chat_height, , 0, 0,  SRCCOPY); 


		//pRenderSurfaceMiniCam->


		// Draw Borders on Right and Left of Table if needed //
		CRect mainrect;
		GetWindowRect(&mainrect);

		int diff = clientrect.left - mainrect.left;
		if( diff > 2)
		{
			CBrush brNew(RGB(30,30,30));  //Creates a blue brush
			CBrush brBorder(RGB(0,0,0));  //Creates a blue brush
			CBrush* pOldBrush;
			
			// Left & Right Rectangle //
			pOldBrush = (CBrush*)pDC->SelectObject(&brNew);
			pDC->Rectangle(0,-1, (diff-2), ypos_start-2);
			pDC->Rectangle(m_cx-2-(diff-2),-1, m_cx, ypos_start-2);
			
			// Left & Right Border //
			//pOldBrush = (CBrush*)pDC->SelectObject(&brBorder);
			//pDC->Rectangle((diff-4),-1, (diff-2), ypos_start-2);
			//pDC->Rectangle(m_cx-4-(diff-2),-1, m_cx-2-(diff-2), ypos_start-2);
			

			pDC->SelectObject(pOldBrush);
		}
		

		
		CBrush brush(RGB(20,20,20));
		
//		#endif
						
		// add some colour to background
		CPen *oldPen = pDC->SelectObject(&pen);
		CBrush *oldBrush = pDC->SelectObject(&brush);
		
		pDC->SelectObject(&brush);
	
		
		// draw mini-cam left border
		int squareHeight = chat_height;//m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height
		pDC->Rectangle(160, ypos_start, 162, ypos_start+squareHeight);

		// draw mini-cam right border
		pDC->Rectangle(161+squareHeight, ypos_start, 164+squareHeight, ypos_start+squareHeight);
		
		// draw mini-cam top border
		//pDC->Rectangle(400-13-offsetX-3 - squareHeight - g_FIX_shiftX - g_FIX_SpareW-2, (int)(32+600-175-52+24+6-ceil(offsetX*0.5f)-2-g_yBarOffset),
		//			   400-13-offsetX-3 - 0			   - g_FIX_shiftX - g_FIX_SpareW+2, (int)(32+600-175-52+24+6-ceil(offsetX*0.5f)+2-g_yBarOffset));

		CRect r1;
		m_sliderRaiseButt.GetClientRect(&r1);

		// draw mini-cam & slider right border
		pDC->Rectangle(163+squareHeight + r1.Width(), (int)(32+600-175-52+24+6-ceil(offsetX*0.5f)-g_yBarOffset),
					   163+squareHeight + r1.Width() + 2, 600-offsetY);
	
		// draw divide line between main view and console below
		pDC->SelectObject(&whiteBrush);
		pDC->Rectangle(0, ypos_start-2,
					   m_cx, ypos_start+1);

		pDC->SelectObject(oldPen);
		pDC->SelectObject(oldBrush);


		// Process 2D Sprites
		

		// release DC - we're finished rendering
		ReleaseDC(pDC);
	}
			
	
/*
	int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);

	// draw seats only (online) [*NEW* CP]
	if( tblIdx != -1) 
	{	
		char NotSeated = 0;

		if(!m_table[tblIdx].doubles)
			{
			if(!m_sit1PButton.m_name[0] || !m_sit2PButton.m_name[0]) NotSeated = 1; // not all seated, so draw seats
			}
		else{
			if(!m_sit1PButton.m_name[0] || !m_sit2PButton.m_name[0] || !m_sit1PButtonB.m_name[0] || !m_sit2PButtonB.m_name[0]) NotSeated = 1; // not all seated, so draw seats
			}
		
		if(NotSeated == 1)
		{
			m_drawSeatsDelay = 0;
		}
		else
		{			
			m_drawSeatsDelay++;
			if(m_drawSeatsDelay>2) m_drawSeatsDelay = 2;
		}

		if(m_drawSeatsDelay < 2) // 2 frames delay
		{
			DrawSeatsOnly(m_cx, m_cy);
		}
	}
*/
	#endif //!MAIN_SERVER

}

void CGameAppView::Draw2DRender(CDC *dc, BOOL bNoDbl)
{

#ifndef MAIN_SERVER

	if(!dc) return;

	m_snooker->m_customTable->Decode();


	CDC *pBkDC = dc; // copy our DC.
	CDC *pDC = dblDC; // switch to mem DC.
	
	if(bNoDbl) pDC = dc;
	
	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	float fX = (float)(m_cx) / 1182;
	float fY = (float)(m_cx)*0.5f / 1182;
	
	float centerX;
	
	if(pDC)
	{
		{
		int offsetX = 788 - m_cx; // 800
		int offsetY = 542 - m_cy; // 600
		float fX = (float)(m_cx) / 1182;
		float fY = (float)(m_cx)*0.5f / 1182;
		CPen pen(PS_NULL, 0, RGB(0,0,0));
		CBrush brush(RGB(20,20,20));
		CBrush borderBrush(RGB(243,246,29));
		CBrush panelBrush(RGB(236,233,216));
		CPen *oldPen = NULL;
		CBrush *oldBrush = NULL;

		// add some colour to background
		oldPen = pDC->SelectObject(&pen);
		oldBrush = pDC->SelectObject(&brush);


		
		if(m_snooker->m_bComputerMode)
		ComputerPracticeOnDraw(pDC, m_cx, m_cy);

		pDC->SelectObject(oldPen);
		pDC->SelectObject(oldBrush);
		}

		//CPen pen(PS_NULL, 0, RGB(0,0,0));
		//CBrush brush(RGB(0,200,00));
		CPen pen(PS_NULL, 0, RGB(0,0,0));
		CBrush brush(RGB(20,20,20));
		CPen *oldPen = NULL;
		CBrush *oldBrush = NULL;

		// add some colour to background
		oldPen = pDC->SelectObject(&pen);
		oldBrush = pDC->SelectObject(&brush);


		//////////////////////////////////////////////////////////////////////////////////////////
		// display "Cue-Error" & "Rated" & "Type:" text
		int offsetX = 788 - m_cx; // 800
		int offsetY = 542 - m_cy; // 600
		int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view
		int excess_w = m_cx - (squareHeight + (72*2 + 19));
		int initial_w = (300+40) + (100+g_FIX_shiftX-40);
		g_FIX_SpareW = excess_w - initial_w;
		if(g_FIX_SpareW < 0) g_FIX_SpareW = 0;

		int x = 1;
		int y = 4;
		int w = 70;
		int h = 20;//30;
		int hoff = 3;
			
		pDC->SetBkMode(OPAQUE);//TRANSPARENT);
		pDC->SetBkColor(RGB(0,0,0));
				
		CBrush blackBrush(RGB(0,0,0));
		CBrush *oldBlackBrush = pDC->SelectObject(&blackBrush);
		
		// cue-error (pro-level) blank rectangle
		CRect r;
		r = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 20 - 4 - g_yBarOffset,
				  (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 56-3 + 1,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 20 - 4 + 16 + 1 - g_yBarOffset);
		pDC->Rectangle(&r);
		pDC->SelectObject(&oldBlackBrush);

		pDC->SetTextColor(RGB(255,255,255));
		CFont *oldFont3 = pDC->SelectObject(&m_checkBoxFont);
		sprintf(buffer, "Pro-Level");//Cue-Error");
		pDC->TextOut((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3, 
					  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 20 - 2 - g_yBarOffset,
					  buffer);

		
		// rated button (blank rectangle)
		r = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 4 + 1 - g_yBarOffset,
				  (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19 + 36 + 1,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 4 + 1 + 16 + 1 - g_yBarOffset);
		pDC->Rectangle(&r);

		sprintf(buffer, "Rated");
		pDC->TextOut((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19, 
					  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 4 + 1 - g_yBarOffset,
					  buffer);

		//if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			// miss-rule button (blank rectangle)
			r = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19 - 20,
					  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 + 20 - 4 + 1 - g_yBarOffset,
					  (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19 + 36 + 1,
					  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 + 20 - 4 + 1 + 16 + 1 - g_yBarOffset);
			pDC->Rectangle(&r);

			if(g_build.gameType == GAMETYPE_SNOOKER) sprintf(buffer, "Miss Rule");
			else sprintf(buffer, " Call Shot");
			pDC->TextOut((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19 - 18, 
						  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 + 20 - 4 + 1 - g_yBarOffset + 2,
						  buffer);
		}

				
		//sprintf(buffer, "Say :");
		//pDC->TextOut(388-offsetX-g_FIX_shiftX-g_FIX_SpareW + 15 + 2, (int)(435-ceil(offsetX*0.5f) + 2), buffer);
		pDC->SelectObject(oldFont3);
		//////////////////////////////////////////////////////////////////////////////////////////

		pDC->SelectObject(oldPen);
		pDC->SelectObject(oldBrush);

		//m_bitmap.Draw(pDC, m_cx*0.5f,100);
		//m_bitmap.DrawScale(pDC, m_cx*0.5f,100,64,64);
							
		//ReleaseDC(pDC);
	}


	if(bNoDbl) goto skip2;

	///////////////////////////////////////////////////////////////////////////
	// now render double buffer GFX to our client window
	pDC = pBkDC;
	if(pDC) // window DC
	{
		CRect rect;
		CSize size;

	
		///////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////
		// render pro-level & rated text regions [& miss-rule region]
		{
			int offsetX = 788 - m_cx; // 800
			int offsetY = 542 - m_cy; // 600
			int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view
			int excess_w = m_cx - (squareHeight + (72*2 + 19));
			int initial_w = (300+40) + (100+g_FIX_shiftX-40);
			g_FIX_SpareW = excess_w - initial_w;
			if(g_FIX_SpareW < 0) g_FIX_SpareW = 0;

			int x = 1;
			int y = 4;
			int w = 70;
			int h = 20;//30;
			int hoff = 3;

			rect = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19,
						 ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 4 + 1 - g_yBarOffset,
						 (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19 + 36,
						 ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 4 + 1 + 16 - g_yBarOffset);
									 
			size = rect.Size();						  
			pDC->BitBlt(rect.left, rect.top, size.cx-2, size.cy, dblDC, rect.left, rect.top, SRCCOPY);//WHITENESS);//

			// miss-rule region
			//if(g_build.gameType == GAMETYPE_SNOOKER)
			{
				rect = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19 - 20,
							 ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 + 20 - 4 + 1 - g_yBarOffset,
							 (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19 + 36,
							 ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 + 20 - 4 + 1 + 16 - g_yBarOffset);
										 
				size = rect.Size();						  
				pDC->BitBlt(rect.left, rect.top, size.cx-2, size.cy, dblDC, rect.left, rect.top, SRCCOPY);//WHITENESS);//
			}
		}

		///////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////
		// render 'blackness' to bottom-left corner region
		int offsetX = 788 - m_cx; // 800
		int offsetY = 542 - m_cy; // 600
		int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view

		rect = CRect(0-2,
					 (int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset),
					 400-13-offsetX-3 - squareHeight - g_FIX_shiftX - g_FIX_SpareW-2,
					 600-offsetY);
		size = rect.Size();

		// exclude buttons, tick boxes & combobox child windows
		CRect r;
		int x, y, w, h, n;
		n = 0;
		w = 70;
		h = 20;//30;
		int hoff = 2;
		for(x=0;x<2;x++)
		for(y=0;y<4;y++)
		{		 
			r = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW,
					  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - g_yBarOffset,
					  (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 72,
					  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 + 20 - g_yBarOffset);
			
			pDC->ExcludeClipRect(&r);

			n++;
			
//			if(g_build.gameType == GAMETYPE_SNOOKER)
//			{
//				if(n == 7) goto endxy;
//			}
//			else if(g_build.gameType == GAMETYPE_POOL)
			{
				if(n == 8)
				{
					y--;
					goto endxy;
				}
			}
		}
		endxy:;
		y++;
		x++;
		

		{
		r = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW - 20,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*(y) + 4 + 18 + 1 - g_yBarOffset,
				  (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW - 20 + 15,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*(y) + 4 + 18 + 1 + 15 - g_yBarOffset);
		}

		pDC->ExcludeClipRect(&r);

		// miss-rule button
		//if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		r = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW - 20,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*(y) + 4 + 18 + 1 - g_yBarOffset + (20+2),
				  (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW - 20 + 15,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*(y) + 4 + 18 + 1 + 15 - g_yBarOffset + (20+2));
		
		pDC->ExcludeClipRect(&r);
		}
						
		// table type combobox
		r = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW - 20 - 133,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*(y) + 4 + 18 + 1 - g_yBarOffset,
				  (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW - 20 - 133 + (96 - 6),
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*(y) + 4 + 18 + 1 + /*96*/24-4 - 2 - g_yBarOffset);

		pDC->ExcludeClipRect(&r);


		{
		int offsetX = 788 - m_cx; // 800
		int offsetY = 542 - m_cy; // 600
		int squareHeight = m_cy - ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f) - g_yBarOffset)); // square height mini 3D camera view
		int excess_w = m_cx - (squareHeight + (72*2 + 19));
		int initial_w = (300+40) + (100+g_FIX_shiftX-40);
		g_FIX_SpareW = excess_w - initial_w;
		if(g_FIX_SpareW < 0) g_FIX_SpareW = 0;

		int x = 1;
		int y = 4;
		int w = 70;
		int h = 20;//30;
		int hoff = 3;

		// cue-error (pro-level) text
		r = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 20 - 4 - g_yBarOffset,
				  (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 56-3,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 20 - 4 + 16 - g_yBarOffset);
		pDC->ExcludeClipRect(&r);
				
		// rated text
		r = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 4 + 1 - g_yBarOffset,
				  (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19 + 36-3,
				  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 - 4 + 1 + 16 - g_yBarOffset);
		pDC->ExcludeClipRect(&r);

		// miss-rule text
		//if(g_build.gameType == GAMETYPE_SNOOKER)
			{
			r = CRect((400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19 - 20,
					  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 + 20 - 4 + 1 - g_yBarOffset,
					  (400-13-offsetX-3 - squareHeight) + (w+5)*x - ((w+5)*2) - g_FIX_shiftX - g_FIX_SpareW + 3 + 19 + 36-3,
					  ((int)(32+600-175-52+24+6-ceil(offsetX*0.5f))) + (h+hoff)*y + 4 - 3 + 20 - 4 + 1 + 16 - g_yBarOffset);
			pDC->ExcludeClipRect(&r);
			}
		}

				
		pDC->BitBlt(rect.left, rect.top, size.cx, size.cy, dblDC, rect.left, rect.top, BLACKNESS);//SRCCOPY);
	}

	skip2:;

	m_snooker->m_customTable->Encode();

	#endif //!MAIN_SERVER
}

void CGameAppView::Draw2DLobby(void)
{	  
	
	// draw standard window GDI GFX (double buffering - to eliminate flickering)
#ifndef MAIN_SERVER
	
	// Get DC for rendering 
	CDC *pDC = NULL;
	pDC = GetDC();
	if(pDC)
	{ 
		
		Draw2DLobbyRender(pDC);

		// Render Sprites
		
		// m_testSprite->Update(pDC);
		// m_testSprite->Process();
		
		m_findMatchCtrl->Update(pDC);
		m_findMatchCtrl->Process();

		m_lobbyButtons->Update(pDC);
		m_lobbyButtons->Process();

		// release DC - we're finished rendering
		ReleaseDC(pDC);
	}
#endif //!MAIN_SERVER
}





void CGameAppView::Draw2DLobbyRender(CDC *pDC)
{	
	
#ifndef MAIN_SERVER
	// Here is Where we Render the Lobby TV //
	// Render Lobby TV //
	// If this is our first time here, then Set up the start-up table position
	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	int widthMixedMode = 4+(70 + 50 + 100 + 100)+::GetSystemMetrics(SM_CXVSCROLL);
	int tv_x, tv_y, tv_w, tv_h;
	CBrush brush_black = RGB(0,0,0);
	tv_x = 0;
	tv_y = 108;
	// tv_w = (float)(m_cx) * 0.33f;
	tv_h = (int)(m_cy-200+offsetY*0.5f-m_tabLobbyCtrlEx.m_cornerPtTabs.y)-100+1-1;

	tv_w = (float)(m_cx) * 0.43f;
	
	// Make sure our Table and Player List has at least 
	if( (m_cx - tv_w) < 620 )
	{
		tv_w = m_cx - 620;
	}

	if(m_bFullMode)
	{
		tv_w = m_cx - 249;
	}



	static char first_time = 1;
	int offset = (tv_w - 200) >> 1;

	if(first_time == 1)
	{
	//first_time = 0;
	m_elCycle = EL_REST | EL_BALLS;
	}


	CBrush brush_lobbytvbg(RGB(29,9,0));		// BG2
	CBrush brush_lobbybg(RGB(59,19,0));		// BG2

	int offY = 0;
	int offX = 2;

	// Only Display TV if we're in the Lobby 

	//CRect tmpRect;
	//m_htmlViewTickerBoard.GetWindowRect(&tmpRect);
	//tv_h = tmpRect.top - tv_y;
	if(m_bLobbyMode == 2)
	{
		if(tv_w > 1300) 
		{
			offX += (tv_w -1300) * 0.5;
			tv_w = 1300;

			// Draw Side borders
			pDC->FillRect(CRect(0, 84+23, offX, tv_h+84+23), &brush_lobbytvbg);
			pDC->FillRect(CRect(offX+1300-2, 84+23, offX+1300+offX, tv_h+84+23), &brush_lobbytvbg);
			
		}

		if(m_lobby->m_bInLobby) DrawLobbyTV(tv_x+offX, tv_y, tv_w, tv_h);
	}

	//m_viewtablesButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

	// Click Here To View Tables Text //
	// When the user clicks on this, it will change the Message-Board to the Table List CTRL //
	
	static int offsetx;
	static float tv_ox, tv_oy;
	static DWORD starting_point = 0; // = GetTickCount();
	

	if(first_time) 
		{
		tv_timer = 0;
		first_time = 0;
		}
		



/*

#ifdef MAIN_SERVER
	//pDC->Rectangle( 0, 0, m_cx, m_cy);
	#else
	// paint top of screen (banner region)
	if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		pDC->SelectObject(&bannerBrushGreen);
		pDC->Rectangle( 0, 0, m_cx + 1, 0);
		pDC->SetTextColor(RGB(210,210,210));
		pDC->SetBkColor(RGB(0,128,0));
	}
	else if(g_build.gameType == GAMETYPE_POOL)
	{
		// extra blue panel for lobby's tab ctrl + setup text colours for GMT time
		pDC->SelectObject(&bannerBrushBlue);
		pDC->Rectangle( 0, 0, m_cx + 1, 0);
		pDC->SetTextColor(RGB(15,15,15));
		pDC->SetBkColor(RGB(0,0,128));
	}
*/
	{ // draw Lobby GMT Time



		CRect tmpRect;
		CSize tmpSize;

	if(g_Menu_Refresh)
		{	
		g_Menu_Refresh = FALSE;
		m_listPlayers.GetWindowRect(&tmpRect);
		tmpSize = tmpRect.Size();




		int xbtnoffset = 160;

		xbtnoffset = -84 + 688-tmpSize.cx+175+4-offsetX-g_FIX_shiftX+40; //270;
		xbtnoffset -= (51+73+76+70);
		if(xbtnoffset > tv_x+tv_w) xbtnoffset = tv_x+tv_w;

		// BackGround (Between 'Change Lobby' & 'Home' Button) //
		pDC->FillRect(CRect(160, 84, xbtnoffset, 84+23), &brush_lobbybg);
		}

		
		m_changelobbyButton.GetWindowRect(&tmpRect);
		
		char buf[256];
		CTime time;
		CString timeStr;
		time = GetServerTime();
		timeStr = time.Format( "%H:%M:%S" );
		sprintf(buf, "%s (GMT)", timeStr.GetBuffer(0));
		//dc->TextOut(tmpRect.right + 10, tmpRect.top+4, buf);

		//dc->SelectObject(
		//pDC->SetBkMode(TRANSPARENT);
		pDC->SetBkColor(RGB(59,19,0));
		pDC->SetTextColor(RGB(255,255,255));
		pDC->TextOut(168, 88, buf);

		/*
		CSize timeSize = pDC->GetTextExtent(timeStr);
		GMTTimeRect.SetRect(0,0,timeSize.cx+2, timeSize.cy);
		GMTTimeRect.OffsetRect(m_tabLobbyCtrlEx.m_tabTotalRect.right+12, 0);

		// render GMT time region
		rect = GMTTimeRect;
		size = rect.Size();
		pDC->BitBlt(rect.left, rect.top, size.cx, size.cy-10, dblDC, rect.left, rect.top, SRCCOPY);
		*/


	}

#endif
/*
	// draw enter lobby button region	
	int tabSelected = m_tabLobbyCtrlEx.GetCurSel();
	if(tabSelected == 4)// [Lobby Select]
	{
		char buff[256];
		CRect tmpRect;
		CSize tmpSize;
		CRect ELRect;
		CSize ELSize;		
		m_listPlayers.GetWindowRect(&tmpRect);
		tmpSize = tmpRect.Size();
		m_EnterLobbyButton.GetWindowRect(&ELRect);
		ELSize = ELRect.Size();
		EnterLobbyRect.SetRect(ELSize.cx,
							   -1+100 + m_tabLobbyCtrlEx.m_cornerPtTabs.y + (int)(m_cy - 330+50 + offsetY*0.5f - m_tabLobbyCtrlEx.m_cornerPtTabs.y-26),
							   m_cx - tmpSize.cx,
							   m_cy - 132 - 48 + offsetY*0.5f);

		pDC->SelectObject(&bannerBrushBlack);
		pDC->Rectangle(EnterLobbyRect);

		pDC->SetTextColor(RGB(15,15,15));
		pDC->SetBkColor(RGB(0,0,0));

		if( m_lobby->GetPlayerIdx(m_playerSockIdx) !=-1 )
		if( m_lobbySelectDlg.m_enterlobby.IsWindowEnabled() )
		{
			if( !m_EnterLobbyButton.IsWindowEnabled() ) m_EnterLobbyButton.EnableWindow(TRUE);
			sprintf(buff, "<- Click Button or Double-Click selection to enter lobby");
		}
			else
		{
			if( m_EnterLobbyButton.IsWindowEnabled() ) m_EnterLobbyButton.EnableWindow(FALSE);
			sprintf(buff, "Select a lobby from the list above");
		}
		
		pDC->TextOut(ELSize.cx+8, 4-1+100 + m_tabLobbyCtrlEx.m_cornerPtTabs.y + (int)(m_cy - 330+50 + offsetY*0.5f - m_tabLobbyCtrlEx.m_cornerPtTabs.y-26), buff);
	}

#endif // MAIN_SERVER

	//////////////////////////////////

#ifdef MAIN_SERVER
		pDC->SelectObject(&brush);
		pDC->Rectangle( 0, 0, m_cx*0.5f, 32);
#endif // MAIN_SERVER
	
	pDC->SetStretchBltMode(HALFTONE);
	pDC->SetBrushOrg(0,0);
*/




	////////////////////////////////////////////////////////////////////
	// display today's highest break in this lobby
#ifndef MAIN_SERVER
	//if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		//int prevBkMode = pDC->SetBkMode(TRANSPARENT);
		CPen pen(PS_NULL, 0, RGB(0,0,0));
		CPen *oldPen = pDC->SelectObject(&pen);
		CString sName;
		CString sBreak;
		pDC->SetTextColor(RGB(20,20,20));
		pDC->SetBkColor(RGB(166,163,158));

		int offset[3];
		offset[0] = 0;
		offset[1] = m_cx-192;
		offset[2] = 0;

		CFont fnt;
		fnt.CreateFont(18, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,   DEFAULT_QUALITY, DEFAULT_PITCH | FF_ROMAN, "Arial Bold");
		CFont* pOldFont = pDC->SelectObject( &fnt );

				
		CFont fnt2;
		fnt2.CreateFont(14, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,   DEFAULT_QUALITY, DEFAULT_PITCH | FF_ROMAN, "Arial");
		pDC->SelectObject( &fnt2 );
		

		// display title & high-break scores - semi-pro (amateur)
		for(int n=0;n<3;n++)
		{

			sName.Format("%d. %s", n+1, m_sLobbyHighBreakName[n]);
			sBreak.Format("%d", m_sLobbyHighBreak[n]);
			TextOutEllipsis(pDC, offset[0] + 20, 16+12*n, sName, 120);
			pDC->TextOut(offset[0] + 20 + 130, 16+12*n, sBreak);			
		}

		// display title & high-break scores - pro
		for(int n=0;n<3;n++)
		{
			sName.Format("%d. %s", n+1, m_sLobbyPHighBreakName[n]);
			sBreak.Format("%d", m_sLobbyPHighBreak[n]);
			TextOutEllipsis(pDC, offset[1] + 20, 16+12*n, sName, 120);
			pDC->TextOut(offset[1] + 20 + 130, 16+12*n, sBreak);
			
		}
		
		/*
		// display title & high-break scores - Billiards
		for(n=0;n<3;n++)
		{
			sName.Format("%d. %s", n+1, m_sLobbyUKHighBreakName[n]);
			sBreak.Format("%d", m_sLobbyUKHighBreak[n]);
			TextOutEllipsis(pDC, offset[2] + 8, 16 + 12*n + m_cy - 132 - 48 + offsetY*0.5f,  sName, 120);
			pDC->TextOut(offset[2] + 8 + (offset[2]-offset[1]-20), 16 + 12*n + m_cy - 132 - 48 + offsetY*0.5f, sBreak);
		}
		*/

		pDC->SelectObject(pOldFont);
		pDC->SelectObject(oldPen);
		//pDC->SetBkMode(prevBkMode);
	}
#endif //MAIN_SERVER

	

	///////////////////////////////////////////////////////////////////////////
	// now render double buffer GFX to our client window
/*
	//pDC = pBkDC;
	if(pDC) // window DC
	{
		CRect rect;
		CSize size;
	
		///////////////////////////////////////////////////////////////////////////

		// render banner region GFX
		#ifndef MAIN_SERVER
		// render debug display region
		g_gfxDetails.bFrameRateDisplay = TRUE;
		if(g_gfxDetails.bFrameRateDisplay)
		{
			//rect = frameRateRect;
			//size = rect.Size();			
			
			char buf[80];
			sprintf(buf, "fps: %d", m_frameRate);
			pDC->TextOut(0, 0, buf);
		}


		#endif //!MAIN_SERVER
	}
*/
}

void CGameAppView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	CView::OnActivateView(bActivate, pActivateView, pDeactiveView);

	g_active = bActivate;
	//m_bUpdateTable = true;


}


// For iSnooker Only //
// To Update Game Type //
void CGameAppView::OnPracticeGameType(char m_gametype) 
{
	#ifndef MAIN_SERVER

	// Set the game type //
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		switch(m_gametype)
			{
			case 0: m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
					break;
			case 1: m_snooker->m_customTable->m_type = CTTYPE_SNOOKER10;
					break;
			case 2: m_snooker->m_customTable->m_type = CTTYPE_SNOOKER6;
					break;
			case 3: m_snooker->m_customTable->m_type = CTTYPE_RESPOTBLACK;
					break;
			case 4: m_snooker->m_customTable->m_type = CTTYPE_BILLIARDS;
					m_snooker->m_customTable->subtype = 0;	// 50 pts Billiards
					break;
					
			}
		}	
	
	m_snooker->Init(RERACK_START);
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
		
	
	#endif //!MAIN_SERVER
}




void CGameAppView::OnPracticeStart() 
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	
	// Set up the start-up table position
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_START);
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_8BALL;
		m_snooker->Init(RERACK_8BALL);		
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh

	//ChangeTitle(" Font Test ");
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
		

	#endif //!MAIN_SERVER
}

void CGameAppView::OnPracticeLineup() 
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here

	
	// Set up the line-up practice drill
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_LINEUP);
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_9BALL;
		m_snooker->Init(RERACK_9BALL);
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
		


	#endif //!MAIN_SERVER
}

void CGameAppView::OnPracticeColours() 
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	
	// Set up the colours practice drill
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_COLOURS);
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_8BALL;
		m_snooker->Init(RERACK_8BALLSCATTERED);		
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
		
	// show/enable & redraw 'end practice session' button	
//	m_EndPracticeButton.EnableWindow(TRUE);
//	m_EndPracticeButton.ShowWindow(SW_SHOW);
//	m_EndPracticeButton.SetWindowPos(&wndTop, 0.5*m_cx+74, 0.5f*m_cx+5, 200+74, 30, SWP_SHOWWINDOW);
//	m_EndPracticeButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	#endif //!MAIN_SERVER
}

void CGameAppView::OnPracticeBlack() 
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	
	// Set up the black-ball practice drill
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->Init(RERACK_BLACK);
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_9BALL;
		m_snooker->Init(RERACK_9BALLSCATTERED);		
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
		
	// show/enable & redraw 'end practice session' button	
//	m_EndPracticeButton.EnableWindow(TRUE);
//	m_EndPracticeButton.ShowWindow(SW_SHOW);
//	m_EndPracticeButton.SetWindowPos(&wndTop, 0.5*m_cx+74, 0.5f*m_cx+5, 200+74, 30, SWP_SHOWWINDOW);
//	m_EndPracticeButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	#endif //!MAIN_SERVER
}


void CGameAppView::OnPracticeBilliards() 
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	
	// Set up the Billiards starting position - Red Ball on the Black Spot
	
	m_snooker->m_customTable->m_type = CTTYPE_BILLIARDS;
	m_snooker->m_customTable->subtype = 0;	// 50 pts Billiards
	m_snooker->Init(RERACK_BILLIARDS);

	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
		
	// show/enable & redraw 'end practice session' button	
//	m_EndPracticeButton.EnableWindow(TRUE);
//	m_EndPracticeButton.ShowWindow(SW_SHOW);
//	m_EndPracticeButton.SetWindowPos(&wndTop, 0.5*m_cx+74, 0.5f*m_cx+5, 200+74, 30, SWP_SHOWWINDOW);
//	m_EndPracticeButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	#endif //!MAIN_SERVER
}



void CGameAppView::OnPracticeRedsscattered1() 
{
	#ifndef MAIN_SERVER
	
	// TODO: Add your command handler code here

	// Set up the black-ball practice drill
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_REDSSCATTERED1);	
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_ROTATIONBALL;
		m_snooker->Init(RERACK_ROTATIONBALL);		
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
		
	// show/enable & redraw 'end practice session' button	
//	m_EndPracticeButton.EnableWindow(TRUE);
//	m_EndPracticeButton.ShowWindow(SW_SHOW);
//	m_EndPracticeButton.SetWindowPos(&wndTop, 0.5*m_cx+74, 0.5f*m_cx+5, 200+74, 30, SWP_SHOWWINDOW);
//	m_EndPracticeButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	#endif //!MAIN_SERVER
}

void CGameAppView::OnPracticeRedsscattered2() 
{
	#ifndef MAIN_SERVER
	
	// TODO: Add your command handler code here

	// Set up the black-ball practice drill
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_REDSSCATTERED2);
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_BOWLS;
		m_snooker->Init(RERACK_BOWLS);
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
		
	// show/enable & redraw 'end practice session' button	
//	m_EndPracticeButton.EnableWindow(TRUE);
//	m_EndPracticeButton.ShowWindow(SW_SHOW);
//	m_EndPracticeButton.SetWindowPos(&wndTop, 0.5*m_cx+74, 0.5f*m_cx+5, 200+74, 30, SWP_SHOWWINDOW);
//	m_EndPracticeButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	#endif //!MAIN_SERVER
}

void CGameAppView::OnPracticeA() 
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	
	// Set up the start-up table position
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_START);
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_6BALL;
		m_snooker->Init(RERACK_6BALL);		
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();

	#endif //!MAIN_SERVER
}

void CGameAppView::OnPracticeB() 
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	
	// Set up the start-up table position
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_START);
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_6BALL;
		m_snooker->Init(RERACK_6BALLSCATTERED);		
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();

	#endif //!MAIN_SERVER
}

void CGameAppView::OnPracticeC() 
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	
	// Set up the start-up table position
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_START);
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_10BALL;
		m_snooker->Init(RERACK_10BALL);		
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();

	#endif //!MAIN_SERVER
}

void CGameAppView::OnPracticeD() 
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	
	// Set up the start-up table position
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_START);
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_10BALL;
		m_snooker->Init(RERACK_10BALLSCATTERED);		
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();

	#endif //!MAIN_SERVER
}

// Break Setup
void CGameAppView::OnPracticeE()
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	
	// Set up the start-up table position
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_START);
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_BREAK;
		m_snooker->Init(RERACK_BREAK);		
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();

	#endif //!MAIN_SERVER
}



// English Pool Setup
void CGameAppView::OnPracticeF() 
{
	
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	
	// Set up the start-up table position
	if(g_build.gameType == GAMETYPE_SNOOKER)
		{
		m_snooker->m_customTable->m_type = CTTYPE_SNOOKER;
		m_snooker->Init(RERACK_START);
		}
	else if(g_build.gameType == GAMETYPE_POOL)
		{
		m_snooker->m_customTable->m_type = CTTYPE_UKPOOL;
		m_snooker->Init(RERACK_UKPOOL);		
		}
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	ChangeTitle(" Practice - Play Mode");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();

	#endif //!MAIN_SERVER
  
}



// Select the Normal Table (iPool Only) //
void CGameAppView::OnPracticeG() 
{
	
	BOOL setup = FALSE;
	#ifndef MAIN_SERVER
	
	// TODO: Add your command handler code here

	CMenu *subMenu = AfxGetMainWnd()->GetMenu()->GetSubMenu(PRACTICE_MENU);
	if(subMenu->GetMenuState(POOL_PRACTICE_NORMALTABLE, MF_BYPOSITION) == MF_UNCHECKED)
		{
		subMenu->CheckMenuItem(POOL_PRACTICE_NORMALTABLE, MF_CHECKED | MF_BYPOSITION);	// Turn on Normal Table
		subMenu->CheckMenuItem(POOL_PRACTICE_PROTABLE, MF_UNCHECKED | MF_BYPOSITION);	// Turn off Pro Table 
		subMenu->CheckMenuItem(POOL_PRACTICE_UKTABLE, MF_UNCHECKED | MF_BYPOSITION);	// Turn off UK Table
		setup = TRUE;
		}
	
	if(m_snooker->m_M3d_Table_ptr != &m_snooker->m_customTable->m_M3d_Table)
		m_snooker->m_customTable->PoolTableChange(&m_snooker->m_customTable->m_M3d_Table);
	

	if(setup)
		{
		m_snooker->InitChalkMarks(); // used to trigger redraw of new table
		m_snooker->m_bPracticeMode = TRUE;
		m_snooker->m_bComputerMode = FALSE;
		m_snooker->m_seat = 0; // force player to sit in 1P seat

		// refresh
		ChangeTitle(" Practice - (Normal Table) Play Mode");
		g_bMenuSelect = 0;
		m_bDisableOnDraw = 0;
		//RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		PreviousWndEditSetFocus();
		}	
	// show/enable & redraw 'end practice session' button	

	#endif //!MAIN_SERVER
}


// Select the Normal Table (iPool Only) //
void CGameAppView::OnPracticeH() 
{
	
	BOOL setup = FALSE;
	#ifndef MAIN_SERVER
	
	// TODO: Add your command handler code here

	CMenu *subMenu = AfxGetMainWnd()->GetMenu()->GetSubMenu(PRACTICE_MENU);
	if(subMenu->GetMenuState(POOL_PRACTICE_PROTABLE, MF_BYPOSITION) == MF_UNCHECKED)
		{
		subMenu->CheckMenuItem(POOL_PRACTICE_NORMALTABLE, MF_UNCHECKED | MF_BYPOSITION);// Turn off Normal Table
		subMenu->CheckMenuItem(POOL_PRACTICE_PROTABLE, MF_CHECKED | MF_BYPOSITION);		// Turn on Pro Table 
		subMenu->CheckMenuItem(POOL_PRACTICE_UKTABLE, MF_UNCHECKED | MF_BYPOSITION);	// Turn off UK Table
		setup = TRUE;
		}
	
	if(m_snooker->m_M3d_Table_ptr != &m_snooker->m_customTable->m_M3d_proTable)
		m_snooker->m_customTable->PoolTableChange(&m_snooker->m_customTable->m_M3d_proTable);
	

	if(setup)
		{
		m_snooker->InitChalkMarks(); // used to trigger redraw of new table
		m_snooker->m_bPracticeMode = TRUE;
		m_snooker->m_bComputerMode = FALSE;
		m_snooker->m_seat = 0; // force player to sit in 1P seat

		// refresh
		ChangeTitle(" Practice - (Normal Table) Play Mode");
		g_bMenuSelect = 0;
		m_bDisableOnDraw = 0;
		//RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		PreviousWndEditSetFocus();
		}	
	// show/enable & redraw 'end practice session' button	

	#endif //!MAIN_SERVER
}


// Select the Normal Table (iPool Only) //
void CGameAppView::OnPracticeI() 
{
	
	BOOL setup = FALSE;
	#ifndef MAIN_SERVER
	
	// TODO: Add your command handler code here

	CMenu *subMenu = AfxGetMainWnd()->GetMenu()->GetSubMenu(PRACTICE_MENU);
	if(subMenu->GetMenuState(POOL_PRACTICE_UKTABLE, MF_BYPOSITION) == MF_UNCHECKED)
		{
		subMenu->CheckMenuItem(POOL_PRACTICE_NORMALTABLE, MF_UNCHECKED | MF_BYPOSITION);	// Turn off Normal Table
		subMenu->CheckMenuItem(POOL_PRACTICE_PROTABLE, MF_UNCHECKED | MF_BYPOSITION);	// Turn off Pro Table 
		subMenu->CheckMenuItem(POOL_PRACTICE_UKTABLE, MF_CHECKED | MF_BYPOSITION);	// Turn on UK Table
		setup = TRUE;
		}
	
	if(m_snooker->m_M3d_Table_ptr != &m_snooker->m_customTable->m_M3d_ukTable)
		m_snooker->m_customTable->PoolTableChange(&m_snooker->m_customTable->m_M3d_ukTable);
	

	if(setup)
		{
		m_snooker->InitChalkMarks(); // used to trigger redraw of new table
		m_snooker->m_bPracticeMode = TRUE;
		m_snooker->m_bComputerMode = FALSE;
		m_snooker->m_seat = 0; // force player to sit in 1P seat

		// refresh
		ChangeTitle(" Practice - (Normal Table) Play Mode");
		g_bMenuSelect = 0;
		m_bDisableOnDraw = 0;
		RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		PreviousWndEditSetFocus();
		}	
	// show/enable & redraw 'end practice session' button	

	#endif //!MAIN_SERVER
}



void CGameAppView::OnPracticeEdit() 
{
	#ifndef MAIN_SERVER
	// TODO: Add your command handler code here
	
	if(m_snooker->m_reRackType == RERACK_EMPTY)
	{
		// Set up the start-up table position
		m_snooker->Init(RERACK_WHITEONLY);
		m_snooker->m_bPracticeMode = TRUE;
		m_snooker->m_bComputerMode = FALSE;
		m_snooker->m_seat = 0; // force player to sit in 1P seat

		// refresh
		ChangeTitle(" Practice - Play Mode");
		g_bMenuSelect = 0;
		m_bDisableOnDraw = 0;
		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		PreviousWndEditSetFocus();
		
		// show/enable & redraw 'end practice session' button	
//		m_EndPracticeButton.EnableWindow(TRUE);
//		m_EndPracticeButton.ShowWindow(SW_SHOW);
//		m_EndPracticeButton.SetWindowPos(&wndTop, 0.5*m_cx+74, 0.5f*m_cx+5, 200+74, 30, SWP_SHOWWINDOW);
//		m_EndPracticeButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	}

	// display practice-Edit tool-box
	m_practiceEditDlg.DestroyWindow();
	m_practiceEditDlg.Create(IDD_PRACTICEEDIT);
	m_practiceEditDlg.ShowWindow(SW_SHOW);
	
	if(g_build.gameType == GAMETYPE_POOL)
	{
		m_practiceEditDlg.m_buttonBlue.EnableWindow(FALSE);
		m_practiceEditDlg.m_buttonBlue.ShowWindow(SW_HIDE);
		m_practiceEditDlg.m_buttonPink.EnableWindow(FALSE);
		m_practiceEditDlg.m_buttonPink.ShowWindow(SW_HIDE);
		m_practiceEditDlg.m_buttonBlack.EnableWindow(FALSE);
		m_practiceEditDlg.m_buttonBlack.ShowWindow(SW_HIDE);
	}
	#endif //!MAIN_SERVER
}

void CGameAppView::PracticeEditRefreshBallSpots(int n) 
{
	int colour = m_snooker->m_ball[n]->m_colour;
	float f = 0 - BALL_POSITIONZOFFSET;
	switch(colour)
	{
		case WHITE:
		m_snooker->m_ball[n]->m_PSpot = CVector(-WORLD_X(912+5),-WORLD_Y(250+5),-f);
		break;						
		case YELLOW:
		m_snooker->m_ball[n]->m_PSpot = CVector(-WORLD_X(912),-WORLD_Y(199+12),-f);
		break;
		case GREEN:
		m_snooker->m_ball[n]->m_PSpot = CVector(-WORLD_X(912),-WORLD_Y(395-12),-f);
		break;
		case BROWN:
		m_snooker->m_ball[n]->m_PSpot = CVector(-WORLD_X(912),-WORLD_Y(297),-f);
		break;
		case BLUE:
		m_snooker->m_ball[n]->m_PSpot = CVector(-WORLD_X(591),-WORLD_Y(297),-f);
		break;
		case PINK:
		m_snooker->m_ball[n]->m_PSpot = CVector(-WORLD_X(331+10),-WORLD_Y(297),-f);
		break;
		case BLACK:
		m_snooker->m_ball[n]->m_PSpot = CVector(-WORLD_X(175-10),-WORLD_Y(297),-f);
		break;
	}
}	

void CGameAppView::OnPracticeLoad() 
{
	// TODO: Add your command handler code here
	
	// now start the loding process
	CGameAppDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	static char BASED_CODE szFilter[] = "Practice Files (*.prc;*.txt) | *.prc;*.txt ||"; 

	CFileDialog dlg(TRUE, "prc", "*.prc;*.txt", OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, szFilter);

	///////////////////////////////////////
	char version[24];
	char appName[80];
	DWORD customTableType;
	int colorSeq;
	appName[0] = 0;
	customTableType = 0;
	colorSeq = 0;

    if (dlg.DoModal() == IDOK)
	{
		//pDoc->OnOpenDocument(dlg.GetPathName());
		FILE *fptr = NULL;
		fptr = fopen(dlg.GetPathName().GetBuffer(0),"r");
		if(fptr)
		{	
			int n;

			/////////////////////////////////////////
			// Set up the start-up table position (init every ball)
			m_snooker->Init(RERACK_START);
			m_snooker->ClearBalls(); // Now, clear all balls states [Note: shouldn't have to do this trick!!]
			m_snooker->m_bPracticeMode = TRUE;
			m_snooker->m_bComputerMode = FALSE;
			m_snooker->m_seat = 0; // force player to sit in 1P seat

			// now set rereack type loaded position
			m_snooker->m_reRackType = RERACK_LOAD;
			
			// invalidate all
			for(n=0;n<MAX_TOTALBALLS;n++)
			{
				m_snooker->m_ballPosColour[n].x = 0;
				m_snooker->m_ballPosColour[n].y = 0;
				m_snooker->m_ballPosColour[n].colour = -1;
			}

			// refresh
			ChangeTitle(" Practice - Play Mode");
			g_bMenuSelect = 0;
			m_bDisableOnDraw = 0;
			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
			PreviousWndEditSetFocus();
			
			// show/enable & redraw 'end practice session' button	
//			m_EndPracticeButton.EnableWindow(TRUE);
//			m_EndPracticeButton.ShowWindow(SW_SHOW);
//			m_EndPracticeButton.SetWindowPos(&wndTop, 0.5*m_cx+74, 0.5f*m_cx+5, 200+74, 30, SWP_SHOWWINDOW);
//			m_EndPracticeButton.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
			/////////////////////////////////////////

			///////////////////////////////////////////////
			// read header (for version checking, etc)
			fscanf(fptr,"%s",&version);
			///////////////////////////////////////////////

			if( strcmpi(version, "V1.0") == 0)
			{
				//"V1.0"
			}
			else if( strcmpi(version, "V1.1") == 0)
			{
				//Higher Version

				// app. name
				fscanf(fptr,"%s",&appName);
				
				// wrong application file version?
				if( strcmpi(g_appName.GetBuffer(0), appName) !=0 )
				{
					fclose(fptr);
					return;
				}
								
				// custom table type
				fscanf(fptr,"%d",&customTableType);
				
				if( strcmpi(appName, "iSnooker") == 0 )
				{
					
				}
				else if( strcmpi(appName, "iPool") == 0 )
				{
					m_snooker->m_customTable->m_type = customTableType;					
				}

				// colour sequence
				fscanf(fptr,"%d",&colorSeq);				
			}
			else
			{
				// wrong version!
				fclose(fptr);
				return;
			}

			///////////////////////////////////////////////
			// read comments
			
			// display practice-Edit tool-box
			m_practiceEditDlg.DestroyWindow();
			m_practiceEditDlg.Create(IDD_PRACTICEEDIT);
			m_practiceEditDlg.ShowWindow(SW_SHOW);

			// make sure we've created this dialog!
			m_practiceEditDlg.m_commentDlg.DestroyWindow();
			m_practiceEditDlg.m_commentDlg.Create(IDD_PRACTICECOMMENTS);
			

			if( m_practiceEditDlg.IsWindowVisible() )
					m_practiceEditDlg.m_commentDlg.ShowWindow(SW_SHOW);
			
			m_practiceEditDlg.CenterWindow();

			CEdit *pEdit = (CEdit *)m_practiceEditDlg.m_commentDlg.GetDlgItem(IDC_PRACTICECOMMENTS_EDIT);
			CString comments;
			int lineCount;
			char letter;
			
			if(pEdit)
			{
				// get length of comments message
				int length = 0;
				fscanf(fptr,"%d", &length);
				
				// build up string (char by char)
				if(length)
				{
					for(int n=0;n<length;n++)
					{
						fread(&letter,1,1,fptr);
						//if(letter==0x0d) 
						//	break;
						if(n>=2) // skip \r\n (from length above)
							comments += letter;
					}
					//comments += _T("0");
				}
		
				// display string to windows
				pEdit->SetWindowText(comments.GetBuffer(0));
				Message(""); // trick!! to make text correct colour
				m_editExChat.SetWindowText(comments.GetBuffer(0));
			}
			///////////////////////////////////////////////
			
			#ifdef THE_POOL_CLUB // ipool
			///////////////////////////////////////////////
			// read ball (x, y, colour) data
			int total = MAX_TOTALBALLS;
			float x, y;
			int colour;
			int success;

			while(total)
			{
				// read x,y,colour data
				success = fscanf(fptr,"%f", &x);
				if(success == EOF) break;
				success = fscanf(fptr,"%f", &y);
				if(success == EOF) break;
				success = fscanf(fptr,"%d", &colour);
				if(success == EOF) break;
								
				for(n=0;n<MAX_TOTALBALLS;n++)
				{
					if(!TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
					if(n == colour) // get correct idx for colour
					{					
						// store ball pos & colour - for re-rack (Load setup)
						m_snooker->m_ballPosColour[n].x = -x;
						m_snooker->m_ballPosColour[n].y = -y;
						m_snooker->m_ballPosColour[n].colour = colour;

						// init a snooker ball
						m_snooker->m_ball[n]->Init(-x,-y,0, colour);
											
						//if(g_build.gameType == GAMETYPE_SNOOKER)
						//	PracticeEditRefreshBallSpots(n);
						break;
					}
				}				
				total--;
			}
			///////////////////////////////////////////////
			#else // isnooker
			///////////////////////////////////////////////
			// read ball (x, y, colour) data
			float x, y;
			int colour;
			int success;
			for(n=0;n<MAX_TOTALBALLS;n++)
			{
				if(!TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
				{
					success = fscanf(fptr,"%f", &x);
					if(success == EOF) break;
					success = fscanf(fptr,"%f", &y);
					if(success == EOF) break;
					success = fscanf(fptr,"%d", &colour);
					if(success == EOF) break;
					
					// store ball pos & colour - for re-rack (Load setup)
					m_snooker->m_ballPosColour[n].x = -x;
					m_snooker->m_ballPosColour[n].y = -y;
					m_snooker->m_ballPosColour[n].colour = colour;

					// init a snooker ball
					m_snooker->m_ball[n]->Init(-x,-y,0, colour);
										
					if(g_build.gameType == GAMETYPE_SNOOKER)
						PracticeEditRefreshBallSpots(n);
				}
			}
			///////////////////////////////////////////////
			#endif //THE_POOL_CLUB
						
			fclose(fptr);

			// finally, re-rack 'load' type
			m_snooker->Init(m_snooker->m_reRackType);

			if( strcmpi(version, "V1.0") == 0) return;
			
			// ...and switch back to correct rerack type
			if( strcmpi(appName, "iPool") == 0 )
			{
				m_snooker->m_reRackType = RERACK_8BALL;
				m_snooker->m_colourseq = colorSeq;
			}
		}
	}
}

void CGameAppView::OnPracticeSave()  // Save As...
{
	// TODO: Add your command handler code here
	CGameAppDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	static char BASED_CODE szFilter[] = "Practice Files (*.prc) | *.prc ||"; 

	CFileDialog dlg(FALSE, "prc", "*.prc", OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, szFilter);
	
	///////////////////////////////////////

    if (dlg.DoModal() == IDOK)
	{
		//pDoc->OnOpenDocument(dlg.GetPathName());
		FILE *fptr = NULL;
		fptr = fopen(dlg.GetPathName().GetBuffer(0),"w");
		if(fptr)
		{
			///////////////////////////////////////////////
			// add header (for version checking, etc)
			//fprintf(fptr,"V1.0\r\n");
			fprintf(fptr,"V1.1\r\n");
			///////////////////////////////////////////////

			///////////////////////////////////////////////
			// app. name
			fprintf(fptr,"%s\r\n", g_appName);
			///////////////////////////////////////////////

			///////////////////////////////////////////////
			// custom table type
			fprintf(fptr,"%d\r\n", m_snooker->m_customTable->m_type);
			///////////////////////////////////////////////

			///////////////////////////////////////////////
			// colour sequence
			fprintf(fptr,"%d\r\n", m_snooker->m_colourseq);
			///////////////////////////////////////////////

			///////////////////////////////////////////////
			// add comments
			BOOL ok = FALSE;
			CEdit *pEdit;
			if(m_practiceEditDlg.m_commentDlg.m_hWnd)
				{
				pEdit = (CEdit *)m_practiceEditDlg.m_commentDlg.GetDlgItem(IDC_PRACTICECOMMENTS_EDIT);
				ok = TRUE;
				}
			CString comments;
			if(ok)
			{
				// get window text
				pEdit->GetWindowText(comments);
				
				// get & write text length + comments
				int length = comments.GetLength();
			
				fprintf(fptr,"%d\r\n", length+2);

				// write comments string
				fwrite(comments, comments.GetLength(), 1, fptr);			
			}
			else
			{
				fprintf(fptr,"%d\r\n", 0);
			}
			///////////////////////////////////////////////
			
			///////////////////////////////////////////////
			// add ball (x, y, colour) data
			for(int n=0;n<MAX_TOTALBALLS;n++)
			{
				if(TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
				{
					fprintf(fptr,"%f\r\n%f\r\n%d\r\n", m_snooker->m_ball[n]->m_P.x, m_snooker->m_ball[n]->m_P.y, m_snooker->m_ball[n]->m_colour);
				}
			}
			///////////////////////////////////////////////
			fclose(fptr);
		}
	}
}

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
// OnUpdatePractice - for enabling/disabling

void CGameAppView::OnUpdatePracticeStart(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))// || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeLineup(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))// || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeColours(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))// || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeBlack(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))// || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeBilliards(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))// || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeRedsscattered1(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))// || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeRedsscattered2(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))// || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeA(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeB(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeC(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeD(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeE(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}


void CGameAppView::OnUpdatePracticeF(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}


// Normal Table Type //
void CGameAppView::OnUpdatePracticeG(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

// Pro Table Type //
void CGameAppView::OnUpdatePracticeH(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

// English Pool Table Type //
void CGameAppView::OnUpdatePracticeI(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}


void CGameAppView::OnUpdatePracticeBallinhand(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && !gameShell && m_snooker->m_bPracticeMode) && !m_snooker->m_bComputerMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePracticeEdit(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell) && !m_snooker->m_bComputerMode)// || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}


void CGameAppView::OnUpdatePracticeLoad(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell) && !m_snooker->m_bComputerMode)// || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 	
}

void CGameAppView::OnUpdatePracticeSave(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell) && !m_snooker->m_bComputerMode)// || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 	
}

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

void CGameAppView::OnOptionsReplaypanel() 
{
	#ifndef MAIN_SERVER

	// TODO: Add your command handler code here
	m_replayDlg.DestroyWindow();
	m_replayDlg.Create(IDD_REPLAY); m_bReplayMode = TRUE;

	m_replayDlg.m_slider.SetRange(0,100);//m_replay->m_strikelist_idx);
	m_replayDlg.m_slider.SetPos(0);
	m_replayDlg.ShowWindow(SW_SHOW);
		
	#endif //!MAIN_SERVER
}

void CGameAppView::OnUpdateOptionsReplaypanel(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && !gameShell && m_snooker->m_bPracticeMode) )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnGamePlayerlist() 
{
	// TODO: Add your command handler code here
	m_playerListDlg.DestroyWindow();
	m_playerListDlg.Create(IDD_PLAYERLIST);
	m_playerListDlg.ShowWindow(SW_SHOW);
}

void CGameAppView::OnInvitationsDeclineall() 
{
	// TODO: Add your command handler code here
	#ifndef MAIN_SERVER
	CMenu *subMenu = AfxGetMainWnd()->GetMenu()->GetSubMenu(GAME_MENU);
	if(subMenu)
	{
		CMenu *subSubMenu = subMenu->GetSubMenu(GAME_INVITATIONS);
		if(subSubMenu)
		{
			// toggle option
			if(!m_lobby->m_bDeclineAll)
			{
				g_gfxDetails.bDeclineAll = m_lobby->m_bDeclineAll = TRUE;
				subSubMenu->CheckMenuItem(GAME_INVITATIONS_DECLINEALL, MF_CHECKED | MF_BYPOSITION);

				for(int n=0;n<MAX_INVITATIONDLGS;n++)
					m_invitationDlg[n].m_bDeclineAll = TRUE;															  
			}
			else
			{
				g_gfxDetails.bDeclineAll = m_lobby->m_bDeclineAll = FALSE;
				subSubMenu->CheckMenuItem(GAME_INVITATIONS_DECLINEALL, MF_UNCHECKED | MF_BYPOSITION);

				for(int n=0;n<MAX_INVITATIONDLGS;n++)				
					m_invitationDlg[n].m_bDeclineAll = FALSE;
			}
		}
	}
	#endif //!MAIN_SERVER 
}

void CGameAppView::OnInvitationsDeclineguests() 
{
	// TODO: Add your command handler code here
	#ifndef MAIN_SERVER
	CMenu *subMenu = AfxGetMainWnd()->GetMenu()->GetSubMenu(GAME_MENU);
	if(subMenu)
	{
		CMenu *subSubMenu = subMenu->GetSubMenu(GAME_INVITATIONS);
		if(subSubMenu)
		{
			// toggle option
			if(!m_lobby->m_bDeclineAllGuests)
			{
				g_gfxDetails.bDeclineAllGuests = m_lobby->m_bDeclineAllGuests = TRUE;
				subSubMenu->CheckMenuItem(GAME_INVITATIONS_DECLINEALLGUESTS, MF_CHECKED | MF_BYPOSITION);

				for(int n=0;n<MAX_INVITATIONDLGS;n++)
					m_invitationDlg[n].m_bDeclineAllGuests = TRUE;
			}
			else
			{
				g_gfxDetails.bDeclineAllGuests = m_lobby->m_bDeclineAllGuests = FALSE;
				subSubMenu->CheckMenuItem(GAME_INVITATIONS_DECLINEALLGUESTS, MF_UNCHECKED | MF_BYPOSITION);

				for(int n=0;n<MAX_INVITATIONDLGS;n++)
					m_invitationDlg[n].m_bDeclineAllGuests = FALSE;
			}
		}
	}
	#endif //!MAIN_SERVER 
}

void CGameAppView::OnUpdateGamePlayerlist(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	//if( (!m_lobby->m_bInLobby && gameShell) )
	if( m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 )
	{	  
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdateInvitationsDeclineall(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( m_lobby->m_bInLobby || 
		m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdateInvitationsDeclineguests(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( m_lobby->m_bInLobby || 
		m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnAppAbout() 
{
	// TODO: Add your command handler code here
	//m_aboutDlg.DoModal();
	m_aboutDlg.DestroyWindow();
	m_aboutDlg.Create(IDD_ABOUTBOX);
	m_aboutDlg.ShowWindow(SW_SHOW);
}

void CGameAppView::OnInternetDetails() 
{
	// TODO: Add your command handler code here
	m_detailsDlg.DestroyWindow();
	m_detailsDlg.Create(IDD_DETAILS);
	m_detailsDlg.ShowWindow(SW_SHOW);	
}
/*
void CGameAppView::OnInternetSettings() 
{
	// TODO: Add your command handler code here
	m_detailsSettingsDlg.DestroyWindow();
	m_detailsSettingsDlg.Create(IDD_DETAILSSETTINGS);
	m_detailsSettingsDlg.ShowWindow(SW_SHOW);
}
*/

/*
<html><head><title>NetGenie Gateway</title></head><body bgcolor='#000000' text='#ffffff'>Lobbys: <b>(0/64)</b><br><table border=1><tr><td>#</td><td>Name</td><td>Description</td><td>Address</td><td>Last Updated<br>(secs)</td></tr></table></body></html>
*/


void CGameAppView::ReportMatchTourney(int tid, char *name1P, int frames1P, char *name2P, int frames2P) // Send Tournament frame result
{
	if (!g_bTournamentLobby) return;

	//m_httpSocketEx2->Init(m_lobbySettings->m_gatewayIP, m_lobbySettings->m_gatewayPort);

	//m_httpSocketEx2->m_tag = HTTPSOCKETEXTAG_TOURNEY;

	char str[256];

#ifndef THE_POOL_CLUB
	if(g_tourney_system==0) sprintf(str, "mtourney/mtourney.php?mode=a12_dmatchreport&tid=%d&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
	else if(g_tourney_system==1) sprintf(str, "etourney/mtourney.php?mode=a12_dmatchreport&tid=%d&&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
	else if(g_tourney_system==2) sprintf(str, "s1tourney/mtourney.php?mode=a12_dmatchreport&tid=%d&&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
	else if(g_tourney_system==3) sprintf(str, "s2tourney/mtourney.php?mode=a12_dmatchreport&tid=%d&&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
	else if(g_tourney_system==4) sprintf(str, "sgtourney/mtourney.php?mode=a12_dmatchreport&tid=%d&&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
	//else if(g_tourney_system==4) sprintf(str, "mleague/mleague.php?mode=a12_dmatchreport&tid=%d&&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
#else
	if (g_tourney_system == 0) sprintf(str, "ipool/mtourney/mtourney.php?mode=a12_dmatchreport&tid=%d&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
	else if (g_tourney_system == 1) sprintf(str, "ipool/etourney/mtourney.php?mode=a12_dmatchreport&tid=%d&&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
	else if (g_tourney_system == 2) sprintf(str, "ipool/s1tourney/mtourney.php?mode=a12_dmatchreport&tid=%d&&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
	else if (g_tourney_system == 3) sprintf(str, "ipool/s2tourney/mtourney.php?mode=a12_dmatchreport&tid=%d&&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
	else if (g_tourney_system == 4) sprintf(str, "ipool/sgtourney/mtourney.php?mode=a12_dmatchreport&tid=%d&&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);
	//else if(g_tourney_system==4) sprintf(str, "mleague/mleague.php?mode=a12_dmatchreport&tid=%d&&name1=%s&fp1=%d&name2=%s&fp2=%d", tid, name1P, frames1P, name2P, frames2P);

#endif

	//m_httpSocketEx2->Request(str, "", "sockettny2.tmp");
	m_reqManager->StartRequest(m_lobbySettings->m_tourneyIP, m_lobbySettings->m_tourneyPort, str);

	//m_eventTimerMinute->m_tick1 = 2; //2mins
	if(m_eventTimerMinute->m_tick1 > 2) m_eventTimerMinute->m_tick1 = 2; //2mins
}




void CGameAppView::UpdateTourney(void) // Request NetGenie's Tournament info. //
{
	m_httpSocketEx2->Init(m_lobbySettings->m_tourneyIP, m_lobbySettings->m_tourneyPort);

	m_httpSocketEx2->m_tag = HTTPSOCKETEXTAG_TOURNEY;

#ifndef THE_POOL_CLUB
	if(g_tourney_system==0) m_httpSocketEx2->Request("mtourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	else if(g_tourney_system==1) m_httpSocketEx2->Request("etourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	else if(g_tourney_system==2) m_httpSocketEx2->Request("s1tourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	else if(g_tourney_system==3) m_httpSocketEx2->Request("s2tourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	else if(g_tourney_system==4) m_httpSocketEx2->Request("sgtourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	//else if(g_tourney_system==4) m_httpSocketEx2->Request("mleague/mleague.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	else if(g_tourney_system==5) m_httpSocketEx2->Request("s3tourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
#else
	if (g_tourney_system == 0) m_httpSocketEx2->Request("ipool/mtourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	else if (g_tourney_system == 1) m_httpSocketEx2->Request("ipool/etourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	else if (g_tourney_system == 2) m_httpSocketEx2->Request("ipool/s1tourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	else if (g_tourney_system == 3) m_httpSocketEx2->Request("ipool/s2tourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	else if (g_tourney_system == 4) m_httpSocketEx2->Request("ipool/sgtourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	//else if(g_tourney_system==4) m_httpSocketEx2->Request("mleague/mleague.php?mode=a12_dmatchlist", "", "sockettny.tmp");
	else if (g_tourney_system == 5) m_httpSocketEx2->Request("ipool/s3tourney/mtourney.php?mode=a12_dmatchlist", "", "sockettny.tmp");

#endif
}

void CGameAppView::UpdateNextEventBroadcastTimes()
{
	for (NextTournamentData& nextTournamentData : nextTournamentData) {
		nextTournamentData.UpdateBroadcastTime();
	}
}

void CGameAppView::RemoveExpiredBroadcastTimes()
{
	for (int i = 0; i < nextTournamentData.size();++i) {
		if (nextTournamentData[i].expirationCycles <= 0) {
			nextTournamentData.erase(nextTournamentData.begin() + i);
		}
	}
}

void CGameAppView::GetNextEvent() // Request NetGenie's Tournament info. //
{
#ifdef MAIN_SERVER
	// Don't proceed, if we don't have any Tournament Events to broadcast
	// See setting.txt (i.e.)
	// <tournamentbroadcast_url1>localhost/mtourney/mtourney.php</tournamentbroadcast_url1>
	// <tournamentbroadcast_url2>localhost/mtourney/etourney.php</tournamentbroadcast_url2>

	if (m_lobbySettings->m_tourneybcUrlCount == 0)
		return;

	static int tourneyIdx = 0;
	
	m_httpSocketEx2->Init(m_lobbySettings->m_tourneyIP, m_lobbySettings->m_tourneyPort);
	m_httpSocketEx2->m_tag = HTTPSOCKETEXTAG_NEXTEVENT;

	
	char buf[128];
	sprintf(buf, "%s?mode=a12_getnextevent", m_lobbySettings->m_tourneybcUrl[tourneyIdx]);
	m_httpSocketEx2->Request(buf, "", "sockettny.tmp");
	

	
	++tourneyIdx;
	if (tourneyIdx == m_lobbySettings->m_tourneybcUrlCount) {
		tourneyIdx = 0;
	}


#endif
}





void CGameAppView::HTTPParseTourney(void *_lpBuf, int nBufLen) // Received NetGenie's Tournament info. //
{
	CExaminer *Source = new CExaminer((char *)_lpBuf, nBufLen); // Source represents the entire contents.
	if(Source)
	{

		int idx = 0;

		CExaminer *Tourney;
		for(;;)
		{
			
			Tourney = Source->Examine("<tourney>","</tourney>"); // Get Tourney Data /
			if(Tourney)
			{
		
				CExaminer *Name = Tourney->ExamineEntire("<name>","</name>"); // Get Name //
				if(Name)
				{
				g_tournament.AddName(Name->GetString(), idx);
				delete Name;
				}

				CExaminer *Desc = Tourney->ExamineEntire("<desc>","</desc>"); // Get Description //
				if(Desc)
				{
				g_tournament.AddDesc(Desc->GetString(), idx);
				delete Desc;
				}


				CExaminer *SPONSOR = Tourney->ExamineEntire("<sp>","</sp>");
				if(SPONSOR)
				{
				g_tournament.AddSponsor(SPONSOR->GetString(), idx);
				delete SPONSOR;
				}

				CExaminer *SPONSORURL = Tourney->ExamineEntire("<su>","</su>");
				if(SPONSORURL)
				{
				g_tournament.AddSponsorURL(SPONSORURL->GetString(), idx);
				delete SPONSORURL;
				}

				CExaminer *Options = Tourney->ExamineEntire("<options>","</options>"); // Get Options //
				if(Options)
				{
					CExaminer *Level = Options->ExamineEntire("<level>","</level>");
					if(Level)
					{
						g_tournament.AddOptionsLevel(Level->GetString(), idx);
						delete Level;
					}

					CExaminer *WhoBreaks = Options->ExamineEntire("<whobreaks>","</whobreaks>");
					if(WhoBreaks)
					{
						g_tournament.AddOptionsWhoBreaks(WhoBreaks->GetString(), idx);
						delete WhoBreaks;
					}

					CExaminer *TableColour = Options->ExamineEntire("<tablecolour>","</tablecolour>");
					if(TableColour)
					{
						g_tournament.AddOptionsTableColour(TableColour->GetString(), idx);
						delete TableColour;
					}

					CExaminer *TableType = Options->ExamineEntire("<tabletype>","</tabletype>");
					if(TableType)
					{
						g_tournament.AddOptionsTableType(TableType->GetString(), idx);
						delete TableType;
					}

					CExaminer *BallSize = Options->ExamineEntire("<ballsize>","</ballsize>");
					if(BallSize)
					{
						g_tournament.AddOptionsBallSize(BallSize->GetString(), idx);
						delete BallSize;
					}

					CExaminer *RackType = Options->ExamineEntire("<racktype>","</racktype>");
					if(RackType)
					{
						g_tournament.AddOptionsRackType(RackType->GetString(), idx);
						delete RackType;
					}

					CExaminer *AddTimer = Options->ExamineEntire("<addtimer>","</addtimer>");
					if(AddTimer)
					{
						g_tournament.AddOptionsAddTimer(AddTimer->GetString(), idx);
						delete AddTimer;
					}

					CExaminer *ShotTime = Options->ExamineEntire("<shottime>","</shottime>");
					if(ShotTime)
					{
						g_tournament.AddOptionsShotTime(ShotTime->GetString(), idx);
						delete ShotTime;
					}

					CExaminer *Rated = Options->ExamineEntire("<rated>","</rated>");
					if(Rated)
					{
						g_tournament.AddOptionsRated(Rated->GetString(), idx);
						delete Rated;
					}

					CExaminer *CallShots = Options->ExamineEntire("<callshots>","</callshots>");
					if(CallShots)
					{
						g_tournament.AddOptionsCallShots(CallShots->GetString(), idx);
						delete CallShots;
					}

					CExaminer *MissRule = Options->ExamineEntire("<missrule>","</missrule>");
					if(MissRule)
					{
						g_tournament.AddOptionsMissRule(MissRule->GetString(), idx);
						delete MissRule;
					}

					CExaminer *HighB = Options->ExamineEntire("<highb>","</highb>");
					if(HighB)
					{
						g_tournament.AddOptionsHighB(HighB->GetString(), idx);
						delete HighB;
					}

					CExaminer *HighBCash = Options->ExamineEntire("<highbcash>","</highbcash>");
					if(HighBCash)
					{
						g_tournament.AddOptionsHighBCash(HighBCash->GetString(), idx);
						delete HighBCash;
					}

					CExaminer *ProTable = Options->ExamineEntire("<protable>","</protable>"); // note: for iPool only
					if(ProTable)
					{
						g_tournament.AddOptionsProTable(ProTable->GetString(), idx);
						delete ProTable;
					}
					CExaminer *Doubles = Options->ExamineEntire("<doubles>","</doubles>");
					if(Doubles)
					{
						g_tournament.AddOptionsDoubles(Doubles->GetString(), idx);
						delete Doubles;
					}

					
					delete Options;
				}		

				CExaminer *Match;
				for(;;) // Get all Match fields //
				{
					Match = Tourney->Examine("<match>","</match>"); // Get Match //
					if(Match)
					{
					CExaminer *TID;
					CExaminer *A;
					CExaminer *B;
					CExaminer *R;
					CExaminer *FP1;
					CExaminer *FP2;
					CExaminer *WPTS;
					CExaminer *LPTS;
					CExaminer *WCASH;
					CExaminer *LCASH;
					CExaminer *FEE1;
					CExaminer *FEE2;			
					CExaminer *SCORE1;
					CExaminer *SCORE2;
					CExaminer *ROUND;
					CExaminer *WACCEXT;
					CExaminer *LACCEXT;			
					CExaminer *PENALTY;
					CExaminer *GAMETYPE;		

					TID = Match->ExamineEntire("<tid>","</tid>");
					A = Match->ExamineEntire("<a>","</a>");
					B = Match->ExamineEntire("<b>","</b>");
					R = Match->ExamineEntire("<r>","</r>");
					FP1 = Match->ExamineEntire("<fp1>","</fp1>");
					FP2 = Match->ExamineEntire("<fp2>","</fp2>");
					WPTS = Match->ExamineEntire("<wpts>","</wpts>");
					LPTS = Match->ExamineEntire("<lpts>","</lpts>");
					WCASH = Match->ExamineEntire("<wcash>","</wcash>");
					LCASH = Match->ExamineEntire("<lcash>","</lcash>");
					FEE1 = Match->ExamineEntire("<fee1>","</fee1>");
					FEE2 = Match->ExamineEntire("<fee2>","</fee2>");
					SCORE1 = Match->ExamineEntire("<score1>","</score1>");
					SCORE2 = Match->ExamineEntire("<score2>","</score2>");
					ROUND = Match->ExamineEntire("<round>","</round>");
					WACCEXT = Match->ExamineEntire("<wa>","</wa>");
					LACCEXT = Match->ExamineEntire("<la>","</la>");			
					PENALTY = Match->ExamineEntire("<pen>","</pen>");
					GAMETYPE = Match->ExamineEntire("<gametype>","</gametype>");
								
					char *sPENALTY = NULL;
					if(PENALTY) sPENALTY = PENALTY->GetString();
					char *sGAMETYPE = NULL;
					if(GAMETYPE) sGAMETYPE = GAMETYPE->GetString();			

					char *sWACCEXT = NULL;
					if(WACCEXT) sWACCEXT = WACCEXT->GetString();
					char *sLACCEXT = NULL;
					if(LACCEXT) sLACCEXT = LACCEXT->GetString();

					if(TID && A && B && R && FP1 && FP2) // &
					if(WPTS && LPTS && FEE1 && FEE2 && WCASH && LCASH)
						{
						//char buffer[256];
						//sprintf(buffer,"(raceTo:%s) '%s'[%s] vs '%s'[%s] WPTS=%s, LPTS=%s, FEE1=%s, FEE2=%s",R->GetString(),A->GetString(), FP1->GetString(), B->GetString(), FP2->GetString(), WPTS->GetString(), LPTS->GetString(), FEE1->GetString(), FEE2->GetString());
						//ErrorMessage(g_gameAppView,buffer);

						if(ROUND)
							{
							//ErrorMessage(g_wnd, "ABCD1234-----");
							if(SCORE1 && SCORE2)
								{
								// SPECIAL: we have start scores for this match!
								g_tournament.AddMatch(TID->GetString(), R->GetString(),A->GetString(),B->GetString(), FP1->GetString(), FP2->GetString(), WPTS->GetString(), LPTS->GetString(), WCASH->GetString(), LCASH->GetString(), FEE1->GetString(), FEE2->GetString(), SCORE1->GetString(), SCORE2->GetString(), ROUND->GetString(), sWACCEXT, sLACCEXT, sPENALTY, sGAMETYPE, idx, false);
								}
							else
								{
								// default: both players start at 0-0
								g_tournament.AddMatch(TID->GetString(), R->GetString(),A->GetString(),B->GetString(), FP1->GetString(), FP2->GetString(), WPTS->GetString(), LPTS->GetString(), WCASH->GetString(), LCASH->GetString(), FEE1->GetString(), FEE2->GetString(), "0", "0", ROUND->GetString(), sWACCEXT, sLACCEXT, sPENALTY, sGAMETYPE, idx, false);
								}				
							}
						else // null round = -1
							{
							if(SCORE1 && SCORE2)
								{
								// SPECIAL: we have start scores for this match!
								g_tournament.AddMatch(TID->GetString(), R->GetString(),A->GetString(),B->GetString(), FP1->GetString(), FP2->GetString(), WPTS->GetString(), LPTS->GetString(), WCASH->GetString(), LCASH->GetString(), FEE1->GetString(), FEE2->GetString(), SCORE1->GetString(), SCORE2->GetString(), "-1", sWACCEXT, sLACCEXT, sPENALTY, sGAMETYPE, idx, false);
								}
							else
								{
								// default: both players start at 0-0
								g_tournament.AddMatch(TID->GetString(), R->GetString(),A->GetString(),B->GetString(), FP1->GetString(), FP2->GetString(), WPTS->GetString(), LPTS->GetString(), WCASH->GetString(), LCASH->GetString(), FEE1->GetString(), FEE2->GetString(), "0", "0", "-1", sWACCEXT, sLACCEXT, sPENALTY, sGAMETYPE, idx, false);
								}				
							}				

						}

					if(TID) delete TID;
					if(A) delete A;
					if(B) delete B;
					if(R) delete R;
					if(FP1) delete FP1;
					if(FP2) delete FP2;
					if(WPTS) delete WPTS;
					if(LPTS) delete LPTS;
					if(FEE1) delete FEE1;
					if(FEE2) delete FEE2;
					if(SCORE1) delete SCORE1;
					if(SCORE2) delete SCORE2;
					if(ROUND) delete ROUND;
					if(WACCEXT) delete WACCEXT;
					if(LACCEXT) delete LACCEXT;
					if(PENALTY) delete PENALTY;
					if(GAMETYPE) delete GAMETYPE;			

					delete Match;
					} else break;
				} // end for

			delete Tourney;
			idx++;
			} else break;
		}
	
	delete Source;
	}
}


void CGameAppView::HTTPParseNextEvent(void* _lpBuf, int nBufLen) // Received NetGenie's Tournament info. //
{

	NextTournamentData data;
	

	CExaminer* Source = new CExaminer((char*)_lpBuf, nBufLen); // Source represents the entire contents.
	if (Source)
	{

		int idx = 0;

		CExaminer* Tourney;
		for (;;)
		{

			Tourney = Source->Examine("<tourney>", "</tourney>"); // Get Tourney Data /
			if (Tourney)
			{
				
				CExaminer* Name = Tourney->ExamineEntire("<name>", "</name>"); // Get Name //
				if (Name)
				{
					strcpy(data.name, Name->GetString());
					delete Name;
				}

				CExaminer* tourneyid = Tourney->ExamineEntire("<id>", "</id>"); // Get Tournament id //
				if (tourneyid)
				{
					data.tourneyid = tourneyid->GetInt();
					delete tourneyid;
				}

				CExaminer* timestamp = Tourney->ExamineEntire("<timestamp>", "</timestamp>"); // Get Tournament id //
				if (timestamp)
				{
					//nextTournamentData[0].UpdateTimeStamp
					char* str = timestamp->GetString();

					// AfxMessageBox(str);

					data.timestamp = std::stold(str);
					delete timestamp;
				}

				CExaminer* entrants = Tourney->ExamineEntire("<entrants>", "</entrants>"); // Get Tournament id //
				if (tourneyid)
				{
					data.entrants = entrants->GetInt();
					delete entrants;
				}

				CExaminer* url = Tourney->ExamineEntire("<url>", "</url>"); // Get Tournament id //
				if (url)
				{
					strcpy(data.url, url->GetString());
					delete url;
				}

				
				CExaminer* desc = Tourney->ExamineEntire("<lobbydesc>", "</lobbydesc>"); // Get Tournament id //
				if (desc)
				{
					strcpy(data.lobbyDesc, desc->GetString());
					delete desc;
				}



				// Update Next Tournament Data
				// AfxMessageBox("Parsing Event!!!");
				// AfxMessageBox(data.getInfo());



				bool bUpdated = false;
				for (int i = 0; i < nextTournamentData.size(); ++i) {
					if (nextTournamentData[i].tourneyid == data.tourneyid) {
						nextTournamentData[i].Update(data.name, data.tourneyid, data.timestamp, data.entrants, data.url, data.lobbyDesc);
						bUpdated = true;
						break;
					}
				}
				if (!bUpdated) {
					nextTournamentData.push_back(data);
					nextTournamentData[nextTournamentData.size() - 1].ResetExpiration();
				}
				
				delete Tourney;
				idx++;
			}
			else break;
		}

		delete Source;
	}

	// Check if we have any BroadcastTimes to remove.
	((CGameAppView*)g_wnd)->RemoveExpiredBroadcastTimes();

	// Update BroadcastTimes
	((CGameAppView*)g_wnd)->UpdateNextEventBroadcastTimes();
}


void CGameAppView::HTTPStartGateway(int nErrorCode)
{
	CString cstr[4];
	m_lobbySelectDlg.m_listLobbies.DeleteAllItems();
	m_lobbySelectDlg.m_listLobbies.m_totalItems = 0;
	if(nErrorCode)
	{
	cstr[0] = "Error";
	cstr[1] = "Gateway Not Found";
	cstr[2] = "";
	cstr[3] = "";
	m_lobbySelectDlg.m_listLobbies.CreateItem(0, cstr);
	} else {
	cstr[0] = "Success";
	cstr[1] = "Connected To Gateway";
	cstr[2] = "";
	cstr[3] = "";
	m_lobbySelectDlg.m_listLobbies.CreateItem(0, cstr);
	}
}

void CGameAppView::HTTPParseGateway(void *lpBuf, int nBufLen)
{
	char *buffer;
	int offset;
	int len;
	int n;
	int n2;
	int x,y;
	char contents[1024];
	char *entry;
	int entry_len;
	int mainlobby_idx;
	int lobbies;

	lobbies = 0;

	mainlobby_idx = -1;
	if(m_gatewaylst) delete m_gatewaylst;
	m_gatewaylst = new CGatewayLst(64);

	m_lobbySelectDlg.m_listLobbies.DeleteAllItems();
	m_lobbySelectDlg.m_listLobbies.m_totalItems = 0;

	buffer = (char *) lpBuf;

	// AfxMessageBox(buffer);
	offset = 0;
	len = nBufLen;
	offset = wwwsearchiencapsulate(contents, buffer,len, "<b>","</b>", offset);

	// (xxx/yyy)
	for(n=0;n<strlen(contents);n++)
	if(contents[n]=='/' || contents[n]==')') contents[n] = ' ';

	x = -1;
	y = -1;
	sscanf(&contents[1],"%d%d", &x,&y);


	for(n=0;n<64;n++)
	{
	entry = wwwsearchiencapsulateauto(&entry_len, buffer, len, "<tr>" ,"</tr>",&offset); // non case sensi.
	if(!entry) break;
	//entry[entry_len-1] = 0;

	{
	char *str[9];
	char *entry2;
	int entry_len2;
	int offset2;
	offset2=0;
	for(n2=0;n2<9;n2++) str[n2] = NULL;

	for(n2=0;n2<9;n2++)
		{
		entry2 = wwwsearchiencapsulateauto(&entry_len2, entry, entry_len, "<td>" ,"</td>",&offset2); // non case sensi.
		if(!entry2) break;
		str[n2] = makestring(entry2, entry_len2);
		}
	// str[0..4] = our entry
	if(n>0)
		{
		CString cstr[4];
		
		if(!str[1]) cstr[0] = "---";
		else cstr[0] = str[1];

		if(!str[2]) cstr[1] = "---";
		else cstr[1] = str[2];
		
		cstr[2] = "";
		cstr[3] = str[7];


		m_lobbySelectDlg.m_listLobbies.CreateItem(0, cstr);

		char *sstr[2];
		int lobby_idx;
		sstr[0] = str[3];
		sstr[1] = str[5];
		if(!sstr[0]) sstr[0] = "1.1.1.1";
		if(!sstr[1]) sstr[1] = ""; // no extended data.

		lobby_idx = m_gatewaylst->AddLobby(sstr[0],sstr[1]);
		lobbies++;
	
			// Extended data //
		{
		char field_type[80];
		field_type[0] = 0;
		sscanf(sstr[1],"%s",field_type);
		if(!strcmpi(field_type,"M")) mainlobby_idx = lobby_idx;
		}


		}
		
	for(n2=0;n2<9;n2++) if(str[n2]) delete str[n2]; // [F]ix was deleting !fields which is messed!
	}

	} // end outer for

	m_lobbySelectSuccess = TRUE;
	// <td>1</td><td>AlphaServe21</td><td>Alpha Server MAX 128</td><td>192.168.0.789:1703</td><td>11</td>

	// Force lobby entry //
	
	if(m_connectStyle!=CONNECTSTYLE_NORMAL) // For account creation, it automatically logs into the main lobby!, if determinable.
	{
		if(mainlobby_idx!=-1) // Main Lobby known, jump inside!
		{
		OnLobbySelect(mainlobby_idx);
		m_lobbySelectDlg.EndDialog(0);
		m_lobbySelectDlg.DestroyWindow();
		}
	}


	/*CString cstr[3];
		
	cstr[0] = "---";
	cstr[1] = "---";
	cstr[2] = "";

	m_lobbySelectDlg.m_listLobbies.CreateItem(0, cstr);

	m_gatewaylst->AddLobby("217.205.138.40:1701","X"); // 1700, 1701, 1710,1711
	lobbies++;
	*/

	if(!lobbies)
	{
	CString cstr[4];
	cstr[0] = "Error";
	cstr[1] = "No Lobbies listed";
	cstr[2] = "";
	cstr[3] = "";
	m_lobbySelectDlg.m_listLobbies.CreateItem(0, cstr);
	}
	
}

void CGameAppView::HTTPParseMCode(void *lpBuf, int nBufLen)
{
	/*char buffer[80];
	if(nBufLen)
	{

	int type_idx;

	char *type;
	type = (char *) lpBuf;

	if(!strcmpi(type,"1Year")) type_idx = MCODE_1YEAR;
	else if(!strcmpi(type,"6Months")) type_idx = MCODE_6MONTHS;
	else if(!strcmpi(type,"3Months")) type_idx = MCODE_3MONTHS;
	else if(!strcmpi(type,"Special")) type_idx = MCODE_SPECIAL;
	else type_idx = MCODE_UNDEFINED;
	}*/
}	 

void CGameAppView::HTTPSocketSessionFailed(CHTTPSocketEx *pHTTPSocket)
{	
	switch(pHTTPSocket->m_tag)
		{
			case HTTPSOCKETEXTAG_GETLOBBY:
										break;
			//case HTTPSOCKETEXTAG_MCODE:
			//						   break;
			case HTTPSOCKETEXTAG_RMANG:pHTTPSocket->m_active = FALSE; // shouldn't come in here from now on.
									   /*
									   char buffer[256];
									   GetTime();
									   sprintf(buffer,"Failed: %s - %s [%s]",pHTTPSocket->m_saveFname,
															m_stringShortTime,m_stringShortDate);
									   AddLog("LogHTTP.txt", buffer); // ### Log 
									   */
									   break;
			case HTTPSOCKETEXTAG_TOURNEY:break; // Failed
		}
}

void CGameAppView::HTTPSocketSessionEnd(void *lpBuf, int nBufLen, CHTTPSocketEx *pHTTPSocket)
{
	
	switch(pHTTPSocket->m_tag)
		{
			case HTTPSOCKETEXTAG_GETLOBBY:HTTPParseGateway(lpBuf, nBufLen);
										  break;
			//case HTTPSOCKETEXTAG_POSTLOBBY:HTTPParseGateway(lpBuf, nBufLen);
			//							  break;
			//case HTTPSOCKETEXTAG_MCODE:HTTPParseMCode(lpBuf, nBufLen);
//									   break;
			case HTTPSOCKETEXTAG_RMANG:pHTTPSocket->m_active = FALSE;
										/*
									   char buffer[256];
									   GetTime();
									   sprintf(buffer,"Completed: %s - %s [%s]",pHTTPSocket->m_saveFname,
															m_stringShortTime,m_stringShortDate);
									   AddLog("LogHTTP.txt", buffer); // ### Log 
									   */
									   break;
			case HTTPSOCKETEXTAG_TOURNEY:HTTPParseTourney(lpBuf, nBufLen);
										 break;

			case HTTPSOCKETEXTAG_NEXTEVENT:

				// char buf[256];
				// sprintf(buf, "m_tag: %d", pHTTPSocket->m_tag);
				// AfxMessageBox(buf);

				HTTPParseNextEvent(lpBuf, nBufLen);

				break;
		}
}

void CGameAppView::HTTPSocketSessionStart(int nErrorCode, CHTTPSocketEx *pHTTPSocket)
{
	switch(pHTTPSocket->m_tag)
		{
			case HTTPSOCKETEXTAG_GETLOBBY:HTTPStartGateway(nErrorCode);
										  break;
		}
}

BOOL CGameAppView::OnLobbySelect(int n)
{

	// check if the lobby is full i.e. >=127
	if(!m_gatewaylst) return 1;
	if(m_gatewaylst->m_players[n]>=127)
	{
		char _bufferx[MAX_CHARS];
		sprintf(_bufferx,"*** This lobby is full at this time, please try another lobby ***");
		AlertMessage(_bufferx);
		return 0;
	}


	CString lobbyName = _T("");
	if(m_lobbySelectSuccess)
	{
		lobbyName = m_lobbySelectDlg.m_listLobbies.GetItemText(n,1);
		g_tabSelected = 0;				// Default LobbyTV & HTML page view //
	}


	////////////////////////////////////////////////////////////////
	// i.e. selected from tab ctrl in lobby
	// Note: we must perform normal exit code to reset all
	//		 necessary variables - best way to minimise new bugs!
	if(m_lobby->m_bInLobby)
	{


		ExitFromLobby(0, TRUE);
		::ShowWindow(g_hwndDX, SW_HIDE);
		m_lobby->m_bInLobby = TRUE; // set this flag back to true - fixes render table GFX glitch. [*NEW* 26/03/04 CP]


		if(g_gameAppView)
		{
			// Destroy the Force forfit MaxTimeUp dlg if it's open!
			if(g_gameAppView->m_forfeitDlg.m_hWnd)
			if(g_gameAppView->m_forfeitDlg.IsWindowEnabled())
			if(g_gameAppView->m_forfeitDlg.m_forfeitType == 1)
			{
				g_gameAppView->m_forfeitDlg.DestroyWindow();
			}
		}
		
		// reset some key variables & sutff -> see OnPracticeStart code for more details
		m_snooker->m_bPracticeMode = TRUE;
		m_snooker->m_bComputerMode = FALSE;
		m_snooker->m_seat = 0; // force player to sit in 1P seat
		g_bMenuSelect = 0;
		m_bDisableOnDraw = 0;

		
		g_tabSelected = 0;
		m_bLobbyMode = 1;				// 1: Default Mode
		m_viewtablesButton.SetBitmap(Skin_ButtonViewTables[0]);		// 'Click Here To View Tables' button //

	}
	////////////////////////////////////////////////////////////////



	////////////////////////////////////////////////////////////////
	// normal lobby select route continues here
	
	//char buffer[80];
	char *str;
	if(!m_gatewaylst) return 1;
	str = m_gatewaylst->GetLobby(n);
	if(!str) return 1;


	if(m_lobbySelectSuccess)
	{
		g_lobbyname = lobbyName;
		//g_lobbyname = m_lobbySelectDlg.m_listLobbies.GetItemText(n,1);		
		ChangeTitle("");
		EnterLobby(m_gatewaylst->GetLobbyAddr(n),m_gatewaylst->GetLobbyPort(n));
		// EnterLobby("localhost", m_gatewaylst->GetLobbyPort(n));
	}
	////////////////////////////////////////////////////////////////

	return 1;
}

void CGameAppView::EnterLobby(char *addr, int port)
{
#ifndef MAIN_SERVER
	Mmain_log("OnInternetLobby - 1");

	g_DrawLobbyTVUpdate = TRUE;
	g_tabSelected = 0;
	m_bLobbyMode = 1;				// 0: Default Mode, Message-Board is On, 1: Playing Mode, Tables is On //
	m_viewtablesButton.SetBitmap(Skin_ButtonViewTables[0]);		// 'Click Here To View Tables' button //
	//	BP_FIX2 //
	// These must be created, at the time of entering the Lobby //
	m_detailsDlg.DestroyWindow();
	m_detailsDlg.Create(IDD_DETAILS);
	m_detailsSettingsDlg.DestroyWindow();
	m_detailsSettingsDlg.Create(IDD_DETAILSSETTINGS);

	m_kicked = 0;
	m_detailsDlg.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_detailsSettingsDlg.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	m_replayDlg.DestroyWindow(); m_bReplayMode = FALSE;
	m_bPlayOffline = FALSE;
	m_practiceEditDlg.DestroyWindow();
				
	// setup connection with main server

	BOOL success;	

	Mmain_log("OnInternetLobby - 5");

	// ASYNC //
	if(mainShell)
	{
	Mmain_log("OnInternetLobby - 5a");
	//for(int n=0;n<10;n++) // debug line (sim server crash bug for slow users?)
	success = mainShell->ConnectionASYNC(FALSE, addr, port, ASYNCSOCK_TYPE_MAIN); //**BUG***///

	}

	Mmain_log("OnInternetLobby - 7");	
	
#endif //!MAIN_SERVER
}

void CGameAppView::PostLobby(void)
{
	#ifdef MAIN_SERVER
	char buffer[MAX_CHARS];
	char *m_lobbyname;
	char *m_lobbydesc;
	char *m_lobbyip;
	char *m_lobbypass;
	char extdata[80];
	int m_lobbyport;
	int players;

	m_lobbyname = m_lobbySettings->m_name;//"SocialLounge1";
	m_lobbydesc = m_lobbySettings->m_desc;//"Social_Lounge_1";
	m_lobbyip = m_lobbySettings->m_lobbyIP;//SERVERCITY_IP;//"192.168.0.2";
	m_lobbyport = m_lobbySettings->m_lobbyPort;//1700;
	m_lobbypass = m_lobbySettings->m_pass;
	

	m_httpSocketEx->Init(m_lobbySettings->m_gatewayIP, m_lobbySettings->m_gatewayPort);
	m_httpSocketEx->m_tag = HTTPSOCKETEXTAG_POSTLOBBY;
	

	players = m_lobby->CountPlayers();

	if(!g_leader) // "S %d tagdata" or "M %d tagdata"
	{		
	if(!m_lobbySettings->m_tag[0]) sprintf(extdata,"S %d",players); // e.g. "10" = 10 players
	else sprintf(extdata,"S %d %s",players, m_lobbySettings->m_tag); // e.g. "7 $" = 7 players, leader i.e. registration goes thru & this is default selection.
	} else {
	if(!m_lobbySettings->m_tag[0]) sprintf(extdata,"M %d",players); // e.g. "10" = 10 players
	else sprintf(extdata,"M %d %s",players, m_lobbySettings->m_tag); // e.g. "7 $" = 7 players, leader i.e. registration goes thru & this is default selection.
	}

	

	if (g_build.gameType == GAMETYPE_SNOOKER)
	{
		sprintf(buffer, "netgenie_isnk/index.php?pass=%s&name=%s&desc=%s&ext=%s&ip=%s&port=%d&ver=%s&type=%s", m_lobbypass, m_lobbyname, m_lobbydesc, extdata, m_lobbyip, m_lobbyport, GAME_VERSION, "normal");
	}
	else if (g_build.gameType == GAMETYPE_POOL)
	{
		sprintf(buffer, "netgenie_ipool/index.php?pass=%s&name=%s&desc=%s&ext=%s&ip=%s&port=%d&ver=%s&type=%s", m_lobbypass, m_lobbyname, m_lobbydesc, extdata, m_lobbyip, m_lobbyport, GAME_VERSION, "normal");
	}
	else;

	

	m_httpSocketEx->Request(buffer, "", "socket.tmp");

	#endif
}




bool CGameAppView::ShowNews(void)
{
	// Display the News (if any) retrived from Server //
	
	m_NewsDlg.DestroyWindow();
	m_NewsDlg.Create(IDD_NEWSDLG);
	m_NewsDlg.LoadNews("news.txt");
	m_NewsDlg.CenterWindow();
	m_NewsDlg.ShowWindow(SW_SHOW);

	m_NewsDlg.m_text.ShowScrollBar(SB_VERT);
	m_NewsDlg.m_text.SetScrollRange(SB_VERT,0, INT_MAX);
	

	return false;
}


bool CGameAppView::ShowTerms(BOOL bIsTablCtrlWindow)
{

	// Make sure Replay is Closed if not already

	if(g_gameAppView) 
	if(g_gameAppView->m_bReplayMode) 
	{
		g_gameAppView->m_replayDlg.DestroyWindow();
		g_gameAppView->m_bReplayMode = FALSE;
		g_gameAppView->m_replay->m_bPlay = 0;
		g_gameAppView->m_snooker->m_bTurn1P = TRUE;
	}
	
	/*
	 * Skip the Terms for now.
	 * Better to have Terms on the Wesbite. So it cuts down one step for the new User getting online
	 * Also might be bad for non English speakers to have to go through Terms to play online
	 */


	

	if(g_gameAppView) g_gameAppView->ConnectToLobby(bIsTablCtrlWindow);
	/*

	m_TermsDlg.m_bIsTablCtrlWindow = bIsTablCtrlWindow;
	
	m_TermsDlg.DestroyWindow();
	m_TermsDlg.Create(IDD_TERMSDLG);
	m_TermsDlg.CenterWindow();
	m_TermsDlg.m_text.ShowScrollBar(SB_VERT);
	m_editExChat.SetScrollRange(SB_VERT,0, INT_MAX);

	m_TermsDlg.ShowWindow(SW_SHOW);
	*/


	//return;

	return false;
}





void CGameAppView::ConnectToLobby(BOOL bIsTabCtrlWindow)
{

	


	// TODO: Add your command handler code here

	m_lobbySelectSuccess = FALSE;



#ifdef LOCALTEST
	
	// m_httpSocketEx->Init(GATEWAY_IP, 1798); // Gateway address/port
	m_httpSocketEx->Init("localhost", 80); // Localtesting is on one gateway (1798)
	

////m_httpSocketEx->Init("pluto", 1780); // Localtesting is on one gateway (1798)
//	m_httpSocketEx->Init("pluto", 1781); // Localtesting is on one gateway (1798)


#else

	#ifdef THE_POOL_CLUB
	// m_httpSocketEx->Init(GATEWAY_IP, 1798); // Gateway address/port

	m_httpSocketEx->Init(GATEWAY_IP, 80); // Gateway address/port


	//m_httpSocketEx->Init("217.205.138.40", 1798); // Gateway address/port
	#else
	// m_httpSocketEx->Init(GATEWAY_IP, 80); // Gateway address/port
	// m_httpSocketEx->Init("www.thesnookerclub.com", 1799); // Gateway address/port
	// m_httpSocketEx->Init(GATEWAY_IP, 1799); // Gateway address/port
	m_httpSocketEx->Init(GATEWAY_IP, 80); // Gateway address/port
	// m_httpSocketEx->Init("209.208.71.50", 1799); // Gateway address/port
	

	
	#endif

#endif

	m_httpSocketEx->m_tag = HTTPSOCKETEXTAG_GETLOBBY;
	
	char fname_full[128];
	sprintf(fname_full, "%s%s", g_build.savepath, "socket.tmp");
	
	
	if (g_build.gameType == GAMETYPE_SNOOKER)
	{
		m_httpSocketEx->Request("netgenie_isnk/index.php", "", NULL);
	}
	else if (g_build.gameType == GAMETYPE_POOL)
	{
		m_httpSocketEx->Request("netgenie_ipool/index.php", "", NULL);
	}
	else;

	if( !bIsTabCtrlWindow )
	{
		m_lobbySelectDlg.DestroyWindow();
		m_lobbySelectDlg.Create(IDD_LOBBYSELECT);
		m_lobbySelectDlg.SetEraseBkgnd(TRUE);
		m_lobbySelectDlg.ShowWindow(SW_SHOW);
	}

	CString cstr[4];
	cstr[0] = "Searching...";
	cstr[1] = "";
	cstr[2] = "";
	cstr[3] = "";
	m_lobbySelectDlg.m_listLobbies.CreateItem(0, cstr);
		
	// Set Description Width in Lobby Seledt back to it's default 300 in size
	if(g_gameAppView->m_lobby->m_bInLobby == false)
	{
		m_lobbySelectDlg.m_listLobbies.SetColumnWidth(1, 220);
	}
	else
	{
		m_lobbySelectDlg.m_listLobbies.SetColumnWidth(1, 220);
	}


	return;


}


void CGameAppView::HTTPRequestMemberShipCode(char *code)
{
	/*#ifdef MAIN_SERVER
	char buffer[160];

	m_httpSocketEx->Init(m_lobbySettings->m_gatewayIP, m_lobbySettings->m_gatewayPort);
	m_httpSocketEx->m_tag = HTTPSOCKETEXTAG_MCODE;
			
	sprintf(buffer,"swreg.netgenie?serial=%s",code);

	m_httpSocketEx->Request(buffer, "", "socket.tmp");
	#endif*/
}

void CGameAppView::OnInternetLobby() 
{	
	// Bring up 'Terms of Use' Dialog. This dialog also 


	m_connectStyle = CONNECTSTYLE_NORMAL;
	ShowTerms(); // This Function Calls up ConnectToLobby if User Agrees with Terms - ConnectToLobby(TRUE);

}

// "Incorrect login! (0)" -> "Account 'UserName' doesn't exist! Click 'OK' to try again. (0)"
// "Incorrect login! (1)" -> "Wrong Password (1)"
// "Incorrect login! (2)" -> "Already Logged In (2)"

// "Couldn't Connect to server![1]" -> "New Version Available!\r\n(Download NOW!). [1]"
// "Couldn't Connect to server![3]"
// "Couldn't Connect to server![4]" -> "Couldn't connect to lobby!!!\r\nLobby Possibly down.\r\nTry an alternative lobby or try again later. [4]"


void CGameAppView::LoginFailed(char failType)
{


	char buffer[256];
	int i;
	OnInternetExit();
	
	switch(failType)
	{
		case 0://incorrect "login name" <-- Note: not sued anymore!
			//sprintf(buffer,"Incorrect login! (0)");
			//MessageBox(buffer, g_appName);

			AlertLoginMessage("Incorrect login! (0)"); // should be obsolete now
			break;
		case 1://incorrect "password" for "login name"						
			//sprintf(buffer,"Wrong Password (1)");
			//MessageBox(buffer, g_appName);

				// show login wizard dialogue
			//if(m_bDoneADraw && !m_loginWizardDlg.m_bActive)
			//if(g_gfxDetails.bShowLoginWizard)
			{
				Mmain_log("m_loginWizardDlg.DoModal");
				
				m_loginWizardDlg.m_bActive = TRUE;
				m_loginWizardDlg.CopyPlayerLoginDetails();
				//m_loginWizardDlg.DoModal();
				if(g_build.gameType == GAMETYPE_SNOOKER) 
					{
					m_loginWizardDlg.DestroyWindow();
					m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG2);
					}
				else if(g_build.gameType == GAMETYPE_POOL) 
					{
					m_loginWizardDlg.DestroyWindow();
					m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG3);
					}
				m_loginWizardDlg.ShowWindow(SW_SHOW);
			}

			AlertLoginMessage("Wrong Password (1)");
			break;
		case 2:// this "login name" has already logged in			
			//sprintf(buffer,"Already Logged In (2)");
			//MessageBox(buffer, g_appName);

				// show login wizard dialogue
			//if(m_bDoneADraw && !m_loginWizardDlg.m_bActive)
			//if(g_gfxDetails.bShowLoginWizard)
			{
				Mmain_log("m_loginWizardDlg.DoModal");
				
				m_loginWizardDlg.m_bActive = TRUE;
				m_loginWizardDlg.CopyPlayerLoginDetails();
				//m_loginWizardDlg.DoModal();
				if(g_build.gameType == GAMETYPE_SNOOKER) m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG2);
				else if(g_build.gameType == GAMETYPE_POOL) m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG3);
				m_loginWizardDlg.ShowWindow(SW_SHOW);
			}			

			AlertLoginMessage("Already Logged In (2)");
			break;
		case 9:// incorrect version/crc messed up!!!
			MessageBox("Incorrect version! (Bad CRC)", g_appName);//\r\nGo to www.thesnookerclub.com");
			if(g_build.gameType == GAMETYPE_SNOOKER)
				{
				char dbuf[128];
				sprintf(dbuf, "http://www.thesnookerclub.com/index2.php?mainframe=dls.html&ver=%s", GAME_VERSION);
				ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T(dbuf),_T(""),NULL,0);
				}
			else if(g_build.gameType == GAMETYPE_POOL)
				{
				char dbuf[128];
				sprintf(dbuf, "http://www.thepoolclub.com/index2.php?mainframe=dls.html&ver=%s", GAME_VERSION);
				ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T(dbuf),_T(""),NULL,0);
				}
			AfxGetMainWnd()->DestroyWindow();
			break;		   
		case 10:// new version available (Download NOW)!!!
			//PostMessage((AfxGetMainWnd()->m_hWnd), WM_CLOSE, NULL, NULL); 
			
			//AfxGetMainWnd()->DestroyWindow();
			MessageBox("New Version Available!\r\n(Download NOW!)", g_appName);//\r\nGo to www.thesnookerclub.com");
			if(g_build.gameType == GAMETYPE_SNOOKER)
				{
				char dbuf[128];
				sprintf(dbuf, "http://www.thesnookerclub.com/index2.php?mainframe=dls.html&ver=%s", GAME_VERSION);
				//ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thesnookerclub.com/index2.php?mainframe=patch.html"),_T(""),NULL,0);
				ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T(dbuf),_T(""),NULL,0);
				}
			else if(g_build.gameType == GAMETYPE_POOL)
				{
				char dbuf[128];
				sprintf(dbuf, "http://www.thepoolclub.com/index2.php?mainframe=dls.html&ver=%s", GAME_VERSION);
				ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T(dbuf),_T(""),NULL,0);
				}
			



			// Clean up Shells before we Destroy Window so no Crashing :)
			if(gameShell) 
			{
				if(gameShell->Client)
					gameShell->Client->Close();

				if(gameShell->Server)
					gameShell->Server->Close();

				delete gameShell;
				gameShell = NULL;
			}

			if(mainShell) 
			{
				if(mainShell->Client)
					mainShell->Client->Close();

				if(mainShell->Server)
					mainShell->Server->Close();

				delete mainShell;
				mainShell = NULL;
			}
	

			AfxGetMainWnd()->DestroyWindow();
			break;		   
		case 11:// this account has been banned!!!
			if(g_build.gameType == GAMETYPE_SNOOKER)
				AlertMessage("This account has been banned\r\nPlease contact support@thesnookerclub.com");
			else if(g_build.gameType == GAMETYPE_POOL)
				AlertMessage("This account has been banned\r\nPlease contact support@thepoolclub.com");
			break;
		case 12:// incorrect login details - take u back to wizard.
			//sprintf(buffer,"Account %s doesn't exist!\r\nClick 'OK' to try again. (0)",m_detailsDlg.m_name.GetBuffer(0));
			//MessageBox(buffer, g_appName);

			// show login wizard dialogue
			//if(m_bDoneADraw && !m_loginWizardDlg.m_bActive)
			//if(g_gfxDetails.bShowLoginWizard)
			{
				Mmain_log("m_loginWizardDlg.DoModal");
				
				m_loginWizardDlg.m_bActive = TRUE;
				m_loginWizardDlg.CopyPlayerLoginDetails();
				//m_loginWizardDlg.DoModal();
				if(m_loginWizardDlg.m_hWnd) m_loginWizardDlg.DestroyWindow();
				if(g_build.gameType == GAMETYPE_SNOOKER) m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG2);
				else if(g_build.gameType == GAMETYPE_POOL) m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG3);
				m_loginWizardDlg.ShowWindow(SW_SHOW);
			}

			sprintf(buffer,"Account %s doesn't exist!\r\nClick 'OK' to try again. (0)",m_detailsDlg.m_name.GetBuffer(0));
			AlertLoginMessage(buffer);
			break;
		case 13://incorrect "login name" <-- Note: not sued anymore!
			//sprintf(buffer,"Incorrect login! (0)");
			//MessageBox(buffer, g_appName);

			AlertLoginMessage("Lobby Full"); // should be obsolete now
			break;
		case 14:
			AlertLoginMessage("Trial account can only log in\r\nfrom the computer originally created on"); // should be obsolete now
			break;
		case 15:
			//Account Not Activated
			{
				Mmain_log("m_loginWizardDlg.DoModal");
				
				m_loginWizardDlg.m_bActive = TRUE;
				m_loginWizardDlg.CopyPlayerLoginDetails();
				//m_loginWizardDlg.DoModal();
				if(g_build.gameType == GAMETYPE_SNOOKER) 
					{
					m_loginWizardDlg.DestroyWindow();
					m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG2);
					}
				else if(g_build.gameType == GAMETYPE_POOL) 
					{
					m_loginWizardDlg.DestroyWindow();
					m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG3);
					}
				m_loginWizardDlg.ShowWindow(SW_SHOW);
			}

			
			AlertLoginMessage("Account not activated. Please check your e-mail and activate the account!"); // should be obsolete now
			
			break;
		default:i = failType;
				if(i==15) sprintf(buffer,"Login failed - Guests can only access 'Guest Lobbies'",i);
					else sprintf(buffer,"Login failed (%d)",i);
				AlertLoginMessage(buffer); // should be obsolete now
				break;
	}
}

/*
void CGameAppView::AccountCreated(char failType)
{
	switch(failType)
	{
			case 0:	// Created Account, so login again with this account :)
			case 3: // Topped Up Account
			{
				char buffer[MAX_CHARS];

				if(failType==3) sprintf(buffer,"Account '%s' successfully topped up\r\nClick Ok to proceed to lobby.", m_newAccountDataRemember.m_name);
				else sprintf(buffer,"Account '%s' successfully created\r\nClick Ok to proceed to lobby.", m_newAccountDataRemember.m_name);
				MessageBox(buffer, g_appName);
			
				m_details.m_name = m_newAccountDataRemember.m_name;
				m_details.m_password = m_newAccountDataRemember.m_password;
				SaveDetailsFile("MyDetails.txt", &m_details);

				m_detailsDlg.m_name = m_newAccountDataRemember.m_name;
				m_detailsDlg.m_password = m_newAccountDataRemember.m_password;

			// get player's (client) local IP (LAN name)
			CString playerLocalIP;
			playerLocalIP = mainShell->GetHostIPAddress(CShellEx::LOCAL_HOST_IP);

			Player plr;
			m_lobby->ClearPlayer(&plr);
			//memset(&plr, 0, sizeof(Player_typ));
			strcpy(plr.name, m_detailsDlg.m_name.GetBuffer(0));
			strcpy(plr.password, m_detailsDlg.m_password.GetBuffer(0));
			plr.playerIP[0] = 0;
			strcpy(plr.playerLocalIP, playerLocalIP.GetBuffer(0));
			plr.playerPort = m_detailsSettingsDlg.m_myPort;
			plr.playerSocketIdx = m_rememberPlayerSocketIdx;//idxdata->idx;
											
			SendPlayerDetailsConnect2(FALSE, &plr, -1, 0); // connect to server again!
			}
			break;
		case 1: // Failed to Create account (name already exists)
			{
			OnInternetExit();
			char buffer[MAX_CHARS];
			if(m_connectStyle==CONNECTSTYLE_TOPUP)
			{
			sprintf(buffer,"Account name '%s' doesn't exist, therefore cannot be topped up", m_newAccountDataRemember.m_name);
			}
			else sprintf(buffer,"Account name '%s' already exists, please choose a different name", m_newAccountDataRemember.m_name);
			MessageBox(buffer, g_appName);
			}
			break;
		case 2: // Failed to Create account (invalid membership code)
			{
			OnInternetExit();
			char buffer[MAX_CHARS];

			sprintf(buffer,"Membership code '%s' is invalid", m_newAccountDataRemember.m_mCode);
			MessageBox(buffer, g_appName);
			}
			break;
		case 4: // Can't create more than 3 accounts within 8 hours (Cool down)
			{
			OnInternetExit();
			char buffer[MAX_CHARS];

			sprintf(buffer,"You have created too many accounts, please try again later.");
			MessageBox(buffer, g_appName);
			}
			break;
		case 5: // Can only create one account on this machine.
			{
			OnInternetExit();
			char buffer[MAX_CHARS];

			sprintf(buffer,"You have already created a free trial account on this computer.");
			MessageBox(buffer, g_appName);
			}
			break;
	}
}
*/

void CGameAppView::AccountCreated(char failType)
{

	
	switch(failType)
	{
			case 0:	// Created Account, so login again with this account :)
			case 3: // Topped Up Account
			{
				/*
				// In Windows Vista we no longer can write to System32 / System Folders, so we'll have to find a new method //
				// Cannot write to the Registry Either, since we need to be in Administrator Mode.. Microsoft sure don't make life
				// easy with each new version of windows..... hmmmmmmmmmm //



				// Impregnate the System if This is a Trial account //
				if(G_Trialist_Flag)
					{
					
					// iPool Must use different files to iSnooker //

					if(g_build.gameType == GAMETYPE_POOL)
						{
						// New Account Created, So Impregnate the System //
						// Impregnate the Users System with 2 Tracking Files //
						FILE *fptr;
						fptr = fopen("C:\\windows\\system32\\kbxbvcd.dll", "wb");
						if(fptr)
							{
							fprintf(fptr, "MZ!This program cannot be run in DOS mode.");
							fclose(fptr);
							}
						fptr = fopen("C:\\windows\\system\\multskc.tsk", "wb");
						if(fptr)
							{
							fprintf(fptr, "MZ!This program requires Microsoft Windows.");
							fclose(fptr);
							}
						}
					else{
						// New Account Created, So Impregnate the System //
						// Impregnate the Users System with 2 Tracking Files //
						FILE *fptr;
						fptr = fopen("C:\\windows\\system32\\kbpxvcd.dll", "wb");
						if(fptr)
							{
							fprintf(fptr, "MZ!This program cannot be run in DOS mode.");
							fclose(fptr);
							}
						fptr = fopen("C:\\windows\\system\\multsp.tsk", "wb");
						if(fptr)
							{
							fprintf(fptr, "MZ!This program requires Microsoft Windows.");
							fclose(fptr);
							}
						}
						//////////////////////////////////////////////////////
					}
				*/


				char buffer[MAX_CHARS];

				if(failType==3) sprintf(buffer,"Account '%s' successfully topped up\r\nClick Ok to proceed to lobby.", m_newAccountDataRemember.m_name);
				else{
					if(!G_Trialist_Flag) sprintf(buffer,"Account '%s' successfully created\r\nClick Ok to proceed to lobby.", m_newAccountDataRemember.m_name);
					else{

						char gamebuf[32];
						if(g_build.gameType == GAMETYPE_SNOOKER) sprintf(gamebuf, "iSnooker");
							else sprintf(gamebuf, "iPool");
							
						sprintf(buffer,"Trial Account '%s' successfully created. \r\nYou agree not to use this Trial Account if you've had a Trial or Registered account within the last 6 Months on %s. Failing to meet this requirement may result in a ban. Click Ok to proceed to lobby & Enjoy your games!", m_newAccountDataRemember.m_name, gamebuf);

						}
					}
				MessageBox(buffer, g_appName);
			
				m_details.m_version = _T("1.01");
				m_details.m_name = m_newAccountDataRemember.m_name;
				m_details.m_password = ENCRYPT_STR(m_newAccountDataRemember.m_password);
				if(g_RememberPassword) m_details.m_bpass = _T("SAVE");
					else m_details.m_bpass = _T("");
				SaveDetailsFile("MyDetails.txt", &m_details);

				m_detailsDlg.m_name = m_newAccountDataRemember.m_name;
				m_detailsDlg.m_password = m_newAccountDataRemember.m_password;
				
			// get player's (client) local IP (LAN name)
			CString playerLocalIP;
			playerLocalIP = mainShell->GetHostIPAddress(CShellEx::LOCAL_HOST_IP);

			Player plr;
			m_lobby->ClearPlayer(&plr);
			//memset(&plr, 0, sizeof(Player_typ));
			strcpy(plr.name, m_detailsDlg.m_name.GetBuffer(0));
			strcpy(plr.password, m_detailsDlg.m_password.GetBuffer(0));
			plr.playerIP[0] = 0;
			strcpy(plr.playerLocalIP, playerLocalIP.GetBuffer(0));
			plr.playerPort = m_detailsSettingsDlg.m_myPort;
			plr.playerSocketIdx = m_rememberPlayerSocketIdx;//idxdata->idx;
											
			SendPlayerDetailsConnect2(FALSE, &plr, -1, 0); // connect to server again!
			}
			break;
		case 1: // Failed to Create account (name already exists)
			{
			OnInternetExit();
			char buffer[MAX_CHARS];
			if(m_connectStyle==CONNECTSTYLE_TOPUP)
			{
			sprintf(buffer,"Account name '%s' doesn't exist, therefore cannot be topped up", m_newAccountDataRemember.m_name);
			}
			else sprintf(buffer,"Account name '%s' already exists, please choose a different name", m_newAccountDataRemember.m_name);
			MessageBox(buffer, g_appName);
			}

			if(g_build.gameType == GAMETYPE_SNOOKER) 
				{
				m_loginWizardDlg.DestroyWindow();
				m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG2);
				}
			else if(g_build.gameType == GAMETYPE_POOL) 
				{
				m_loginWizardDlg.DestroyWindow();
				m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG3);
				}
			m_loginWizardDlg.ShowWindow(SW_SHOW);

			break;
		case 2: // Failed to Create account (invalid membership code)
			{
			OnInternetExit();
			char buffer[MAX_CHARS];

			sprintf(buffer,"Membership code '%s' is invalid", m_newAccountDataRemember.m_mCode);
			MessageBox(buffer, g_appName);
			}

			if(g_build.gameType == GAMETYPE_SNOOKER) 
				{
				m_loginWizardDlg.DestroyWindow();
				m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG2);
				}
			else if(g_build.gameType == GAMETYPE_POOL) 
				{
				m_loginWizardDlg.DestroyWindow();
				m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG3);
				}
			m_loginWizardDlg.ShowWindow(SW_SHOW);


			break;
		case 4: // Can't create more than 3 accounts within 8 hours (Cool down)
			{
			OnInternetExit();
			char buffer[MAX_CHARS];

			sprintf(buffer,"You have created too many accounts, please try again later.");
			MessageBox(buffer, g_appName);
			}
			break;
		case 5: // Can only create one account on this machine.
			{
			OnInternetExit();
			char buffer[MAX_CHARS];
			//sprintf(buffer,"You have already created a free trial account on this computer.");
			if(g_build.gameType == GAMETYPE_POOL) sprintf(buffer,"Cannot create another free Trial account on this computer. If you have not created a Trial account before, please contact support@thepoolclub.com. Please purchase a Membership Code (see 'Register' Top Menu) or login with Username: Guest.");
			else sprintf(buffer,"Cannot create another free Trial account on this computer. If you have not created a Trial account before, please contact support@thesnooker.com. Please purchase a Membership Code (see 'Register' Top Menu) or login with Username: Guest.");
			MessageBox(buffer, g_appName);
			}
			break;
		case 6: // Failed to Create account (Incorrect Username / Password)
			{
			OnInternetExit();
			char buffer[MAX_CHARS];
			if(m_connectStyle==CONNECTSTYLE_TOPUP)
			{
			sprintf(buffer,"Incorrect Username / Password, cannot top-up");
			}
			else sprintf(buffer,"Incorrect Username / Password, cannot top-up");
			MessageBox(buffer, g_appName);
			}
			
			if(g_build.gameType == GAMETYPE_SNOOKER) 
				{
				m_loginWizardDlg.DestroyWindow();
				m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG2);
				}
			else if(g_build.gameType == GAMETYPE_POOL) 
				{
				m_loginWizardDlg.DestroyWindow();
				m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG3);
				}
			m_loginWizardDlg.ShowWindow(SW_SHOW);


			break;
		case 7: // Your Username must not contact the Following Symbols
			{
			OnInternetExit();
			char buffer[MAX_CHARS];
			sprintf(buffer,"The Username you have entered contains Invalid Characters. Please try again.");
			MessageBox(buffer, g_appName);

			if(g_build.gameType == GAMETYPE_SNOOKER) 
				{
				m_loginWizardDlg.DestroyWindow();
				m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG2);
				}
			else if(g_build.gameType == GAMETYPE_POOL) 
				{
				m_loginWizardDlg.DestroyWindow();
				m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG3);
				}
			m_loginWizardDlg.ShowWindow(SW_SHOW);


			break;
			}
		case 8: // Invalid Referrer
			{
			OnInternetExit();
			char buffer[MAX_CHARS];
			sprintf(buffer,"Referrer is not valid. Please enter a valid Member Username or leave this field Empty to proceed. Please try again.");
			MessageBox(buffer, g_appName);


			if(g_build.gameType == GAMETYPE_SNOOKER) 
				{
				m_loginWizardDlg.DestroyWindow();
				m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG2);
				}
			else if(g_build.gameType == GAMETYPE_POOL) 
				{
				m_loginWizardDlg.DestroyWindow();
				m_loginWizardDlg.Create(IDD_LOGINWIZARDDLG3);
				}
			m_loginWizardDlg.ShowWindow(SW_SHOW);

			}
			break;
	}
}

char NameInValid(char *str)
{ // returns first invalid character if exists.
	int n;
	BOOL status;
	for(n=0;n<256;n++)
	if(!str[n]) break;
	else {
	status = FALSE;
	// Valid characters: a-z, A-Z, 0-9
	if(str[n]>='a' && str[n]<='z') status = TRUE;
	else if(str[n]>='A' && str[n]<='Z') status = TRUE;
	else if(str[n]>='0' && str[n]<='9') status = TRUE;
	else switch(str[n])
		{
		case ',':
		case '.':
		case '_':
		case '-':
		case '(':
		case ')':
		case '[':
		case ']':
		case '{':
		case '}':
		case '@':
		case '~':
				 status = TRUE;
				 break;
		}
	// 33 ---- 47
	// !"#$%&'()*+,-./
	// removed <> due to windows bug
	// Windows hates the chars: \/:*?"<>|
	if(status==FALSE) return str[n];
	}
	return 0;
}

void CGameAppView::LoginNewAccount(int timetoexp, BYTE ext)
{ // [+] Add code to say "Revive existing (Expired) account"


	CNewAccountDlg newaccountdlg;
	char c;
	newaccountdlg.m_name = m_detailsDlg.m_name;//.GetBuffer(0)

	if(m_connectStyle==CONNECTSTYLE_NEWACC)
	newaccountdlg.SetTitle("Create new account");
	else if(m_connectStyle==CONNECTSTYLE_TOPUP)
	newaccountdlg.SetTitle("Top up existing account");

	if(ext) {
			newaccountdlg.SetTitle("Create new account (FREE)");
			newaccountdlg.m_mCode = "Unrequired";
			newaccountdlg.SetProps(FALSE);
			}
	
	if(timetoexp!=1)
		{
		char buffer[256];
		sprintf(buffer,"This account expired %d day(s) ago\r\nYou have %d day(s) before this account will be permanently deleted", -timetoexp,DAYSTOKEEPACCOUNT+timetoexp);
		MessageBox(buffer, g_appName);
		newaccountdlg.SetTitle("Revive account");
		}
	retry:
	if(newaccountdlg.DoModal()==IDOK)
	{
	/////////////// [-] remove this debug!
/*	// m_FindOutIdx = -1, if user doesn't select an item from combo box
	char buff[80];
	sprintf(buff, "idx = %d, str = %s", newaccountdlg.m_FindOutIdx, newaccountdlg.m_FindOutStr.GetBuffer(0));
	///////////////
*/
	if(newaccountdlg.m_name.IsEmpty() || 
		newaccountdlg.m_password.IsEmpty() || 
		newaccountdlg.m_password2.IsEmpty() ||
		newaccountdlg.m_email.IsEmpty()	)
		{
		//MessageBox("All fields are required", g_appName);
		MessageBox("Name, Password & Email fields are required", g_appName);
		goto retry;
		}
	if(!strcmpi(newaccountdlg.m_name, newaccountdlg.m_referer))
	{
	MessageBox("Username & Referer Name fields cannot be the same!", g_appName);
	goto retry;
	}

	// Check if referrer contains valid characters //
	c = NameInValid(newaccountdlg.m_referer.GetBuffer(0));
	if(!c);
	else{
		char buffer[MAX_CHARS];
		if(c==32) sprintf(buffer,"Bad Referrer Name\r\nNames cannot contain spaces");
		else sprintf(buffer,"Bad Referrer Name\r\nNames cannot contain the character '%c'",c);
		MessageBox(buffer, g_appName);
		goto retry;
		}



	c = NameInValid(newaccountdlg.m_name.GetBuffer(0));
	if(!c); // allow it, string is valid
	else 
		{
		char buffer[MAX_CHARS];
		if(c==32) sprintf(buffer,"Bad Username\r\nUsernames cannot contain spaces");
		else sprintf(buffer,"Bad Username\r\nUsernames cannot contain the character '%c'",c);

		MessageBox(buffer, g_appName);
		goto retry;
		}

	
	if(!strcmp(newaccountdlg.m_password.GetBuffer(0),newaccountdlg.m_password2.GetBuffer(0)))
		{

		newAccountSendData newAccountData;

		newAccountData.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
		newAccountData.buffer[1] = 67;			// MSGGAME_SENDNEWACCOUNT
		newAccountData.buffer[2] = m_connectStyle;
		newAccountData.buffer[3] = 0;

		// [+] Need checking for length of these params, don't wanna mash up the buffer!!
		strcpy(newAccountData.m_name, newaccountdlg.m_name.GetBuffer(0));
		strcpy(newAccountData.m_password, newaccountdlg.m_password.GetBuffer(0));
		strcpy(newAccountData.m_mCode, newaccountdlg.m_mCode.GetBuffer(0));
		
	if(newAccountData.m_mCode[0]==0) // trialist account (blank member code)
		{
		
		G_Trialist_Flag = 1; // Set Globat Trialist Flag
			
		

		// Check Impregnation Files first.. If they exist, then this is a multi-Trial user //
		// Can't do this because Windows Doesn't allow writing to System / System32 folders... GRR Microsoft //
		newAccountData.MultiTrialist = 0;
		
		/*
		if(g_build.gameType == GAMETYPE_POOL)
			{
			if( (fptr = fopen("C:\\windows\\system32\\kbxbvcd.dll", "r")))
				{
				newAccountData.MultiTrialist=1; // iPool -> Set MultiTrialist Flag to True
				fclose(fptr);
				}
			if( (fptr = fopen("C:\\windows\\system\\multskc.tsk", "r")) )
				{
				newAccountData.MultiTrialist=1; // iPool -> Set MultiTrialist Flag to True
				fclose(fptr);
				}
			}	
		else{
			if( (fptr = fopen("C:\\windows\\system32\\kbpxvcd.dll", "r")))
				{
				newAccountData.MultiTrialist=1; // iSnooker -> Set MultiTrialist Flag to True
				fclose(fptr);
				}
			if( (fptr = fopen("C:\\windows\\system\\multsp.tsk", "r")) )
				{
				newAccountData.MultiTrialist=1; // iSnooker -> Set MultiTrialist Flag to True
				fclose(fptr);
				}
			}
		*/
		}
	else G_Trialist_Flag = 0;



		newAccountData.m_sysID = g_sysID;
		newAccountData.m_cpuID = g_cpuID;
		newAccountData.m_macID_U = g_macID_U;
		newAccountData.m_macID_L = g_macID_L;
		
		strcpy(newAccountData.m_email, newaccountdlg.m_email.GetBuffer(0));
		strcpy(newAccountData.m_mReferer, newaccountdlg.m_referer.GetBuffer(0));

		if(newaccountdlg.m_FindOutIdx==-1) newAccountData.m_mHearAbout[0] = 0; // nothing in the string.
		else strcpy(newAccountData.m_mHearAbout, newaccountdlg.m_FindOutStr.GetBuffer(0)); // make sure that field is 80 max.

		memcpy(&m_newAccountDataRemember, &newAccountData, sizeof(newAccountSendData_typ));

		if(mainShell)
		{
			mainShell->Client->SendToQueue((void *)&newAccountData, sizeof(newAccountSendData_typ));
		}

		}
	else {
		 MessageBox("Password fields are not the same!!!", g_appName);
		 newaccountdlg.m_password = _T("");
		 newaccountdlg.m_password2 = _T("");
		 goto retry;
		}


	}
	else { // Cancel
	OnInternetExit();
	}

	//MessageBox("Create New Account!", g_appName);
}



void CGameAppView::ExitFromLobby(int disc, BOOL bIsTabCtrlWindow)
{ // [+] Later on, if you get disconnected from the server, you can still play- just get notified!

	

	#ifndef MAIN_SERVER


	if(!m_lobby->m_bInLobby) // if you're inside a game.
	DestroyGameShell();

	// TODO: Add your command handler code here
	g_ballRadiusFactor = 1.0f;
	#ifdef THE_POOL_CLUB
	g_ballRadius = 28.4625f * g_ballRadiusFactor;
	#else // iSnooker
	g_ballRadius = 26.09f * g_ballRadiusFactor;
	#endif

	m_snooker->m_customTable->ReNormalizeBalls();
	m_snooker->m_wildRackType = 0; // no WILD table rack types (default)

	// make sure we are now back with the default pool table (after lobby exit)
	if(g_build.gameType == GAMETYPE_POOL)
	{
		// un-check pro table menu option
		CMenu *subMenu = AfxGetMainWnd()->GetMenu()->GetSubMenu(PRACTICE_MENU);
		subMenu->CheckMenuItem(POOL_PRACTICE_PROTABLE, MF_UNCHECKED | MF_BYPOSITION);

		// switch back to normal table
		if(m_snooker->m_M3d_Table_ptr != &m_snooker->m_customTable->m_M3d_Table)
		m_snooker->m_customTable->PoolTableChange(&m_snooker->m_customTable->m_M3d_Table);
	}
	else
	{
		if(m_snooker->m_M3d_Table_ptr != &m_snooker->m_customTable->m_M3d_Table)
		m_snooker->m_customTable->SnookerTableChange(&m_snooker->m_customTable->m_M3d_Table);
	}

	g_lobbyname = "";
	ChangeTitle("");
	
	// clear out all the text in the chat window
	DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1

	m_editExChat.SetSel(ss,FALSE);
	m_editExChat.ReplaceSel(_T(""));
	//m_editExChat.Clear(); // Beep
	m_sendEdit.SetSel(ss,FALSE);
	m_sendEdit.ReplaceSel(_T(""));
	//m_sendEdit.Clear(); // Beep

	//////////////////////////////////////
	
	// g_bOriginalVersion = FALSE; // For now, when you exit Lobby, put the game back to current version difficulty.
	g_bTournamentLobby = FALSE; // NEW:26/FEB/2004 (BUGFIX, for when traversing lobbies)
	// from EnableSeats(..) code - make sure seats and stand buttons are actice when traversing back to normal lobbies
	m_sit1PButton.EnableWindow(TRUE);
	m_sit2PButton.EnableWindow(TRUE);
	m_sit1PButton.SetState(TRUE);
	m_sit2PButton.SetState(TRUE);

	m_sit1PButton.m_name[0] = 0;
	m_sit2PButton.m_name[0] = 0;
	// 
	m_standButton.EnableWindow(TRUE);
	m_standButtonEnabled = TRUE;

	m_sit1PButtonB.EnableWindow(TRUE);
	m_sit2PButtonB.EnableWindow(TRUE);
	m_sit1PButtonB.SetState(TRUE);
	m_sit2PButtonB.SetState(TRUE);

	m_sit1PButtonB.m_name[0] = 0;
	m_sit2PButtonB.m_name[0] = 0;
	//////////////////////////////////////

	


	::ShowWindow(g_hwndDX, SW_SHOW);
	m_lobby->m_bInLobby = FALSE;
	
	m_snooker->m_bComputerMode = TRUE;
	

	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	
	
	
	m_bJustExitedLobby = TRUE;
	
	

	//m_cueErrorBox.EnableWindow(TRUE);
	m_tableTypeBox.EnableWindow(FALSE);



	// Hide Ticker Board and Banner URL
	m_htmlViewTickerBoard.Navigate2("209.208.71.50", NULL, NULL);
	m_htmlViewBanner.Navigate2("209.208.71.50",NULL,NULL);

	m_htmlViewTickerBoard.ShowWindow(SW_HIDE);
	m_htmlViewBanner.ShowWindow(SW_HIDE);


	//BP_FIX4
	// This was bad to have, since we use this code when joining / rejoin lobby from lobbyselect it would seem
	// Dlg's were getting destroyed that need to remain created //
	/*
	m_statsTabCtrlDlg.DestroyWindow();
	m_statsChatDlg.DestroyWindow();
	m_lobbySelectDlg.DestroyWindow();
	*/

	{
	for(int n=0;n<MAX_INVITATIONDLGS;n++)  // NEW:26/FEB/2004 (BUGFIX, for when traversing lobbies)
		m_invitationDlg[n].DestroyWindow();
	}

	if(!bIsTabCtrlWindow) RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);

	PreviousWndEditSetFocus();
	
	FreeMouse(); // give mouse visibilty and clickability back.

	//--m_snooker->Init();

	

	if(mainShell) 
	{
		//mainShell->Server->Close();
		mainShell->Client->Close();
		if(mainShell) {
			delete mainShell;
			mainShell = NULL;
		}
	}

	
		
	// Main Shell - Main Server communication (Lobby Room Hosted by the 'ONE' SERVER)
	mainShell = new CShellEx(TRUE);
	mainShell->AttachComm(SHELL_SERVER, new CComm(MAX_LOBBY_PLAYERS, SEND_QUEUE_SIZE)); // also sets max profile capacity. which is used for both clients & servers.
	mainShell->AttachComm(SHELL_CLIENT, new CComm(1, SEND_QUEUE_SIZE));

	
	// Game Shell - Game Server communication (Game Room Hosted by a client in Lobby Room)
	//CreateGameShell();
		
	// init main shell network module
	mainShell->Init(this,2); // pass over hwnd
	//mainShell->CreateSeat(0,0+4,200);
	//mainShell->CreateSeat(1,400+4,400);
	//mainShell->CreateStand(100, &m_standButton); 
	//mainShell->AttachNameList(&m_listBox);
	//mainShell->DisplayConnection();
		
	
	m_listPlayers.DeleteAllItems();
	m_listPlayers.m_totalItems = 0;
	m_listPlayers.Invalidate();
	//m_listTables.DeleteAllItems();
	//m_listTables.m_totalItems = 0;
	//m_listTables.m_totalButtons = 0;
	m_lobby->ClearAllTableItems(); // don't really need this line anymore (code below should do)

	//////////////////////////////////////
	// Delete all items and re-create them
	CString items[6];
	items[1].Format("");
	items[2].Format("");
	items[3].Format(""); // P1
	items[4].Format(""); // P2
	items[5].Format(""); // Watcher
	m_listTables.DeleteAllItems();
	m_listTables.m_totalItems = 0;
	m_listTables.SetMaxItems(MAX_TABLEITEMS);
	for(int i=0;i<MAX_TABLEITEMS;i++)
	{
		items[0].Format("#%d", i+1);
		m_listTables.CreateTableItem(i, items, "Options:");//optionsStr);
	}
	//////////////////////////////////////
	
	// initialise lobby object
	m_lobby->Init();

	// reasons for being disconnect
	if(disc)
	{
		if(m_kicked==1)
		{
			if(!m_kreason[0])
				MessageBox("You were kicked by a moderator", g_appName);
			else
			{
				char str[256];
				sprintf(str,"You were kicked by a moderator for:\r\n%s", m_kreason);
				MessageBox(str, g_appName);
			}
		}
		else if(m_kicked==2)
		{
			if(!m_kreason[0])
				MessageBox("You were banned by a moderator", g_appName);
			else
			{
				char str[256];
				sprintf(str,"You were banned by a moderator for:\r\n%s", m_kreason);
				MessageBox(str, g_appName);
			}
		}
		else if(m_kicked==3)
		{
			if(!m_kreason[0])
				if(g_build.gameType == GAMETYPE_POOL) MessageBox("You have been walled. please contact support@thepoolclub.com", g_appName);
					else MessageBox("You have been walled. please contact support@thesnookerclub.com", g_appName);
			else
			{
				char str[256];
				sprintf(str,"You have been walled by a moderator for:\r\n%s\r\nplease contact support", m_kreason);
				MessageBox(str, g_appName);
			}
		}
		else if(m_kicked==4)
		{
			if(!m_kreason[0])
				if(g_build.gameType == GAMETYPE_POOL) MessageBox("You have been denied. please contact support@thepoolclub.com", g_appName);
					else MessageBox("You have been denied. please contact support@thesnookerclub.com", g_appName);
			else
			{
				char str[256];
				sprintf(str,"You have been walled by a moderator for:\r\n%s\r\nplease contact support", m_kreason);
				MessageBox(str, g_appName);
			}
		}
		else if(m_kicked==5)
		{
			if(!m_kreason[0])
				if(g_build.gameType == GAMETYPE_POOL) MessageBox("You have been blocked. please contact support@thepoolclub.com", g_appName);
					else MessageBox("You have been blocked. please contact support@thesnookerclub.com", g_appName);
			else
			{
				char str[256];
				sprintf(str,"You have been walled by a moderator for:\r\n%s\r\nplease contact support", m_kreason);
				MessageBox(str, g_appName);
			}
		}

		
		else if(m_kicked==6)
		{
			if(g_build.gameType == GAMETYPE_POOL) MessageBox("Your account is being accessed/you have been disconnected.\r\nIf you haven't allowed another person to use your account then please contact support@thepoolclub.com", g_appName);
				else MessageBox("Your account is being accessed/you have been disconnected.\r\nIf you haven't allowed another person to use your account then please contact support@thesnookerclub.com", g_appName);
		}

		else
		{
			if(m_playerSockIdx!=-1)
				MessageBox("You were disconnected\r\nfrom the Server\r\nLobby Possibly down\r\nTry an alternative lobby or try again later.", g_appName);			
			else
			{
				//char _bufferx[MAX_CHARS];
				//sprintf(_bufferx,"*** This lobby is full at this time, please try another lobby ***");
				char _bufferx[MAX_CHARS];
				sprintf(_bufferx,"*** Connection refused please contact support ***");

				//Message(_bufferx,10); // personal message
				AlertMessage(_bufferx);
			}
		}
	}

	// reset these vars. now we are out of the lobby (i.e. back at app. startup)
	m_tableNo = -1;
	m_tableEnter = 0; // 0 - Watch / 1 - 1P Join / 2 - 2P Join
	m_playerSockIdx = -1;

	#endif //!MAIN_SERVER
}

void CGameAppView::OnInternetExit()
{
	ExitFromLobby();
}

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
// OnUpdateInternet - for enabling/disabling

void CGameAppView::OnUpdateInternetDetails(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	//if( (m_lobby->m_bInLobby && !gameShell) || gameShell)// || (m_snooker->m_bPracticeMode && !m_snooker->m_bComputerMode) )
	if( m_lobby->m_bInLobby || 
		m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 )
		pCmdUI->Enable(FALSE);
	else
		pCmdUI->Enable(TRUE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}
/*
void CGameAppView::OnUpdateInternetSettings(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	//if( (m_lobby->m_bInLobby && !gameShell) || gameShell)// || (m_snooker->m_bPracticeMode && !m_snooker->m_bComputerMode) )
	if( m_lobby->m_bInLobby || 
		m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 )
		pCmdUI->Enable(FALSE);
	else
		pCmdUI->Enable(TRUE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}
*/

void CGameAppView::OnUpdateInternetLobby(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	//if( (m_lobby->m_bInLobby && !gameShell) || gameShell)// || (m_snooker->m_bPracticeMode && !m_snooker->m_bComputerMode) )
	if( m_lobby->m_bInLobby || 
		m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 )
		pCmdUI->Enable(FALSE);
	else
		pCmdUI->Enable(TRUE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdateInternetExit(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if(m_lobby->m_bInLobby && !gameShell)
			pCmdUI->Enable(TRUE);
		else
			pCmdUI->Enable(FALSE);		
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

void CGameAppView::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	// TODO: Add your message handler code here and/or call default

	switch(nIDCtl)
	{
		case IDC_LISTCTRLPLAYERS:
		// set to 14 defaulty
		//char buff[80];
		//sprintf(buff, "Height = %d", lpMeasureItemStruct->itemHeight);

		
//			// sets the control's column height for the items
			lpMeasureItemStruct->itemHeight = m_listPlayers.m_columnHeight;
		break;
		
		case IDC_LISTCTRLTABLES:
		{
			// sets the control's column height for the items
			lpMeasureItemStruct->itemHeight = m_listTables.m_columnHeight;
		}
		break;

		case IDC_WINDOWLISTBOX:
//			// sets the control's column height for the items
			lpMeasureItemStruct->itemHeight = m_listBox.m_columnHeight;
		break;

		default:
		break;
	}

	CView::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
}

void CGameAppView::CreateGame(BOOL bIsHost, int playerIdx, BOOL bReJoin)
{	
	#ifndef MAIN_SERVER
	
	// update sub menu items
	// disable Internet Exit menu option
	{
		CMenu *subMenu = g_menu->GetSubMenu(4); // 'Internet'
		if(subMenu)
		{
			//int value = subMenu->GetMenuState(0,MF_BYPOSITION);
			//if(value == MF_GRAYED) MessageBox("Grayed","",MB_OK);
			//else if(value == MF_ENABLED) MessageBox("Enabled","",MB_OK);
			
			//MessageBox("2","",MB_OK);
			//subMenu->CheckMenuItem(0, MF_CHECKED | MF_BYPOSITION);
			subMenu->EnableMenuItem(0, MF_GRAYED | MF_BYPOSITION); // 'Details...'
		}
	}

	

	////////////////////////

	// Game Shell - Game Server communication (Game Room Hosted by a client in Lobby Room)
	if(!gameShell)
	{
		// change window title
		CString title;
		title.Format(" Attempting to Connect to Table: %d - Hosted by: %s", m_player[playerIdx].table+1, m_player[playerIdx].name);
		ChangeTitle(title);
		
		//DestroyGameShell();
		CreateGameShell(bIsHost, playerIdx, bReJoin);
	}

	#endif //!MAIN_SERVER
}

void CGameAppView::CreateGame2(BOOL bIsHost, int playerIdx, BOOL bReJoin)
{	
	#ifndef MAIN_SERVER
	
	// update sub menu items
	// disable Internet Exit menu option



	if(g_menu)
	{
		//BP_FIX2 ///
		// Not quite sure why, but g_menu doesn't work here, so using AfxGetMainWnd->GetMenu instead
		// Perhaps it doesn't work in GameAppView, unlike Lobby that works with g_menu only //

		CMenu *subMenu = AfxGetMainWnd()->GetMenu()->GetSubMenu(4); // 'Internet'
		//CMenu *subMenu = g_menu->GetSubMenu(4); // 'Internet'
		if(subMenu)
		{
			//int value = subMenu->GetMenuState(0,MF_BYPOSITION);
			//if(value == MF_GRAYED) MessageBox("Grayed","",MB_OK);
			//else if(value == MF_ENABLED) MessageBox("Enabled","",MB_OK);
			
			//MessageBox("2","",MB_OK);
			//subMenu->CheckMenuItem(0, MF_CHECKED | MF_BYPOSITION);
			subMenu->EnableMenuItem(0, MF_GRAYED | MF_BYPOSITION); // 'Details...'
		}
	}
	////////////////////////

	// Game Shell - Game Server communication (Game Room Hosted by a client in Lobby Room)
//	if(!gameShell)
	{
		// change window title
		CString title;
		title.Format(" Attempting to Connect to Table: %d - Hosted by: %s", m_player[playerIdx].table+1, m_player[playerIdx].name);
		ChangeTitle(title);
		
		//DestroyGameShell();
		CreateGameShell2(bIsHost, playerIdx, bReJoin);
	}

	#endif //!MAIN_SERVER
}


void CGameAppView::CreateGamePost(void)
{
	#ifndef MAIN_SERVER
	if(gameShell)
	{
		::ShowWindow(g_hwndDX, SW_SHOW);
		m_lobby->m_bInLobby = FALSE;
		m_snooker->m_bSeenSelectBall = FALSE;
		m_snooker->m_seat = -1;
		g_bMenuSelect = 0;
		m_bDisableOnDraw = 0;
		//SetFocus();
		PreviousWndEditSetFocus();

		m_snooker->Init(RERACK_EMPTY);//RERACK_START);
		//m_snooker->Init(RERACK_START);
	}
	else
	{
		// change window title back to "lobby"
		CString title;
		title.Format("  Lobby");
		ChangeTitle(title);
	}
	#endif // !MAIN_SERVER
}

void CGameAppView::CreateGamePost2(void)
{	
	::ShowWindow(g_hwndDX, SW_SHOW);
	m_lobby->m_bInLobby = FALSE;
	m_snooker->m_bSeenSelectBall = FALSE;
	m_snooker->m_seat = -1;
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	//SetFocus();
	PreviousWndEditSetFocus();

	m_snooker->Init(RERACK_EMPTY);//RERACK_START);
	//m_snooker->Init(RERACK_START);
}


void CGameAppView::CreateGameShell(BOOL bIsHost, int playerIdx, BOOL bReJoin)
{
	#ifndef MAIN_SERVER

	BOOL bConnect;
	m_createGamePlayerIdx = playerIdx;

	//MessageBox("CreatedGameShell","",MB_OK);
	// Game Shell - Game Server communication (Game Room Hosted by a client in Lobby Room)
	gameShell = new CShellEx(FALSE);
	gameShell->AttachComm(SHELL_SERVER, new CComm(MAX_TABLE_PLAYERS, SEND_QUEUE_SIZE)); // also sets max profile capacity. which is used for both clients & servers.
	gameShell->AttachComm(SHELL_CLIENT, new CComm(1, SEND_QUEUE_SIZE));

	// init shell network module
	gameShell->Init(this,2); // pass over hwnd
	gameShell->CreateSeat(0,0+4,200);
	gameShell->CreateSeat(3,0+4,100);
	
	gameShell->CreateSeat(1,400+4,400);

	gameShell->CreateStand(100, &m_standButton);
	gameShell->AttachNameList(&m_listBox);
	//gameShell->Connection(TRUE, "192.168.0.1", 700);//DisplayConnection();
	
	
	if(playerIdx == -1) // therefore, we're in practice mode
	{
		//gameShell->Connection(bIsHost, NULL, 1700);
	}
	else // in proper Net game mode
	{
		// enable/disable sit buttons
		if(!m_player[playerIdx].bInvited)
		{
			for(int n=0;n<gameShell->m_seatList_n;n++) // check all seats
			if(gameShell->m_seatList[n])
				gameShell->m_seatList[n]->m_button.EnableWindow(FALSE);		
		}
		
		///////////////////////////////////////////////////////////////
		// DEBUGGING CODE:
		// case 1:
		// check if player is using same port as server (for debugging)
		if(m_player[playerIdx].playerPort == 1700)
		{
			FailedGameShell(playerIdx);
			return;
		}


		
		//case 2: 
		if(!bIsHost)
		if(m_player[playerIdx].playerPort == 1701)
		{
			FailedGameShell(playerIdx);
			return;
		}

		///////////////////////////////////////////////////////////////
		
		// do connection
		if(bIsHost)
		{
			//bConnect = gameShell->Connection(bIsHost, NULL,
			//								m_player[playerIdx].playerPort);
			
			if(!bReJoin)
				bConnect = gameShell->ConnectionASYNC(bIsHost, NULL,
											m_player[playerIdx].playerPort, ASYNCSOCK_TYPE_GAMESERVER);
			else
				bConnect = gameShell->ConnectionASYNC(bIsHost, NULL,
											m_player[playerIdx].playerPort, ASYNCSOCK_TYPE_GAMESERVER_REJOIN);
			if(!bConnect)
				{
				//ErrorMessage(this, "Fed Up");
				}
			/*
			if(!bConnect)
				{
					FailedGameShell(playerIdx);
					return;
				}
			
			// enable table type for host of table
			m_tableTypeBox.EnableWindow(TRUE);
			*/
		}
		else
		{
			//sprintf(buffer, "%s,   %s", m_player[0].playerIP, m_player[playerIdx].playerIP);
			//MessageBox(buffer,"",MB_OK);

			// check if table host has same (internet) IP as me
			if( !strcmp(m_player[0].playerIP, m_player[playerIdx].playerIP) )
			{
				//MessageBox("(LOCAL IP) path A","",MB_OK);
				// join host's table on local IP
				//bConnect = gameShell->Connection(bIsHost, m_player[playerIdx].playerLocalIP,
				//								m_player[playerIdx].playerPort);
				if(!bReJoin)
					gameShell->ConnectionASYNC(bIsHost, m_player[playerIdx].playerLocalIP,
											m_player[playerIdx].playerPort, ASYNCSOCK_TYPE_GAME);
				else
					gameShell->ConnectionASYNC(bIsHost, m_player[playerIdx].playerLocalIP,
											m_player[playerIdx].playerPort, ASYNCSOCK_TYPE_GAME_REJOIN);
				/*
				if(!bConnect)
				{
					FailedGameShell(playerIdx);
					return;
				}
				*/
			}
			else
			{
				//MessageBox("(INTERNET IP) path B","",MB_OK);
				// join host's table on internet IP
				//bConnect = gameShell->Connection(bIsHost, m_player[playerIdx].playerIP,
				//								m_player[playerIdx].playerPort);
				if(!bReJoin)
					gameShell->ConnectionASYNC(bIsHost, m_player[playerIdx].playerIP,
											m_player[playerIdx].playerPort, ASYNCSOCK_TYPE_GAME);
				else
					gameShell->ConnectionASYNC(bIsHost, m_player[playerIdx].playerIP,
											m_player[playerIdx].playerPort, ASYNCSOCK_TYPE_GAME_REJOIN);
				/*
				if(!bConnect)
				{
					FailedGameShell(playerIdx);
					return;
				}
				*/
			}
		}
	}
/*
	//*TODO - what if this is someone rehosting a table, then we don't want to clear chat window
	// if successful:
	if(m_lobby->m_bInLobby)
	{
	// clear out all the text in the chat window
	DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
	m_editExChat.SetSel(ss,FALSE);
	m_editExChat.ReplaceSel(_T(""));
	//m_editExChat.Clear(); // Beep
	m_sendEdit.SetSel(ss,FALSE);
	m_sendEdit.ReplaceSel(_T(""));
	//m_sendEdit.Clear();  // Beep
	g_active = 1;
	}

	// change window title
	CString title;
	title.Format(" Table: %d -  Host: %s", m_player[playerIdx].table+1, m_player[playerIdx].name);
	ChangeTitle(title);
*/
	#endif //!MAIN_SERVER
}

void CGameAppView::CreateGameShell2(BOOL bIsHost, int playerIdx, BOOL bReJoin)
{
	//#ifndef MAIN_SERVER

	BOOL bConnect;
	m_createGamePlayerIdx = playerIdx;

	//MessageBox("CreatedGameShell","",MB_OK);
//	// Game Shell - Game Server communication (Game Room Hosted by a client in Lobby Room)
//	gameShell = new CShellEx(FALSE);
//	gameShell->AttachComm(SHELL_SERVER, new CComm(MAX_TABLE_PLAYERS, SEND_QUEUE_SIZE)); // also sets max profile capacity. which is used for both clients & servers.
//	gameShell->AttachComm(SHELL_CLIENT, new CComm(1, SEND_QUEUE_SIZE));
			  
	// init shell network module
//	gameShell->Init(this,2); // pass over hwnd
//	gameShell->CreateSeat(0,0+4,200);
//	gameShell->CreateSeat(1,400+4,400);
//	gameShell->CreateStand(100, &m_standButton);
//	gameShell->AttachNameList(&m_listBox);
//	//gameShell->Connection(TRUE, "192.168.0.1", 700);//DisplayConnection();
	
	
	if(playerIdx == -1) // therefore, we're in practice mode
	{
		//gameShell->Connection(bIsHost, NULL, 1700);
	}
	else // in proper Net game mode
	{
		// enable/disable sit buttons
		if(!m_player[playerIdx].bInvited)
		{
			/*
			for(int n=0;n<gameShell->m_seatList_n;n++) // check all seats
			if(gameShell->m_seatList[n])
				gameShell->m_seatList[n]->m_button.EnableWindow(FALSE);		
			*/
		}
	}
	//#endif //!MAIN_SERVER

	
	if(bIsHost) // ***HOSTER***
	{
		CreateGamePost2();


		/////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////

		// Success! - so continue with joining this table...
		
		// enable table type for host of table
		// if guest, then make sure this table is public
		if(!m_player[playerIdx].bIsGuest)
		{
			m_tableTypeBox.EnableWindow(TRUE);
		}
		//m_cueErrorBox.EnableWindow(TRUE);
		
		// clear out all the text in the chat window
		DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
		m_editExChat.SetSel(ss,FALSE);
		m_editExChat.ReplaceSel(_T(""));
		//m_editExChat.Clear(); // Beep
		m_sendEdit.SetSel(ss,FALSE);
		m_sendEdit.ReplaceSel(_T(""));
		//m_sendEdit.Clear();  // Beep
		g_active = 1;
		
		// change window title
		CString title;
		if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			int tblIdx = m_player[playerIdx].table;

			char wildStr[8];
			wildStr[0] = 0;
			if(m_lobby->IsTableWILD(tblIdx)) // check for WILD tables
				sprintf(wildStr, "WILD? ");

			char buff[32];
			buff[0] = 0;
			
			if(m_table[tblIdx].gameType == 0) sprintf(buff, "Snooker");
			else if(m_table[tblIdx].gameType == 1) sprintf(buff, "Short-Snooker");
			else if(m_table[tblIdx].gameType == 2) sprintf(buff, "Mini-Snooker");
			else if(m_table[tblIdx].gameType == 3) sprintf(buff, "Re-Spot Black");
			else if(m_table[tblIdx].gameType == 4) sprintf(buff, "Billiards (50 pts)");
			else if(m_table[tblIdx].gameType == 5) sprintf(buff, "Billiards (100 pts)");
			else if(m_table[tblIdx].gameType == 6) sprintf(buff, "Billiards (200 pts)");

			char buff2[32];
			buff2[0] = 0;
			if(m_table[tblIdx].cueError == 0) sprintf(buff2, "Beginner");
			else if(m_table[tblIdx].cueError == 1) sprintf(buff2, "Semi-Pro");
			else if(m_table[tblIdx].cueError == 2) sprintf(buff2, "Pro");
			
			title.Format(" Table: %d - %s%s - %s -  Host: %s", m_player[playerIdx].table+1, wildStr, buff, buff2, m_player[playerIdx].name);
		}
		else if(g_build.gameType == GAMETYPE_POOL)
		{
			int tblIdx = m_player[playerIdx].table;

			char wildStr[8];
			wildStr[0] = 0;
			if(m_lobby->IsTableWILD(tblIdx)) // check for WILD tables
				sprintf(wildStr, "WILD? ");

			char buff[32];
			buff[0] = 0;
			
			if(m_table[tblIdx].gameType == 0) sprintf(buff, "8-Ball");
			else if(m_table[tblIdx].gameType == 1) sprintf(buff, "9-Ball");
			else if(m_table[tblIdx].gameType == 2) sprintf(buff, "Rotation-Ball");
			else if(m_table[tblIdx].gameType == 3) sprintf(buff, "Bowls");
			else if(m_table[tblIdx].gameType == 4) sprintf(buff, "6-Ball");
			else if(m_table[tblIdx].gameType == 5) sprintf(buff, "10-Ball");
			else if(m_table[tblIdx].gameType == 6) sprintf(buff, "UKPool");
			else if(m_table[tblIdx].gameType == 7) sprintf(buff, "Break");
	
			title.Format(" Table: %d - %s%s -  Host: %s", m_player[playerIdx].table+1, wildStr, buff, m_player[playerIdx].name);
		}
		ChangeTitle(title);	
		
		// set and broadcast player profile (nick for chat msgs)
		//int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
		//if(plrIdx !=-1) gameShell->SetNick(m_player[plrIdx].name); // note: if can't find name, uses 'Guest' use this for error message
		//gameShell->SendProfile();

		int tblIdx = m_player[playerIdx].table;
		

		// Tell server that the hosting phase is complete
		SendTableHostComplete(tblIdx);	
	}
	else  // ***JOINER***
	{
		m_tableTypeBox.EnableWindow(FALSE);

		
		CreateGamePost2();

		/////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////
		// clear out all the text in the chat window
		DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
		m_editExChat.SetSel(ss,FALSE);
		m_editExChat.ReplaceSel(_T(""));
		//m_editExChat.Clear(); // Beep
		m_sendEdit.SetSel(ss,FALSE);
		m_sendEdit.ReplaceSel(_T(""));
		//m_sendEdit.Clear();  // Beep
		g_active = 1;
		
		// change window title		
		CString title;
		if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			int tblIdx = m_player[playerIdx].table;

			char wildStr[8];
			wildStr[0] = 0;
			if(m_lobby->IsTableWILD(tblIdx)) // check for WILD tables
				sprintf(wildStr, "WILD? ");

			char buff[32];
			buff[0] = 0;
			
			if(m_table[tblIdx].gameType == 0) sprintf(buff, "Snooker");
			else if(m_table[tblIdx].gameType == 1) sprintf(buff, "Short-Snooker");
			else if(m_table[tblIdx].gameType == 2) sprintf(buff, "Mini-Snooker");
			else if(m_table[tblIdx].gameType == 3) sprintf(buff, "Re-Spot Black");
			else if(m_table[tblIdx].gameType == 4) sprintf(buff, "Billiards (50 pts)");
			else if(m_table[tblIdx].gameType == 5) sprintf(buff, "Billiards (100 pts)");
			else if(m_table[tblIdx].gameType == 6) sprintf(buff, "Billiards (200 pts)");

			char buff2[32];
			buff2[0] = 0;
			if(m_table[tblIdx].cueError == 0) sprintf(buff2, "Beginner");
			else if(m_table[tblIdx].cueError == 1) sprintf(buff2, "Semi-Pro");
			else if(m_table[tblIdx].cueError == 2) sprintf(buff2, "Pro");
						
			title.Format(" Table: %d - %s%s - %s -  Host: %s", m_player[playerIdx].table+1, wildStr, buff, buff2, m_player[playerIdx].name);
		}
		else if(g_build.gameType == GAMETYPE_POOL)
		{
			int tblIdx = m_player[playerIdx].table;

			char wildStr[8];
			wildStr[0] = 0;
			if(m_lobby->IsTableWILD(tblIdx)) // check for WILD tables
				sprintf(wildStr, "WILD? ");

			char buff[32];
			buff[0] = 0;
			
			if(m_table[tblIdx].gameType == 0) sprintf(buff, "8-Ball");
			else if(m_table[tblIdx].gameType == 1) sprintf(buff, "9-Ball");
			else if(m_table[tblIdx].gameType == 2) sprintf(buff, "Rotation-Ball");
			else if(m_table[tblIdx].gameType == 3) sprintf(buff, "Bowls");
			else if(m_table[tblIdx].gameType == 4) sprintf(buff, "6-Ball");
			else if(m_table[tblIdx].gameType == 5) sprintf(buff, "10-Ball");
			else if(m_table[tblIdx].gameType == 6) sprintf(buff, "UKPool");
			else if(m_table[tblIdx].gameType == 7) sprintf(buff, "Break");
	
			title.Format(" Table: %d - %s%s -  Host: %s", m_player[playerIdx].table+1, wildStr, buff, m_player[playerIdx].name);
		}
		ChangeTitle(title);
		
		// set and broadcast player profile (nick for chat msgs)
		//int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
		//if(plrIdx !=-1) gameShell->SetNick(m_player[plrIdx].name); // note: if can't find name, uses 'Guest' use this for error message
		//gameShell->SendProfile();

		//int tblIdx = m_player[playerIdx].table;
		//int enterType = 0;
		
		//if(m_table[tblIdx].player1SockIdx == m_player[plrIdx].playerSocketIdx) enterType = 1;
		//else if(m_table[tblIdx].player2SockIdx == m_player[plrIdx].playerSocketIdx) enterType = 2;
		
		//if(enterType == 1) gameShell->SitRequest(0); // Seat #1
		//else if(enterType == 2) gameShell->SitRequest(1); // Seat #2
		
	}
}


void CGameAppView::UpdateWindowTitle(int tblIdx)
{
	int playerIdx = m_lobby->GetHostIdxFromTable(tblIdx);
	if(playerIdx == -1) return;
	
	// change window title		
	CString title;
	if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		int tblIdx = m_player[playerIdx].table;
		char buff[32];
		buff[0] = 0;
		
		if(m_table[tblIdx].gameType == 0) sprintf(buff, "Snooker");
		else if(m_table[tblIdx].gameType == 1) sprintf(buff, "Short-Snooker");
		else if(m_table[tblIdx].gameType == 2) sprintf(buff, "Mini-Snooker");
		else if(m_table[tblIdx].gameType == 3) sprintf(buff, "Re-Spot Black");
		else if(m_table[tblIdx].gameType == 4) sprintf(buff, "Billiards (50 pts)");
		else if(m_table[tblIdx].gameType == 5) sprintf(buff, "Billiards (100 pts)");
		else if(m_table[tblIdx].gameType == 6) sprintf(buff, "Billiards (200 pts)");

		char buff2[32];
		buff2[0] = 0;
		if(m_table[tblIdx].cueError == 0) sprintf(buff2, "Beginner");
		else if(m_table[tblIdx].cueError == 1) sprintf(buff2, "Semi-Pro");
		else if(m_table[tblIdx].cueError == 2) sprintf(buff2, "Pro");
					
		title.Format(" Table: %d - %s - %s -  Host: %s", m_player[playerIdx].table+1, buff, buff2, m_player[playerIdx].name);
	}
	else if(g_build.gameType == GAMETYPE_POOL)
	{
		int tblIdx = m_player[playerIdx].table;

		char wildStr[8];
		wildStr[0] = 0;
		if(m_lobby->IsTableWILD(tblIdx)) // check for WILD tables
			sprintf(wildStr, "WILD? ");

		char buff[32];
		buff[0] = 0;
		
		if(m_table[tblIdx].gameType == 0) sprintf(buff, "8-Ball");
		else if(m_table[tblIdx].gameType == 1) sprintf(buff, "9-Ball");
		else if(m_table[tblIdx].gameType == 2) sprintf(buff, "Rotation-Ball");
		else if(m_table[tblIdx].gameType == 3) sprintf(buff, "Bowls");
		else if(m_table[tblIdx].gameType == 4) sprintf(buff, "6-Ball");
		else if(m_table[tblIdx].gameType == 5) sprintf(buff, "10-Ball");
		else if(m_table[tblIdx].gameType == 6) sprintf(buff, "UKPool");
		else if(m_table[tblIdx].gameType == 7) sprintf(buff, "Break");

		title.Format(" Table: %d - %s%s -  Host: %s", m_player[playerIdx].table+1, wildStr, buff, m_player[playerIdx].name);
	}
	ChangeTitle(title);
}


void CGameAppView::EnableSeats(int plrIdx, BOOL bState)
{
	#ifndef	MAIN_SERVER

	if(plrIdx==-1) return;

	// enable/disable sit buttons
	if(m_player[plrIdx].status)
	//if(!m_player[plrIdx].bInvited)
	//if(gameShell)
	{
		// Get the TableIndex
		int tableIdx = m_player[plrIdx].table;
		bool bLadderMatch = false;

		if (tableIdx != -1)
		{
			bLadderMatch = m_table[tableIdx].bLadderMatch;
		}

		//for(int n=0;n<gameShell->m_seatList_n;n++) // check all seats
		//if(gameShell->m_seatList[n])
		//	gameShell->m_seatList[n]->m_button.EnableWindow(bState);
		if(!g_bTournamentLobby && !bLadderMatch)
		{ // default
			m_sit1PButton.EnableWindow(bState);
			m_sit2PButton.EnableWindow(bState);
			m_sit1PButton.SetState(bState);
			m_sit2PButton.SetState(bState);

			m_sit1PButtonB.EnableWindow(bState);
			m_sit2PButtonB.EnableWindow(bState);
			m_sit1PButtonB.SetState(bState);
			m_sit2PButtonB.SetState(bState);



			// *NEW - disable stand button during game [standdisable]
			if(m_lobby->GameStarted(m_player[plrIdx].playerSocketIdx))
				{
				//m_standButton.EnableWindow(FALSE);
				m_standButtonEnabled = FALSE;
				}
			else{
				//m_standButton.EnableWindow(TRUE);
				m_standButtonEnabled = TRUE;
				}
		}
		else
		{ // if this is a 'Tourney' lobby or Ladder Match only!
			m_sit1PButton.EnableWindow(FALSE);
			m_sit2PButton.EnableWindow(FALSE);
			m_sit1PButton.SetState(FALSE);
			m_sit2PButton.SetState(FALSE);

			m_sit1PButtonB.EnableWindow(FALSE);
			m_sit2PButtonB.EnableWindow(FALSE);
			m_sit1PButtonB.SetState(FALSE);
			m_sit2PButtonB.SetState(FALSE);


			// also disable...
			//m_standButton.EnableWindow(FALSE);
			m_standButtonEnabled = FALSE;
		}
	}

	#endif	//!MAIN_SERVER
}


void CGameAppView::FailedGameShell(int playerIdx)
{
	#ifndef MAIN_SERVER
	
	// send message to all
	SendPlayerJoinFailed(FALSE, m_playerSockIdx, playerIdx);

	//////////////////
	// change window title
	CString title;
	title.Format("  Lobby");
	ChangeTitle(title);

	// back to lobby
	::ShowWindow(g_hwndDX, SW_HIDE);
	m_lobby->m_bInLobby = TRUE;


	if(g_gameAppView)
	{
		g_gameAppView->m_sit1PButtonB.ShowWindow(SW_HIDE);
		g_gameAppView->m_sit2PButtonB.ShowWindow(SW_HIDE);

		// Destroy the Force forfit MaxTimeUp dlg if it's open!
		if(g_gameAppView->m_forfeitDlg.m_hWnd)
		if(g_gameAppView->m_forfeitDlg.IsWindowEnabled())
		if(g_gameAppView->m_forfeitDlg.m_forfeitType == 1)
		{
			g_gameAppView->m_forfeitDlg.DestroyWindow();
		}
	}

	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	//SetFocus();
	PreviousWndEditSetFocus();
	/////////////////

	// *TODO - if player came from a table, then clear out text, otherwise don't clear text i.e. DestroyGameShell(FALSE);
	DestroyGameShell();

	#endif //!MAIN_SERVER
}


void CGameAppView::DestroyGameShell(BOOL bClearChatWindow, BOOL bCloseApp)
{
	// return;
	#ifndef MAIN_SERVER
	
	GamePingInit();

	// remove foul dialogue if it's present
	if(m_snooker->m_foulDlg.m_hWnd)	m_snooker->m_foulDlg.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);

	// m_inviteDlg.m_listPlayers.DeleteAllItems();
	// m_inviteDlg.m_listPlayers.m_totalItems = 0;
	if(m_inviteDlg.m_hWnd) m_inviteDlg.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
	
	// m_bootDlg.m_listPlayers.DeleteAllItems();
	// m_bootDlg.m_listPlayers.m_totalItems = 0;
	if(m_bootDlg.m_hWnd) m_bootDlg.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);

	// m_playerListDlg.m_listPlayers.DeleteAllItems();
	// m_playerListDlg.m_listPlayers.m_totalItems = 0;
	if(m_playerListDlg.m_hWnd) m_playerListDlg.SetWindowPos(&wndTop, 0, 0, 32, 32, SWP_NOACTIVATE | SWP_HIDEWINDOW);
		

	// Write Text, telling player they have disconnected (if online)..
	if(bCloseApp == false)
	if(m_playerSockIdx >= 0)
	{
		Message("You have lost connection from the Lobby. Login by clicking 'Online Play -> Internet Lobby'",10); // personal message
	}

	// clear out all the text in the chat window
	if(bClearChatWindow)
	{
		DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
		if(m_editExChat)
		{
			m_editExChat.SetSel(ss,FALSE);
			m_editExChat.ReplaceSel(_T(""));
			//m_editExChat.Clear(); // Beep
		}
		
		if(m_sendEdit)
		{
			m_sendEdit.SetSel(ss,FALSE);
			m_sendEdit.ReplaceSel(_T(""));
			//m_sendEdit.Clear(); // Beep
		}
	}

	// clear out player names from the listbox
	if(m_listBox)
	{
		m_listBox.DeleteAllItems();
		m_listBox.m_totalItems = 0;
	}

	//MessageBox("DestroyGameShell","",MB_OK);
	if(gameShell) 
	{
		if(gameShell->Client)
			gameShell->Client->Close();

		if(gameShell->Server)
			gameShell->Server->Close();

		delete gameShell;
		gameShell = NULL;
	}

	#endif //!MAIN_SERVER
}

void CGameAppView::ReCreateGameShell(void)
{
	#ifndef MAIN_SERVER
	
	//MessageBox("ReCreatedGameShell","",MB_OK);
	DestroyGameShell();
	CreateGameShell();

	#endif //!MAIN_SERVER
}	


void CGameAppView::ChangeTitle(CString str, char type)
{
	// change window title
	CGameAppDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	#ifdef MAIN_SERVER
		CString title;
		CString gameType;
		CString website;

		if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			gameType = _T("iSnooker");
			website = _T("TheSnookerClub.com");
		}
		else if(g_build.gameType == GAMETYPE_POOL)
		{
			gameType = _T("iPool");
			website = _T("ThePoolClub.com");
		}

		#ifdef TEST_SERVER
		//title = _T("- (TEST) TheSnookerClub.com - iSnooker V");
		title = _T("- (TEST) ");
		title += _T(website);
		title += _T(" - ");
		title += _T(gameType);
		title += _T(" V");
		title += _T(g_build.version);
		title += _T(GAME_VERSION_SUB);
		title += _T(" - ");
		title += _T(m_lobbySettings->m_name);
		title += _T(" - ");
		title += str;// Main Server

		//title.Format("- (TEST) TheSnookerClub.com -  iSnooker - Main Server - %s", str);
		#else
		//title = _T("- TheSnookerClub.com - iSnooker V");
		title = _T("- ");
		title += _T(website);
		title += _T(" - ");
		title += _T(gameType);
		title += _T(" V");
		title += _T(g_build.version);
		title += _T(GAME_VERSION_SUB);
		title += _T(" - ");
		title += _T(m_lobbySettings->m_name);
		title += _T(" - ");
		title += str;
		//title.Format("- TheSnookerClub.com -  iSnooker - Main Server - %s", str);
		#endif // TEST_SERVER
	#else
		CString title;
		CString gameType;
		CString website;

		if(g_build.gameType == GAMETYPE_SNOOKER)
		{
			gameType = _T("iSnooker");
			website = _T("TheSnookerClub.com");
		}
		else if(g_build.gameType == GAMETYPE_POOL)
		{
			gameType = _T("iPool");
			website = _T("ThePoolClub.com");
		}
		
		#ifdef TEST_SERVER
		//title = _T("- (TEST) TheSnookerClub.com - iSnooker V");
		title = _T("- (TEST) ");
		title += _T(website);
		title += _T(" - ");
		title += _T(gameType);
		title += _T(" V");
		title += _T(g_build.version);
		title += _T(GAME_VERSION_SUB);
		if(g_lobbyname.GetLength()>0)
			{
			title += _T(" - ");
			title += _T(g_lobbyname);
			}
		if(str.GetLength() > 0)
		{
			title += _T(" - ");
			title += str;
		}
		//title.Format("- (TEST) TheSnookerClub.com - iSnooker - %s", str);
		#else
		//title = _T("- TheSnookerClub.com - iSnooker V");
		title = _T("");
		title += _T(website);
		title += _T(" - ");
		title += _T(gameType);
		title += _T(" V");
		title += _T(g_build.version);
		title += _T(GAME_VERSION_SUB);
#ifdef WIN_XP
		title += _T(" XP");
#endif
		// title += _T("**c");
		if(g_lobbyname.GetLength()>0)
			{
			title += _T(" - ");
			title += _T(g_lobbyname);
			}
		if(str.GetLength() > 0)
		{
			title += _T(" - ");
			title += str;
		}
		//title.Format("- TheSnookerClub.com - iSnooker - %s", str);
		#endif
	#endif // MAIN_SERVER

	if(type == 1) title = "";
	pDoc->SetTitle(title); // set the name of this document
}

/*
CString CGameAppView::GetTitle(void)
{
	return pDoc->GetTitle(title); // set the name of this document
}
*/

BOOL CGameAppView::OptionNotForGuest(int plrSockIdx, int type)
{
	int plrIdx = m_lobby->GetPlayerIdx(plrSockIdx);
	if(plrIdx != -1)
		{
		// Diable all commands if this person is a Guest //
		// 4 Checks, If the name starts with 'Guest' or if Rating=0 or is bIsGuest is Set //
		char tstr[128];
		char GNameCheck=0;
		strcpy(tstr, m_player[plrIdx].name);
		tstr[5] = 0; //GUEST0
		if(!strcmpi(tstr, "guest")) GNameCheck=1;

		if(m_player[plrIdx].rating ==0 || m_player[plrIdx].bIsGuest==TRUE || GNameCheck==1 || m_player[plrIdx].playertype==6)
		{
			// If g_guestchat is FALSE, Disable Guest Chat entirely.
			// if(g_guestchat)
			if(type == 666)
			{			
				// guest is trying to talk, only allow if this guest is sitting at a table
				if(m_lobby->SeatedAtTable(plrSockIdx))
					return FALSE;
				
				
				// this option is not available for guests
				char _bufferx[MAX_CHARS];
				sprintf(_bufferx,"*** Option not avaliable for guests, unless playing ***");
				Message(_bufferx,10); // personal message
				return TRUE;
			}

			// this option is not available for guests
			char _buffer[MAX_CHARS];
			sprintf(_buffer,"*** Option not avaliable for guests ***");
			Message(_buffer,10); // personal message
			return TRUE;		
		}
	}	
	return FALSE;
}

void RectangleShaded(CDC *pDC, int x1, int y1, int x2, int y2, COLORREF color)
{
	int n;
	float red = (float)GetRValue(color)/0.96f;
	float green = (float)GetGValue(color)/1.25f;
	float blue = 0;//(float)GetBValue(color)/2;
	int r = red;
	int g = green;
	int b = blue;
	float height = y2 - y1;

	for(n=y1;n<(y2-(height/2));n++)
	{
		COLORREF c = RGB(r, g, b);
		CPen pen(PS_SOLID, 2, c);
		CPen *oldPen = pDC->SelectObject(&pen);
		pDC->MoveTo(x1,n);
		pDC->LineTo(x2,n);
		pDC->SelectObject(oldPen);
		if(r<240) r+=4;
		if(g<240) g+=4;
		//if(b<240) b+=6;
	}
		
	for(n=(y1+(height/2));n<y2;n++)
	{
		COLORREF c = RGB(r, g, b);
		CPen pen(PS_SOLID, 2, c);
		CPen *oldPen = pDC->SelectObject(&pen);
		pDC->MoveTo(x1,n);
		pDC->LineTo(x2,n);
		pDC->SelectObject(oldPen);
		if(r) r-=4;
		if(g) g-=4;
		//if(b) b-=6;
	}
}

void RectangleShaded2(CDC *pDC, int x1, int y1, int x2, int y2, COLORREF color)
{
	int n;
	float red = (float)GetRValue(color)/0.96f;//0;
	float green = 0;//(float)GetGValue(color)/0.96f;
	float blue = (float)GetBValue(color)/1.25f;
	int r = red;
	int g = green;
	int b = blue;
	float height = y2 - y1;

	for(n=y1;n<(y2-(height/2));n++)
	{
		COLORREF c = RGB(b+40, g+20+40, r);
		CPen pen(PS_SOLID, 2, c);
		CPen *oldPen = pDC->SelectObject(&pen);
		pDC->MoveTo(x1,n);
		pDC->LineTo(x2,n);
		pDC->SelectObject(oldPen);
		if(r<240) r+=4;
		if(g<240) g+=1;
		if(b<240) b+=1;
	}
		
	for(n=(y1+(height/2));n<y2;n++)
	{
		COLORREF c = RGB(b+40, g+20+40, r);
		CPen pen(PS_SOLID, 2, c);
		CPen *oldPen = pDC->SelectObject(&pen);
		pDC->MoveTo(x1,n);
		pDC->LineTo(x2,n);
		pDC->SelectObject(oldPen);
		if(r) r-=4;
		if(g) g-=2;
		if(b) b-=2;
	}
}

void RectangleShaded3(CDC *pDC, int x1, int y1, int x2, int y2, COLORREF color)
{
	int n;
	float red = (float)GetRValue(color)/0.96f;
	float green = (float)GetGValue(color)/1.25f;
	float blue = 0;//(float)GetBValue(color)/0.96f;
	int r = red*0.6f;
	int g = green;
	int b = blue;
	float height = y2 - y1;

	for(n=y1;n<(y2-(height/2));n++)
	{
		COLORREF c = RGB(g+20, r, b+40);
		CPen pen(PS_SOLID, 2, c);
		CPen *oldPen = pDC->SelectObject(&pen);
		pDC->MoveTo(x1,n);
		pDC->LineTo(x2,n);
		pDC->SelectObject(oldPen);
		if(r<240) r+=2;
		if(g<240) g+=1;
		if(b<240) b+=1;
	}
		
	for(n=(y1+(height/2));n<y2;n++)
	{
		COLORREF c = RGB(g+20, r, b+40);
		CPen pen(PS_SOLID, 2, c);
		CPen *oldPen = pDC->SelectObject(&pen);
		pDC->MoveTo(x1,n);
		pDC->LineTo(x2,n);
		pDC->SelectObject(oldPen);
		if(r) r-=3;
		if(g) g-=2;
		if(b) b-=2;
	}
}

#if 0 // OLD FUNC. AS OF 01FEB04 (SEE NEXT FUNC. BELOW)
void CGameAppView::DrawGameMessage(char *str, float realignment)
{
	#ifndef MAIN_SERVER
	
	float x,y;		
	float offsetX = m_snooker->m_sSize.x - m_cx; // 800
	float offsetY = m_snooker->m_sSize.y - m_cy; // 600
	float fX = (float)(m_cx) / m_snooker->m_sSize.x;
	x = m_cx/2;
	y = m_cx/(2*2);
			
	Mgfx_idx = 255;
	sprintf(buffer, "%s",str);//"Click 'Sit' to start practice");
	int len = strlen(buffer);

	//TEXTMETRIC tm;
	//GetDC()->GetTextMetrics(&tm); // this caused crash after ~5mins ??? Don't know why? Probably due to a NULL'ed DC									
	float aveCharWidth = 6.8f;
	
	//Mgfx_fillrect(x+24 - (len*tm.tmAveCharWidth/2) - 12, y - 12, (realignment*len*tm.tmAveCharWidth) + 24, 24, Mgfx_rgbcolor(20,20,20));
	Mgfx_fillrect(x+24 - (len*aveCharWidth/2) - 12, y - 12, (realignment*len*aveCharWidth) + 24, 24, Mgfx_rgbcolor(20,20,20));
	Mgfx_gditext(x+24, y-8, buffer, Mgfx_idx, MGFX_GDITEXT_CENTER);

	#endif //!MAIN_SERVER
}
#endif //0


void CGameAppView::DrawGameMessage(char *str, float realignment)
{

	DWORD lcol;
	DWORD rcol;


	static float timer = 0.0f;
	static float alpha = 0.01f;

	timer += 0.15;
	alpha = 0.85f + 0.05f * sinf(timer);

	/*
	timer += dir;
	if(timer >= 1.0f) dir = -0.03f;
	if(timer <= 0.4f) dir = 0.03f;
	*/

	// Frames and Next Ball Info Background //
	lcol = D3DCOLOR_RGBA(5,5,5,210);
	rcol = D3DCOLOR_RGBA(5,5,5,210);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,3,-0.5f,-0.5f,0,lcol,lcol,0,1);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,2,0.5f,-0.5f,0,rcol,rcol,1,1);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,1,0.5f,0.5f,0,rcol,rcol,1,0);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,0,-0.5f,0.5f,0,lcol,lcol,0,0);

	// Background
	M2d_platedraw(800, 300, strlen(str)*22, 32);

	// Text 
	g_pFont2->Render(str, 800, 300-16, 0.0f, alpha, 0.3f, 0.3f, MGFX_FNTDRAW_CENTER);
/*	

	#ifndef MAIN_SERVER
	
	realignment = 1.0f; // REDUNDANT VARIABLE!
	
	float x,y;
	SIZE size;
	sprintf(buffer, "%s",str);
	int len = strlen(buffer);

	// get length of text-string in pixels
	////////////////////////////////////////////////////
	HDC dc;	
	HRESULT retval;
	do {
	retval = lpddsx->GetDC(&dc); // Get Device Context from DirectDraw-Surface1
	} while(retval==DDERR_WASSTILLDRAWING);
		
	if(retval == DD_OK)
	{		
		GetTextExtentPoint32(dc, str, strlen(str), &size);			
		retval = lpddsx->ReleaseDC(dc);	// Release the Device Context.
	}
	else // do weak estimate!
	{
		float aveCharWidth = 6.8f;
		size.cx = aveCharWidth * len;
	}
	////////////////////////////////////////////////////
	
	x = m_cx/2;
	y = m_cx/(2*2);
	Mgfx_idx = 255;	
	Mgfx_fillrect(x-16 - (size.cx/2), y - 12, (realignment*size.cx) + 32, 24, Mgfx_rgbcolor(20,20,20));		
	Mgfx_gditext(x - (size.cx/2), y-8, buffer, Mgfx_idx);

	#endif //!MAIN_SERVER

*/
}

void CGameAppView::DrawGameMessageXY(char *str, int x, int y)
{

	float alpha = ((float)m_functionKeyGFXDelay) / 40.0f;


	DWORD lcol;
	DWORD rcol;

	// Frames and Next Ball Info Background //
	lcol = D3DCOLOR_RGBA(20,20,20, (int)(190 * alpha));
	rcol = D3DCOLOR_RGBA(20,20,20, (int)(190 * alpha));
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,3,-0.5f,-0.5f,0,lcol,lcol,0,1);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,2,0.5f,-0.5f,0,rcol,rcol,1,1);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,1,0.5f,0.5f,0,rcol,rcol,1,0);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,0,-0.5f,0.5f,0,lcol,lcol,0,0);

	// Background
	M2d_platedraw(800, 366, strlen(str)*22, 32);

	g_pFont2->Render(str, 800, 350, 0.0f, alpha, 0.3f, 0.3f, MGFX_FNTDRAW_CENTER);

/*
	#ifndef MAIN_SERVER
	
	float realignment = 1.0f; // REDUNDANT VARIABLE!
	
	//float x,y;
	SIZE size;
	sprintf(buffer, "%s",str);
	int len = strlen(buffer);

	// get length of text-string in pixels
	////////////////////////////////////////////////////
	HDC dc;	
	HRESULT retval;
	do {
	retval = lpddsx->GetDC(&dc); // Get Device Context from DirectDraw-Surface1
	} while(retval==DDERR_WASSTILLDRAWING);
		
	if(retval == DD_OK)
	{		
		GetTextExtentPoint32(dc, str, strlen(str), &size);			
		retval = lpddsx->ReleaseDC(dc);	// Release the Device Context.
	}
	else // do weak estimate!
	{
		float aveCharWidth = 6.8f;
		size.cx = aveCharWidth * len;
	}
	////////////////////////////////////////////////////
	
	//x = m_cx/2;
	//y = m_cx/(2*2);
	Mgfx_idx = 255;	
	Mgfx_fillrect(x-16, y - 12, (realignment*size.cx) + 32, 24, Mgfx_rgbcolor(20,20,20));		
	Mgfx_gditext(x , y-8, buffer, Mgfx_idx);

	#endif //!MAIN_SERVER

*/
}

void CGameAppView::DrawGameMessage(char *str, CRect rect, int textdy)
{
/*
	#ifndef MAIN_SERVER
	Mgfx_idx = 255;
	sprintf(buffer, "%s",str);
	int len = strlen(buffer);

	CSize size;
	size = rect.Size();
	
	Mgfx_fillrect(rect.left, rect.top, size.cx, size.cy, Mgfx_rgbcolor(20,20,20));
	Mgfx_gditext(rect.left, rect.top + textdy, buffer, Mgfx_idx, MGFX_GDITEXT_LEFT);
	#endif //!MAIN_SERVER

*/
}

int CGameAppView::PlayerStatus(char *name)
{
#ifdef MYSQL_SYSTEM
	int n;
	n = LoadPlayerFileEx(name, NULL);
	if(n==1) return PLAYER_EXISTS;
	else if(n>1) return n; // Contacts 4 Bits for Banned, Walled, Denied, Blocked
	return PLAYER_INVALID;
#else

	char nameFile[256];
	FILE *fptr;
	m_playerStatusExt = 0;
	sprintf(nameFile,"%sMembers/%s.txt",g_basedir,name);
	if((fptr = fopen(nameFile,"rb"))==NULL);
	else {
		 fclose(fptr);
		 return PLAYER_EXISTS;
		 }

	sprintf(nameFile,"%sMembers/%s.ban",g_basedir,name);
	if((fptr = fopen(nameFile,"rb"))==NULL);
	else {
		 fclose(fptr);
		 return PLAYER_BANNED;
		 }
	
	m_playerStatusExt = 1;
	// Members 2
	sprintf(nameFile,"%sMembers2/%s.txt",g_basedir,name);
	if((fptr = fopen(nameFile,"rb"))==NULL);
	else {
		 fclose(fptr);
		 return PLAYER_EXISTS;
		 }

	sprintf(nameFile,"%sMembers2/%s.ban",g_basedir,name);
	if((fptr = fopen(nameFile,"rb"))==NULL);
	else {
		 fclose(fptr);
		 return PLAYER_BANNED;
		 }
	return PLAYER_INVALID;
#endif

}

BOOL CGameAppView::LoadPlayer(char *name, Player *plr)
{
#ifdef MYSQL_SYSTEM
	if(PlayerStatus(name)!=PLAYER_EXISTS) return FALSE;

	LoadPlayerFileEx(name, plr);
	return TRUE;
#else
	char nameFile[80];
	FILE *fptr;
	// player must exist to ban him. (can't be already banned or non existant)
	if(PlayerStatus(name)!=PLAYER_EXISTS) return FALSE;

	if(!m_playerStatusExt) // playerstatus sets this value, so we know what directory the member file resides in.
	{
	sprintf(nameFile,"%sMembers/",g_basedir);
	}
	else {
	sprintf(nameFile,"%sMembers2/",g_basedir);
	}

	strcat(nameFile, name);
	strcat(nameFile, ".txt");

	LoadPlayerFile(nameFile, plr);
	return TRUE;
#endif
}


BOOL CGameAppView::SavePlayer(char *name, Player *plr)
{
#ifdef MYSQL_SYSTEM
	if(PlayerStatus(name)!=PLAYER_EXISTS) return FALSE;

	SavePlayerFileEx(name, plr);
	return TRUE;
#else
	char nameFile[80];
	FILE *fptr;
	// player must exist to ban him. (can't be already banned or non existant)
	if(PlayerStatus(name)!=PLAYER_EXISTS) return FALSE;

	if(!m_playerStatusExt) // playerstatus sets this value, so we know what directory the member file resides in.
	{
	sprintf(nameFile,"%sMembers/",g_basedir);
	}
	else {
	sprintf(nameFile,"%sMembers2/",g_basedir);
	}

	strcat(nameFile, name);
	strcat(nameFile, ".txt");

	SavePlayerFile(nameFile, plr);
	return TRUE;
#endif
}

BOOL CGameAppView::TopUpPlayer(char *name, int days)
{
#ifdef MYSQL_SYSTEM
	if(PlayerStatus(name)!=PLAYER_EXISTS) return FALSE;
	Player plr;

	LoadPlayerFileEx(name, &plr);
	TopUpAccountPlayerDays(&plr, days);
	SavePlayerFileEx(name, &plr);
	return TRUE;
#else
	char nameFile[80];
	FILE *fptr;
	// player must exist to ban him. (can't be already banned or non existant)
	if(PlayerStatus(name)!=PLAYER_EXISTS) return FALSE;

	if(!m_playerStatusExt) // playerstatus sets this value, so we know what directory the member file resides in.
	{
	sprintf(nameFile,"%sMembers/",g_basedir);
	}
	else {
	sprintf(nameFile,"%sMembers2/",g_basedir);
	}

	strcat(nameFile, name);
	strcat(nameFile, ".txt");

	Player plr;

	LoadPlayerFile(nameFile, &plr);
	TopUpAccountPlayerDays(&plr, days);
	SavePlayerFile(nameFile, &plr);
	return TRUE;
#endif
}


///// Walling /////
BOOL CGameAppView::WallSysID(char *sysid)
{
	int ret = CheckWalledEx(sysid);
	if(ret==1) return FALSE; // Already Walled
	else if(ret==0) WallSysIDEx(sysid);
	return TRUE;
}
///// UnWalling /////
BOOL CGameAppView::UnWallSysID(char *sysid)
{
	int ret = CheckWalledEx(sysid);
	if(ret==0) return FALSE; // Already UnWalled
	else if(ret==1) UnWallSysIDEx(sysid);
	return TRUE;
}

///// Denying /////
BOOL CGameAppView::DenyMacID(char *macid)
{
	int ret = CheckDeniedEx(macid);
	if(ret==1) return FALSE; // Already Denied
	else if(ret==0) DenyMacIDEx(macid);
	return TRUE;
}
///// UnDenying /////
BOOL CGameAppView::UnDenyMacID(char *macid)
{
	int ret = CheckDeniedEx(macid);
	if(ret==0) return FALSE; // Already UnDenied
	else if(ret==1) UnDenyMacIDEx(macid);
	return TRUE;
}

///// Blocking /////
BOOL CGameAppView::BlockIP(char *ip)
{
	int ret = CheckBlockedEx(ip);
	if(ret==1) return FALSE; // Already Blocked
	else if(ret==0) BlockIPEx(ip);
	return TRUE;
}
///// UnBlocking /////
BOOL CGameAppView::UnBlockIP(char *ip)
{
	int ret = CheckBlockedEx(ip);
	if(ret==0) return FALSE; // Already UnBlocked
	else if(ret==1) UnBlockIP(ip);
	return TRUE;
}


BOOL CGameAppView::BanPlayer(char *name)
{
	char nameFile[80];
	char renameFile[80];
	FILE *fptr;
	// player must exist to ban him. (can't be already banned or non existant)
	//if(PlayerStatus(name)!=PLAYER_EXISTS) return FALSE;
	if(PlayerStatus(name)&2) return FALSE;
#ifdef MYSQL_SYSTEM
	BanPlayerFileEx(name);
	return TRUE;
#else
	if(!m_playerStatusExt) // playerstatus sets this value, so we know what directory the member file resides in.
	{
	sprintf(nameFile,"%sMembers/",g_basedir);
	sprintf(renameFile,"%sMembers/",g_basedir);
	}
	else {
	sprintf(nameFile,"%sMembers2/",g_basedir);
	sprintf(renameFile,"%sMembers2/",g_basedir);
	}

	//strcpy(nameFile, "Members/");
	strcat(nameFile, name);
	strcat(nameFile, ".txt");

	
	//strcpy(renameFile, "Members/");
	strcat(renameFile, name);
	strcat(renameFile, ".ban");

	rename( nameFile, renameFile);

	return TRUE;
#endif
}

BOOL CGameAppView::UnbanPlayer(char *name)
{
	char nameFile[80];
	char renameFile[80];
	FILE *fptr;
	// player must exist to ban him. (can't be already banned or non existant)
	//if(PlayerStatus(name)!=PLAYER_BANNED) return FALSE;
	if(!(PlayerStatus(name)&PLAYER_BANNED)) return FALSE;
#ifdef MYSQL_SYSTEM
	UnBanPlayerFileEx(name);
	return TRUE;
#else
	if(!m_playerStatusExt) // playerstatus sets this value, so we know what directory the member file resides in.
	{
	sprintf(nameFile,"%sMembers/",g_basedir);
	sprintf(renameFile,"%sMembers/",g_basedir);
	}
	else {
	sprintf(nameFile,"%sMembers2/",g_basedir);
	sprintf(renameFile,"%sMembers2/",g_basedir);
	}

	//sprintf(nameFile,"%sMembers/",g_basedir);
	strcat(nameFile, name);
	strcat(nameFile, ".ban");

	//sprintf(renameFile,"%sMembers/",g_basedir);
	strcat(renameFile, name);
	strcat(renameFile, ".txt");

	rename( nameFile, renameFile);

	return TRUE;
#endif;
}

int CGameAppView::LoadPlayerProfile(Player *plr, char *filetype)
{
	FILE *fp;
	char nameFile[80];

	/*sprintf(nameFile,"%sMembers/",g_basedir);
	//strcpy(nameFile, "Members/");
	strcat(nameFile, plr->name);
	//strcat(nameFile, ".bak");
	strcat(nameFile, filetype);
	*/

	return LoadPlayerFileExFT(plr->name, plr, filetype);  // save member file.
}

void CGameAppView::SavePlayerProfile(Player *plr, char *filetype)
{
	FILE *fp;
	char nameFile[80];

	/*
	sprintf(nameFile,"%sMembers/",g_basedir);
	//strcpy(nameFile, "Members/");
	strcat(nameFile, plr->name);
	//strcat(nameFile, ".bak");
	strcat(nameFile, filetype);
	*/

	SavePlayerFileExFT(plr->name, plr, filetype);  // save member file.
}

void CGameAppView::DeletePlayerProfile(Player *plr, char *filetype)
{
	#ifdef MYSQL_SYSTEM
	// do nothing, we dont deal with backup files //
	#else
	FILE *fp;
	char nameFile[256];

	if(plr->state&PLRSTATE_GUESTMEMBER)
	{
	sprintf(nameFile,"%sMembers2/%s%s",g_basedir,plr->name,filetype);
	DeleteFile(nameFile); // doesn't delete for some reason?
	}
	else {
	sprintf(nameFile,"%sMembers/%s%s",g_basedir,plr->name,filetype);
	DeleteFile(nameFile);
	}
	#endif
	/*
	sprintf(nameFile,"%sMembers/",g_basedir);
	//strcpy(nameFile, "Members/");
	strcat(nameFile, plr->name);
	//strcat(nameFile, ".bak");
	strcat(nameFile, filetype);	

	DeleteFile(nameFile);
	*/
}

BOOL CGameAppView::PreTranslateMessage(MSG* pMsg) 
{
	// TODO: Add your specialized code here and/or call the base class
	g_bNewMessage = TRUE;

	#ifndef MAIN_SERVER
	// check if any hot-keys have been pressed i.e. Function key maps for menus
	if(pMsg->message == WM_KEYDOWN)
	if(!m_lobby->m_bInLobby)
	if( m_snooker->m_cueBallSelect == 0 || m_snooker->m_cueBallSelect == 1 || m_snooker->m_cueBallSelect == 5)
	{
		switch(pMsg->wParam) // virtual key codes info.
		{
		case VK_F1: // used by onhelp command
		break;
		case VK_F2:
		((CMainFrame *)AfxGetMainWnd())->OptionsDrawcoloursl();
		m_functionKey = 2;
		m_functionKeyGFXDelay = 40;
		break;
		case VK_F3:
		((CMainFrame *)AfxGetMainWnd())->OptionsDrawerrorsl();
		m_functionKey = 3;
		m_functionKeyGFXDelay = 40;
		break;
		case VK_F4:
		((CMainFrame *)AfxGetMainWnd())->OptionsDrawghostcueball();
		m_functionKey = 4;
		m_functionKeyGFXDelay = 40;
		break;
		case VK_F5:
		((CMainFrame *)AfxGetMainWnd())->OptionsDrawcueballLe();
		m_functionKey = 5;
		m_functionKeyGFXDelay = 40;
		break;
		case VK_F6:
		if(g_gfxDetails.bOptionsLowgfx) ((CMainFrame *)AfxGetMainWnd())->OptionsMediumgfx();
		else if(g_gfxDetails.bOptionsMediumgfx) ((CMainFrame *)AfxGetMainWnd())->OptionsHighgfx();
		else ((CMainFrame *)AfxGetMainWnd())->OptionsLowgfx();
		m_functionKey = 6;
		m_functionKeyGFXDelay = 40;
		break;
		case VK_F7: // un-used
		if(m_snooker)
		if(m_snooker->m_bPracticeMode)
		{
			//((CMainFrame *)AfxGetMainWnd())->PracticeBallinhand();
			m_functionKey = 7;
			m_functionKeyGFXDelay = 40;
		}
		break;
		case VK_F8: // un-used
		if(m_snooker)
		if(m_snooker->m_bPracticeMode)
		{
			#ifndef THE_POOL_CLUB
			switch(m_snooker->m_reRackType)
			{
				case RERACK_START:
				OnPracticeLineup();
				break;
				case RERACK_LINEUP:
				OnPracticeColours();
				break;
				case RERACK_COLOURS:				
				OnPracticeBlack();
				break;
				case RERACK_BLACK:				
				OnPracticeRedsscattered1();
				break;
				case RERACK_REDSSCATTERED1:				
				OnPracticeRedsscattered2();
				break;
				case RERACK_REDSSCATTERED2:				
				OnPracticeStart();
				break;
			}
			#else
			switch(m_snooker->m_reRackType)
			{
				case RERACK_8BALL:
				OnPracticeLineup();
				break;
				case RERACK_9BALL:
				OnPracticeColours();
				break;
				case RERACK_8BALLSCATTERED:
				OnPracticeBlack();
				break;
				case RERACK_9BALLSCATTERED:
				OnPracticeRedsscattered1();
				break;
				case RERACK_ROTATIONBALL:
				OnPracticeRedsscattered2();
				break;
				case RERACK_BOWLS:
				OnPracticeA();
				break;
				case RERACK_6BALL:
				OnPracticeB();
				break;
				case RERACK_6BALLSCATTERED:
				OnPracticeC();
				break;
				case RERACK_10BALL:
				OnPracticeD();
				break;
				case RERACK_10BALLSCATTERED:
				OnPracticeStart();
				break;
				case RERACK_UKPOOL:
				OnPracticeF();
				break;
				case RERACK_BREAK:
				// Change to Normal Table //
				break;
				//case RERACK_BREAK:
				// Change to Pro Table //
				break;
				//case RERACK_BREAK:
				// Change to Pro Table //
				break;
				
			}
			#endif
			m_functionKey = 8;
			m_functionKeyGFXDelay = 40;
		}
		break;
		}
	}

	
	// check if our app is in an idle state - i.e. user not doing any input stuff to this app.
	switch(pMsg->message)
	{

		
		case WM_MOUSEMOVE:	
		/////////////////////////////		
		if(m_mouseMovePoint == pMsg->pt) // if no change in mouse position, ignore this message - still idle
			return CView::PreTranslateMessage(pMsg);
		m_mouseMovePoint = pMsg->pt;
		/////////////////////////////
		case WM_MOUSEWHEEL:
		case WM_LBUTTONDBLCLK:
		case WM_LBUTTONUP:
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_CHAR:
		case WM_SETFOCUS:
		case WM_SIZE:
		case WM_MOVE:
		g_playerIdleTime = 0; // reset player's idle time counter
		if(m_bIdleAway)
		{
			m_bIdleAway = FALSE;
			SendRequestIdleAway(FALSE);
		}
		//ErrorMessage(g_wnd, "alive!");
		break;



		default:
		//ErrorMessage(g_wnd, "idle.");
		break;
	}
	#endif //!MAIN_SERVER

	return CView::PreTranslateMessage(pMsg);
}

void CGameAppView::OnHelpOnline() 
{
	// TODO: Add your command handler code here
	//CRect rect;
	//m_Picture.GetWindowRect(&rect);
	//ScreenToClient(&rect);
	//if (rect.PtInRect(point))

	if(g_build.gameType == GAMETYPE_SNOOKER)
		ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thesnookerclub.com/index2.php?mainframe=gettingstarted.html"),_T(""),NULL,0);
	else if(g_build.gameType == GAMETYPE_POOL)
		ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thepoolclub.com/index2.php?mainframe=getting_started.html"),_T(""),NULL,0);
															 
}

void CGameAppView::OnHelpFaq() 
{
	// TODO: Add your command handler code here
	if(g_build.gameType == GAMETYPE_SNOOKER)
		ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thesnookerclub.com/index2.php?mainframe=faq.html"),_T(""),NULL,0);
	else if(g_build.gameType == GAMETYPE_POOL)
		ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thepoolclub.com/index2.php?mainframe=faq.html"),_T(""),NULL,0);
}

void CGameAppView::OnHelpVersion() 
{
	// TODO: Add your command handler code here
	if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thesnookerclub.com/dls.html"),_T(""),NULL,0);	
		//ShellExecute(AfxGetMainWnd()->m_hWnd,/*NULL*/_T("open"), _T("http://www.thesnookerclub.com/patch.html"),_T(""),NULL,0);
	}
	else if(g_build.gameType == GAMETYPE_POOL)
	{
		ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thepoolclub.com/index2.php?mainframe=dls.html"),_T(""),NULL,0);	
	}
	AfxGetMainWnd()->DestroyWindow();
}

void CGameAppView::OnHelpGamerules() 
{
	// TODO: Add your command handler code here
	OnHelpMessage();	
}


void CGameAppView::OnUpdateHelpVersion(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	//if( (!m_lobby->m_bInLobby && !gameShell) )
	if( !m_lobby->m_bInLobby && 
		m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) ==-1 )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdateHelpGamerules(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	//if( (!m_lobby->m_bInLobby && !gameShell) )
	if( m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 	
}


void CGameAppView::OnUpdateWideScreenEnabled(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	//if( (!m_lobby->m_bInLobby && !gameShell) )
	if( m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 	
}



void CGameAppView::OnUpdateWideScreenDisabled(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	//if( (!m_lobby->m_bInLobby && !gameShell) )
	if( m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) !=-1 || m_snooker->m_bPracticeMode)
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 	
}


void CGameAppView::OnWideScreenDisabled() 
{
	// TODO: Add your command handler code here
	g_WideScreenEnabled = FALSE;
	
	// Tick Disabled, and UnTick Enabled //
	CMenu *menu = AfxGetMainWnd()->GetMenu();
	CMenu *subMenu;
	if(menu)
	{
		subMenu = menu->GetSubMenu(11);  // 11 is WideScreen Menu
		if(subMenu)
		{
			subMenu->CheckMenuItem(0, MF_CHECKED | MF_BYPOSITION);
			subMenu->CheckMenuItem(1, MF_UNCHECKED | MF_BYPOSITION);
		}
	}


	// Refresh Everything //
	if(g_gameAppView)
		{
		// GameLoop();
		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		}

	static BOOL firstTime = 1;
	

#ifndef MAIN_SERVER
	m_snooker->m_bRefreshScores = TRUE;
#endif //!MAIN_SERVER


	m_bOnSize = TRUE;
	m_bOnSizeDrawTmpSurf = TRUE;

	if(firstTime) firstTime = 0;

}

	

void CGameAppView::OnWideScreenEnabled() 
{
	// TODO: Add your command handler code here
	g_WideScreenEnabled = TRUE;	

	// Tick Enabled, and UnTick Disabled //
	CMenu *menu = AfxGetMainWnd()->GetMenu();
	CMenu *subMenu;

	
	if(menu)
	{
		subMenu = menu->GetSubMenu(11);  // 11 is WideScreen Menu
		if(subMenu)
		{
			subMenu->CheckMenuItem(1, MF_CHECKED | MF_BYPOSITION);
			subMenu->CheckMenuItem(0, MF_UNCHECKED | MF_BYPOSITION);
		}
	}

	
	// Refresh Everything //
	if(g_gameAppView)
		{
		// GameLoop();
		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		}

	static BOOL firstTime = 1;
	

#ifndef MAIN_SERVER
	m_snooker->m_bRefreshScores = TRUE;
#endif //!MAIN_SERVER

	Deinit();
	Init();
	m_bOnSize = TRUE;
	m_bOnSizeDrawTmpSurf = TRUE;

	if(firstTime) firstTime = 0;
}





BOOL CGameAppView::GetClickBanner(CBitmap *pBanner, CPoint point, CRect offset)
{
	BITMAP bm;
	CRect rect;
/*	
	// check if clicked on banner
	GetWindowRect(&rect);
	pBanner->GetBitmap(&bm);
	
	// add offsets	
	rect.left += offset.left;
	rect.top += offset.top;

	rect.right = rect.left + bm.bmWidth + offset.right;
	rect.bottom = rect.top + bm.bmHeight + offset.bottom;
	ScreenToClient(&rect);
	if (rect.PtInRect(point))
		return TRUE;
	
	return FALSE;
*/

	// check if clicked on banner
	//offset.left = 0;
	//offset.top = 0;
	//offset.right = m_cx;
	//offset.bottom = m_cy;

	//ScreenToClient(&offset);
	if (offset.PtInRect(point))
		return TRUE;
	
	return FALSE;

}

void CGameAppView::PreviousWndEditSetFocus(BOOL bDefault)
{
	// default focus window if can't find previous edit window
	//if(!bDefault)
	//	m_sendEdit.SetFocus();
	//else
	m_snooker->PreviousWndEditSetFocus();
}


#if 0
void CGameAppView::InitRankings(void)
{// default don't update.
	m_rankingstick = 0;//RANKING_UPDATE_DELAY*GAMEAPP_FPS;
	m_rankingsfreq = 0;
}

void CGameAppView::SetRankingsFreq(int mins)
{
	int old;
	old = m_rankingsfreq;
	m_rankingsfreq = mins*60*GAMEAPP_FPS;
	if(old!=m_rankingsfreq) // if frequency of updation changed, then reset the ticker.
	m_rankingstick = m_rankingsfreq;
}

void CGameAppView::ProcessRankings(void) // No Longer Called! //
{
	#ifdef MAIN_SERVER
	
	#ifndef TEST_SERVER	// only on final build main server
	if(m_rankingstick)
	{
	m_rankingstick--;
	if(!m_rankingstick)
		{
		m_rankingstick = m_rankingsfreq;//RANKING_UPDATE_DELAY*GAMEAPP_FPS;

		CRanking *ranking;
		ranking = new CRanking;
		ranking->GetParent(this);
		
		// Writes the rankings locally to a file in the webshared folder.
		ranking->InitMembers(4096);
		ranking->LoadAllMembers();
		ranking->SortByRank();
		ranking->GenerateHTMLRANK(g_config.m_filenameRankings.GetBuffer(0));
		ranking->DeinitMembers();
		GetTime();
			{
			char _buffer[MAX_CHARS];
			sprintf(_buffer,"Updated %s at %s",g_config.m_filenameRankings.GetBuffer(0), m_stringShortTime);
			Message(_buffer,10); // personal message	
			}

		/*
		ranking->SetupLogin(NET_FTP_URL, NET_FTP_USER, NET_FTP_PASS, NET_FTP_DIR); // Note must pass statically allocated data e.g "ftp.blahblahblah"
		ranking->InitMembers(1024);
		ranking->LoadAllMembers();
		ranking->SortByRank();
		ranking->GenerateHTMLRANK(g_config.m_filenameRankings.GetBuffer(0));
		ranking->DeinitMembers();
		GetTime();
		
		if(ranking->UploadFile(g_config.m_filenameRankings.GetBuffer(0))==FALSE)
			{
			char _buffer[160];
			sprintf(_buffer,"Failed to update %s (%s) at %s",g_config.m_filenameRankings.GetBuffer(0),g_iNetErrorMessage, m_stringShortTime);
			Message(_buffer,10); // personal message
			}
		else {
			char _buffer[160];
			sprintf(_buffer,"Updated %s at %s",g_config.m_filenameRankings.GetBuffer(0), m_stringShortTime);
			Message(_buffer,10); // personal message	
			}
		*/

		delete ranking;
		}
	}
	#endif //!TEST_SERVER

 	#endif // MAINSERVER
}
#endif //0

// [CEventTimer] //

CEventTimer::CEventTimer()
{
	m_timeEvent = CTime::GetCurrentTime();	// Set Event to go off at a specific time, defaultly present time.
	m_timeFrequency = CTimeSpan(10);		// Frequency of Events.
}

CEventTimer::~CEventTimer()
{

}

void CEventTimer::Process(void)
{
	CTime timeCurrent = CTime::GetCurrentTime();

	while(timeCurrent - m_timeEvent>=0) // we have reached/gone past the event.
	{
		m_timeEvent+=m_timeFrequency; // Setup time for next event.
		OnEvent();
	}

}

void CEventTimer::OnEvent(void)
{
	
}


// ------------- //

CEventTimerMidnightWeekly::CEventTimerMidnightWeekly()
{


	m_timeEvent = CTime::GetCurrentTime(); // Get current time.
										   // set event to occur at midnight yesterday i.e. 1st second of this day (so it's already expired.) mean it'll happen straight away!
	
	// get day of the week, Sunday = 1, Monday = 2, Tus = 3, Wed = 4, Thu = 5, Fri = 6..... Saturday = 7
	int day = m_timeEvent.GetDayOfWeek();
	

	m_timeEvent = CTime(m_timeEvent.GetYear(),
		m_timeEvent.GetMonth(),
		m_timeEvent.GetDay(),
		0, 0, 0);

	// so we have the day of the week. (depending on which day, we need to offset this so it's Monday)
	// i.e. if day is 1 (Sun) then add 1 day
	// if day is 2 (Monday), then no nothing
	// if day is 3 (Tues) subtract 1 days..etc.
	// if day is 4 (Wed) subtract 2 days..etc.
	// need to add 7 days, to make it the following sunday (in future)

	if (day == 1) day = 1; // Sunday, so we need to add a day, to get next Monday
	else if (day == 2) day = 7; // add a week, to get next monday
	else if (day == 3) day = 6; // add a 6 days to get next monday
	else if (day == 4) day = 5; // add a 5 days to get next monday
	else if (day == 5) day = 4; // add a 4 days to get next monday
	else if (day == 6) day = 3; // add a 3 days to get next monday
	else if (day == 7) day = 2; // add a 2 days to get next monday


	//m_timeEvent += CTimeSpan(day-7, 0, 0, 0); // we reset ladder (for the upcoming Monday 00:00)  // Debug  previous Monday 00:00
	m_timeEvent += CTimeSpan(day, 0, 0, 0); // we reset ladder (for the upcoming Monday 00:00)


	// Now we should have Monday at 00:00..

	m_timeFrequency = CTimeSpan(7, 0, 0, 0); // this event occurs daily from now.


}

void CEventTimerMidnightWeekly::OnEvent()
{
	// Log the Ladder Results first, then update accounts with Cash Amounts
	
	// If <laddersave></laddersave> is not set, then don't save results...
	
	if (!g_laddersave) return;


	if (g_gameAppView)
	{
		g_gameAppView->ladderRankings->SaveResults();
	}


	// Reset those Ladder Rankings...
	ResetLadderRankings();

	// Log Results (for prizes)
}

// ------------- //

CEventTimerMIDNIGHT::CEventTimerMIDNIGHT()
{
	m_timeEvent = CTime::GetCurrentTime(); // Get current time.
	// set event to occur at midnight yesterday i.e. 1st second of this day (so it's already expired.) mean it'll happen straight away!
	m_timeEvent = CTime(m_timeEvent.GetYear(),
						m_timeEvent.GetMonth(),
						m_timeEvent.GetDay(),
						0,0,0);
	m_timeFrequency = CTimeSpan(1, 0,0,0); // this event occurs daily from now.
}

void CEventTimerMIDNIGHT::OnEvent(void) // This event is called every midnight (for clients and servers)
{

	
	#ifdef MAIN_SERVER
	
	// << -- Put it inside here
	if(!g_bTournamentLobby)
	{		
		if(g_config.m_mostRunOutsPrize)
		{
			// most RunOuts/High-Break prize (daily)
			#ifdef THE_POOL_CLUB		
			if(((CGameAppView *)g_wnd)->m_sLobbyHighBreak[0] >= 10)		// 8-ball
			#else
			if(((CGameAppView *)g_wnd)->m_sLobbyHighBreak[0] >= 100)	// semi-PRO
			#endif
			{				
				// give highbreak prize (1 day) to whoever?				
				((CGameAppView *)g_wnd)->TopUpPlayer(((CGameAppView *)g_wnd)->m_sLobbyHighBreakName[0].GetBuffer(0), 1);
			}
		
			#ifdef THE_POOL_CLUB		
			if(((CGameAppView *)g_wnd)->m_sLobbyPHighBreak[0] >= 10)	// 9-ball
			#else
			if(((CGameAppView *)g_wnd)->m_sLobbyPHighBreak[0] >= 100)	// PRO
			#endif
			{				
				// give highbreak prize (1 day) to whoever?				
				((CGameAppView *)g_wnd)->TopUpPlayer(((CGameAppView *)g_wnd)->m_sLobbyPHighBreakName[0].GetBuffer(0), 1);
			}	
			
			#ifdef THE_POOL_CLUB		
			if(((CGameAppView *)g_wnd)->m_sLobbyUKHighBreak[0] >= 4)	// English Pool
			#else
			if(((CGameAppView *)g_wnd)->m_sLobbyUKHighBreak[0] >= 50)	// 
			#endif
			{				
				// give highbreak prize (1 day) to whoever?				
				((CGameAppView *)g_wnd)->TopUpPlayer(((CGameAppView *)g_wnd)->m_sLobbyUKHighBreakName[0].GetBuffer(0), 1);
			}	
		}

		// clear high-break tables in lobby
		((CGameAppView *)g_wnd)->SendAllHighBreaksReset();
	}

	#endif // MAIN_SERVER
}

// ------------- //

CEventTimerOFTEN::CEventTimerOFTEN()
{
	m_timeEvent = CTime::GetCurrentTime(); // Get current time.
	// set event to occur at midnight yesterday i.e. 1st second of this day (so it's already expired.) mean it'll happen straight away!
	m_timeEvent = CTime(m_timeEvent.GetYear(),
						m_timeEvent.GetMonth(),
						m_timeEvent.GetDay(),
						m_timeEvent.GetHour(),(m_timeEvent.GetMinute()/30)*30,0);
	m_timeFrequency = CTimeSpan(0, 0,30,0); // this event occurs every 30mins from this point onwards.
}

void CEventTimerOFTEN::OnEvent(void) // This event is called every midnight (for clients and servers)
{
	#ifdef MAIN_SERVER
	#ifndef TEST_SERVER

	((CGameAppView *)g_wnd)->m_ipCoolDown->Process(); // Performed every 30 mins
	if(g_leader)
	{
		/*
CRanking *ranking;
		ranking = new CRanking;			
		ranking->GetParent( (CGameAppView *)g_wnd );
		
		// Writes the rankings locally to a file in the webshared folder.
		ranking->InitMembers(4096);
		ranking->LoadAllMembers();
		ranking->SortByRank();
		ranking->GenerateHTMLRANK(g_config.m_filenameRankings.GetBuffer(0));
		ranking->DeinitMembers();
		((CGameAppView *)g_wnd)->GetTime();
			{
			char _buffer[160];
			sprintf(_buffer,"Updated %s at %s",g_config.m_filenameRankings.GetBuffer(0), ((CGameAppView *)g_wnd)->m_stringShortTime);
			((CGameAppView *)g_wnd)->Message(_buffer,10); // personal message	
			}

delete ranking;
*/

/*	((CGameAppView *)g_wnd)->m_ranking->GenerateHTMLRANK(g_config.m_filenameRankings.GetBuffer(0));
	
	((CGameAppView *)g_wnd)->GetTime();
			{
			char _buffer[160];
			sprintf(_buffer,"Updated %s at %s",g_config.m_filenameRankings.GetBuffer(0), ((CGameAppView *)g_wnd)->m_stringShortTime);
			((CGameAppView *)g_wnd)->Message(_buffer,10); // personal message	
			}*/
	}
	#endif // !TEST_SERVER
	#endif // MAIN_SERVER
}

// ------------- //

CEventTimerMINUTE::CEventTimerMINUTE()
{
	m_timeEvent = CTime::GetCurrentTime(); // Get current time.
	// set event to occur at midnight yesterday i.e. 1st second of this day (so it's already expired.) mean it'll happen straight away!
	m_timeEvent = CTime(m_timeEvent.GetYear(),
						m_timeEvent.GetMonth(),
						m_timeEvent.GetDay(),
						m_timeEvent.GetHour(),m_timeEvent.GetMinute(),0);
	m_timeFrequency = CTimeSpan(0, 0,1,0); // this event occurs every minute from this point onwards.
	m_tick1 = 1;
	m_tick2 = 0;
	m_tick3 = 0;
	m_tick4 = 0;
	m_tick5 = 0; // Every 5 minutes, we get a list of upcoming Tournaments and set the next tournament data

}

void CEventTimerMINUTE::OnEvent(void) // This event is called every minute.
{
	//((CGameAppView *)g_wnd)->GetTime();
	//ErrorMessage(((CGameAppView *)g_wnd),((CGameAppView *)g_wnd)->m_stringFullTime.GetBuffer(0));
		
	#ifdef MAIN_SERVER
	//#ifndef TEST_SERVER

	// Post Server on Gateway.
	if(((CGameAppView *)g_wnd)->m_bGateopen)
	{
	((CGameAppView *)g_wnd)->PostLobby();
	((CGameAppView *)g_wnd)->ChangeTitle("");
	} else {
	((CGameAppView *)g_wnd)->ChangeTitle("Gates Closed");
	}
	// Set update transfers //
	g_lobbystat->m_xPlayers = ((CGameAppView *)g_wnd)->m_lobby->CountPlayers();

	// Update for this minute //
	g_lobbystat->UpdateMinute();

	m_tick1--;
	if(!m_tick1) // Every 1 minutes.
	{
		m_tick1=1;
		if(g_bTournamentLobby)
		((CGameAppView *)g_wnd)->UpdateTourney(); // Must be a tourney lobby.
	}

	//#endif // !TEST_SERVER
	#endif // MAIN_SERVER
}

// ------------- //

CEventTimerSECOND::CEventTimerSECOND()
{
	m_timeEvent = CTime::GetCurrentTime(); // Get current time.
	// set event to occur at midnight yesterday i.e. 1st second of this day (so it's already expired.) mean it'll happen straight away!
	m_timeEvent = CTime(m_timeEvent.GetYear(),
						m_timeEvent.GetMonth(),
						m_timeEvent.GetDay(),
						m_timeEvent.GetHour(),m_timeEvent.GetMinute(),m_timeEvent.GetSecond());
	m_timeFrequency = CTimeSpan(0, 0,0,1); // this event occurs every 10 seconds from this point onwards.
	m_tick1 = 0;
	m_tick2 = 0;
	m_tick3 = 0;
	m_tick4 = 0;
	m_tick5 = 0;
}

void CEventTimerSECOND::OnEvent(void) // This event is called every 10 secs
{

#ifndef MAIN_SERVER
	

	// Find Match Ctrl
	if (g_gameAppView)
	if (g_gameAppView->m_findMatchCtrl)
	{
		g_gameAppView->m_findMatchCtrl->OnOneSecondTimer();
	}

	/*
	m_tick1++;
	if(m_tick1>15) // every 15 seconds do lobby banner
	{
		m_tick1 = 0;
		((CGameAppView *)g_wnd)->m_bitmapBanner_idx++;
		if(((CGameAppView *)g_wnd)->m_bitmapBanner_idx>=((CGameAppView *)g_wnd)->m_bitmapBanner_n)
		((CGameAppView *)g_wnd)->m_bitmapBanner_idx = 0;


		((CGameAppView *)g_wnd)->m_bitmapSubBanner_idx++;
		if(((CGameAppView *)g_wnd)->m_bitmapSubBanner_idx>=((CGameAppView *)g_wnd)->m_bitmapSubBanner_n)
		((CGameAppView *)g_wnd)->m_bitmapSubBanner_idx = 0;

		// Update Lobby Banner if in lobby only.
		if(((CGameAppView *)g_wnd)->m_lobby->m_bInLobby)
		{

		}
	}
	*/
#endif


#ifdef MAIN_SERVER


		/*
		m_stringFullDate = m_time.Format("%A, %B %d, %Y");
		m_stringShortDate = m_time.Format("%a %b %d, %Y");

		m_stringFullTime = m_time.Format("%#I:%M:%S%p (GMT)");
		m_stringShortTime = m_time.Format("%H:%M:%S (GMT)");

		m_stringTimeStamp = m_time.Format("[%A, %B %d] %H:%M");


		m_ExpDateDay = m_time.GetDay();
		m_ExpDateMonth = m_time.GetMonth();NextTournamentData

		m_ExpDateYear = m_time.GetYear();
		*/

	
	
	((CGameAppView*)g_wnd)->ProcessEventBroadcasts();

	

	if (m_tick5) {
		m_tick5--;
	} else {
		 // Every 60 seconds get a list of next events
		((CGameAppView*)g_wnd)->GetNextEvent();
		m_tick5 = ((CGameAppView*)g_wnd)->m_lobbySettings->m_tourneybcPingSeconds;

		// total events
		// char sbuf[80];
		// sprintf(sbuf, "****total events: %d", ((CGameAppView*)g_wnd)->nextTournamentData.size());
		// AfxMessageBox(sbuf);
	}

	if(g_bTournamentLobby)
	{
		m_tick2++;
		if(m_tick2>=2) // every 2 seconds do tournament auto-invites and match table creation...
		{
			m_tick2 = 0;
			//ErrorMessage(((CGameAppView *)g_wnd), "ProcessAutoInvites()...");
			g_tournament.ProcessAutoInvites();
		}

		g_tournament.ProcessMatchOvers();	// do every second!
		g_tournament.ProcessMatchTimers();	// do every second!		
	}
	else
	{
		// normal lobbies only...
		m_tick4++;
		if(m_tick4>=5) // every 5 seconds do auto-invites for players that lost connection
		{
			m_tick4 = 0;
			//ErrorMessage(((CGameAppView *)g_wnd), "LostConnectionAutoInvites()...");
			((CGameAppView *)g_wnd)->m_lobby->LostConnectionAutoInvites();
		}

		m_tick2++;
		if (m_tick2 >= 2) // every 2 seconds do Ladder Match Processing & Invites
		{
			m_tick2 = 0;
			// Find Match
			((CGameAppView *)g_wnd)->m_lobby->ProcessFindMatchSetup(); // We will probably have to loop this.. 10 times, to makes sure it sets up all matches..

			/*
			((CGameAppView *)g_wnd)->m_lobby->ProcessFindMatchInvites();
			*/

			g_tournament.ProcessAutoInvites();
		}


		g_tournament.ProcessMatchOvers();	// do every second!
		g_tournament.ProcessMatchTimers();	// do every second!		
	}
#endif
}

// ------------- //

void CGameAppView::InitEventTimer(void)
{
	m_eventTimerMidnightWeekly = new CEventTimerMidnightWeekly();
	m_eventTimerMidnight = new CEventTimerMIDNIGHT();
	m_eventTimerOften = new CEventTimerOFTEN();
	m_eventTimerMinute = new CEventTimerMINUTE();
	m_eventTimerSecond = new CEventTimerSECOND();
}

void CGameAppView::DeInitEventTimer(void)
{
	delete m_eventTimerMidnightWeekly;
	delete m_eventTimerMidnight;
	delete m_eventTimerOften;
	delete m_eventTimerMinute;
	delete m_eventTimerSecond;
}

void CGameAppView::ProcessEventTimer(void)
{
	m_eventTimerMidnightWeekly->Process();
	m_eventTimerMidnight->Process();
	m_eventTimerOften->Process();
	m_eventTimerMinute->Process();
	m_eventTimerSecond->Process();
}

char *GetStrStart(char *str) // "    Hello" -> "Hello"
{
	int n;
	if(str==NULL) return NULL;
	for(n=0;n<80;n++) // find solid.
	{
	if(str[n]>32) break;
	if(!str[n]) return NULL; // No string
	}
	return &str[n];
}

char *GetStrEnd(char *str) // "Hello    " -> (Hello)"   "
{
	int n;
	if(str==NULL) return NULL;
	for(n=0;n<80;n++) // find solid.
	{
	if(!str[n]) return NULL; // No string
	if(str[n]<=32) break;	
	}
	return &str[n];
}

void GetStrWord(char *word, char *str)
{
	int n;
	if(str==NULL)
	{
	word[0] = 0;
	return;
	}
	for(n=0;n<80;n++) // find solid.
	{
	word[n] = str[n];
	if(str[n]<=32) break;
	}
	word[n] = 0;
}

//BOOL PM_SENT_BY_GUEST;

void CGameAppView::HandleServerMessage(char *str, int i)
{
	#ifdef MAIN_SERVER // don't let the clients know what special commands we've made, especially /crash & /sting
	char *command;
	char command_word[256];
	char *nextstr;
	int plrIdx;
	int mod_idx, mod_type;

	// ---------------------------------------------------------------------
	

	command = GetStrStart(str);
	GetStrWord(command_word, command);

	// check guest
	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return; // invalid player index!

		
	// Diable all commands if this person is a Guest //
	// 4 Checks, If the name starts with 'Guest' or if Rating=0 or is bIsGuest is Set //
	char tstr[128];
	char GNameCheck=0;
	strcpy(tstr, m_player[plrIdx].name);
	tstr[5] = 0; //GUEST0
	if(!strcmpi(tstr, "guest")) GNameCheck=1;
	
	if(m_player[plrIdx].rating ==0 || m_player[plrIdx].bIsGuest==TRUE || GNameCheck==1 || m_player[plrIdx].playertype==6)
		{
		char buffer[256];
		sprintf((char *)&buffer[2],"Option not available to Guests");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	/*if(m_player[plrIdx].bIsGuest) PM_SENT_BY_GUEST = TRUE;
	else PM_SENT_BY_GUEST = FALSE;*/

	// --------------------------------------------------------------------
	
	if(!strcmpi(command_word,"msg")) HandleServerMessageMSG(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"whisper")) HandleServerMessageMSG(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"time")) HandleServerMessageTIME(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"help")) HandleServerMessageHELP(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"stats")) HandleServerMessageSTATS(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"kick")) HandleServerMessageKICK(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"status")) HandleServerMessageSTATUS(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"available")) HandleServerMessageSETSTATUS(PLRSTATE_AVAILABLE,i);
	else if(!strcmpi(command_word,"here")) HandleServerMessageSETSTATUS(PLRSTATE_AVAILABLE,i);
	else if(!strcmpi(command_word,"busy")) HandleServerMessageSETSTATUS(PLRSTATE_BUSY,i);
	else if(!strcmpi(command_word,"brb")) HandleServerMessageSETSTATUS(PLRSTATE_BRB,i);
	else if(!strcmpi(command_word,"away")) HandleServerMessageSETSTATUS(PLRSTATE_AWAY,i);
	else if(!strcmpi(command_word,"phone")) HandleServerMessageSETSTATUS(PLRSTATE_PHONE,i);
	else if(!strcmpi(command_word,"lunch")) HandleServerMessageSETSTATUS(PLRSTATE_LUNCH,i);
	else if(!strcmpi(command_word,"dnd")) HandleServerMessageSETSTATUS(PLRSTATE_DND,i);
	//else if(!strcmpi(command_word,"hostcheck")) HandleServerMessageHOSTCHECK(i);
	else if(!strcmpi(command_word,"ban")) HandleServerMessageBAN(GetStrStart(GetStrEnd(command)),i);
	else if(!strcmpi(command_word,"unban")) HandleServerMessageUNBAN(GetStrStart(GetStrEnd(command)),i);
	//else if(!strcmpi(command_word,"hostchecktimeout")) HandleServerMessageHOSTCHECKTIMEOUT(GetStrStart(GetStrEnd(command)),i);
	else if(!strcmpi(command_word,"greeting")) HandleServerMessageGREETING(GetStrStart(GetStrEnd(command)),i);
	else if(!strcmpi(command_word,"cleartable")) HandleServerMessageCLEARTABLE(GetStrStart(GetStrEnd(command)),i);
	else if(!strcmpi(command_word,"broadcast")) HandleServerMessageBROADCAST(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"bc")) HandleServerMessageBROADCAST(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"mods")) HandleServerMessageMODS(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"gate")) HandleServerMessageGATE(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"server")) HandleServerMessageSERVER(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"sting")) HandleServerMessageSTING(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"crash")) HandleServerMessageCRASH(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"wall")) HandleServerMessageWallDenyBlock(GetStrStart(GetStrEnd(command)), i, 0);
	else if(!strcmpi(command_word,"unwall")) HandleServerMessageUnWallDenyBlock(GetStrStart(GetStrEnd(command)), i, 0);
	else if(!strcmpi(command_word,"deny")) HandleServerMessageWallDenyBlock(GetStrStart(GetStrEnd(command)), i, 1);
	else if(!strcmpi(command_word,"undeny")) HandleServerMessageUnWallDenyBlock(GetStrStart(GetStrEnd(command)), i, 1);
	else if(!strcmpi(command_word,"block")) HandleServerMessageWallDenyBlock(GetStrStart(GetStrEnd(command)), i, 2);
	else if(!strcmpi(command_word,"unblock")) HandleServerMessageUnWallDenyBlock(GetStrStart(GetStrEnd(command)), i, 2);
	else if(!strcmpi(command_word,"debug")) HandleServerMessageDEBUG(GetStrStart(GetStrEnd(command)), i);
	//else if(!strcmpi(command_word,"addmod")) HandleServerMessageADDMOD(GetStrStart(GetStrEnd(command)), i);
	//else if(!strcmpi(command_word,"delmod")) HandleServerMessageDELMOD(GetStrStart(GetStrEnd(command)), i);
	//else if(!strcmpi(command_word,"modlist")) HandleServerMessageMODLIST(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"rating")) HandleServerMessageRATING(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"players")) HandleServerMessagePLAYERS(GetStrStart(GetStrEnd(command)), i);
	//else if(!strcmpi(command_word,"text")) HandleServerMessageTEXT(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"cue")) HandleServerMessageCUE(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"chalk")) HandleServerMessageCHALK(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"buy")) HandleServerMessageBUY(GetStrStart(GetStrEnd(command)), i);
	//else if(!strcmpi(command_word,"sell")) HandleServerMessageSELL(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"autoinvite")) HandleServerMessageAUTOINVITE(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"clearmostrunouts")) HandleServerMessageCLEARMOSTRUNOUTS(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"clearhighbreaks")) HandleServerMessageCLEARHIGHBREAKS(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"mostrunouts")) HandleServerMessageMOSTRUNOUTS(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"leaderboard")) HandleServerMessageLEADERBOARD(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"mute")) HandleServerMessageMUTE(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"unmute")) HandleServerMessageUNMUTE(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"topup")) HandleServerMessageTOPUP(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"sysid")) HandleServerMessageSYSID(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"macid")) HandleServerMessageMACID(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"sponsor")) HandleServerMessageSPONSOR(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"sponsorurl")) HandleServerMessageSPONSORURL(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"sponsorback")) HandleServerMessageSPONSORBACK(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"stealth")) HandleServerMessageSTEALTH(GetStrStart(GetStrEnd(command)), i);
	else if(!strcmpi(command_word,"unstealth")) HandleServerMessageUNSTEALTH(GetStrStart(GetStrEnd(command)), i);
	else { // Invalid Command!
	HandleServerMessageInvalid(command_word, i);
	}
	#endif
}

void CGameAppView::HandleServerMessageInvalid(char *str, int i)
{ // Invalid command. should give a help for now just return Invalid Command
	unsigned char buffer[256];

	sprintf((char *)&buffer[2],"Invalid Command '/%s' type '/help' for a list of commands",str);

	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
}

void CGameAppView::HandleServerMessageMSG(char *str, int i)
{ // "/msg <user_name> <message>"
	//char name[80];
	char name[256];
	char *message;
	unsigned char buffer[256];
	int n;
	int sockIdx;
	int plrIdx;
	
	/*
	plrIdx = m_lobby->GetPlayerIdx(i);
	if(m_player[plrIdx].state2&PLRSTATE2_MUTE)
	{
	sprintf((char *)&buffer[2],"Can't send private messages, you have been muted!");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}
	*/

	if(str==NULL)
	{
	sprintf((char *)&buffer[2],"Usage: /msg <user> <message>");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}
	GetStrWord(name, str);

	message = GetStrStart(GetStrEnd(str));
	if(message==NULL)
	{
	sprintf((char *)&buffer[2],"Usage: /msg <user> <message>");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}	
		
	sockIdx = m_lobby->FindPlayerSockIdxi(name); // Get socket index of player you wish to message.noncase sensi.
	if(sockIdx==-1)
	{
	sprintf((char *)&buffer[2],"User '%s' is not online", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
	else {
	// check if player status is 'available'
	plrIdx = m_lobby->GetPlayerIdx(sockIdx);
	int state = m_player[plrIdx].state&PLRSTATE_STATUSMASK;
	if(state == PLRSTATE_BUSY || state == PLRSTATE_DND)
	{
		switch(state)
		{
		case PLRSTATE_BUSY:
		sprintf((char *)&buffer[2],"User '%s' is Busy", name);
		break;
		/*
		case PLRSTATE_BRB:
		sprintf((char *)&buffer[2],"User '%s' will Be Right Back", name);
		break;
		case PLRSTATE_AWAY:
		case PLRSTATE_AWAY2:
		sprintf((char *)&buffer[2],"User '%s' is Away", name);
		break;
		case PLRSTATE_PHONE:
		sprintf((char *)&buffer[2],"User '%s' is on the Phone", name);
		break;
		case PLRSTATE_LUNCH:
		sprintf((char *)&buffer[2],"User '%s' is out to Lunch", name);
		break;
		*/
		case PLRSTATE_DND:
		sprintf((char *)&buffer[2],"User '%s' is not to be Disturbed!", name);
		break;
		}
		//sprintf((char *)&buffer[2],"User '%s' is not available", name);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
	} // end if
	

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;

	// Tell Sender that message is being sent.
	sprintf((char *)&buffer[3],"To %s: %s", name, message);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfc; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
	buffer[2] = m_player[plrIdx].level;
	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[3])+4, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap +1 for level.

	// Send message to the player.
	sprintf((char *)&buffer[3],"From %s: %s", m_player[plrIdx].name, message);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfc; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
	buffer[2] = m_player[plrIdx].level;
	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[3])+4, sockIdx); // +1 for Ter, +1 for Code at beginning +1 for sender gap, +1 for level.
	} // end else
}

void CGameAppView::HandleServerMessageTIME(char *str, int i)
{
	unsigned char buffer[256];
	GetTime();
	
	sprintf((char *)&buffer[2],"Server Time: %s",m_stringShortTime);//m_stringFullTime);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
}

void CGameAppView::HandleServerMessageHELP(char *str, int i)
{
	char command[80];
	unsigned char buffer[2048];//256]; // !!Careful 256 byte limit!
	if(str==NULL) // '/help'
	{
	if(mainShell)
	{
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
  
	sprintf((char *)&buffer[2],"Commands: HELP, MSG, r , WHISPER, TIME, STATS, STATUS, AVAILABLE, HERE, BUSY, BRB, AWAY, PHONE, LUNCH, DND, PLAYERS, TEXT, BUY");
	mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

	// extra help commands - for Admin only
	int plrIdx;
	int mod_idx;
	int mod_type;
	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Ranking
	
	char cmd_a[256];
	char cmd_m[256];
	char cmd_s[256];
	char cmd_sm[256];


	sprintf(cmd_a, "kick, ban, block, wall, deny, unban, unblock, unwall, undeny, gate, server, rating, autoinvite, clearmostrunouts, mostrunouts, stealth, unstealth, greeting, sponsor, broadcast, mods, cleartable");
	sprintf(cmd_s, "kick, ban, block, wall, deny, unban, unblock, unwall, undeny, mute, rating, autoinvite, mostrunouts, greeting, broadcast, mods");
	sprintf(cmd_m, "kick, ban, block, mute, broadcast, mods");
	sprintf(cmd_sm, "kick, ban, wall, deny, block, mute, broadcast, mods, greeting");
	

	if(mod_type==0) // 0 = Admin
		{
		sprintf((char *)&buffer[2],"%s", cmd_a);
		mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		}
	else if(mod_type==1) // 1 = Moderators
		{
		sprintf((char *)&buffer[2],"%s", cmd_m);
		mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		}
	else if(mod_type==2) // 2 = Senior Mods
		{
		sprintf((char *)&buffer[2],"%s", cmd_s);
		mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		}
	else if(mod_type==3) // 3 = Special Mods
		{
		sprintf((char *)&buffer[2],"%s", cmd_sm);
		mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		}
	////////////////////////////////////////

	sprintf((char *)&buffer[2],"Type '/help <command>' for more information on a command");
	mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
	return;
	}
	// '/help <command>'
	GetStrWord(command, str);
	if(!strcmpi(command,"help"))
	{
	sprintf((char *)&buffer[2],"/help Displays a list of commands");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
	else
	if(!strcmpi(command,"msg") || !strcmpi(command,"whisper"))
	{
	sprintf((char *)&buffer[2],"/msg Sends a private message to a user");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	} 
	else
	if(!strcmpi(command,"players"))
	{
	sprintf((char *)&buffer[2],"/players Displays total number of player in this lobby");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	} 
	else
	{
	sprintf((char *)&buffer[2],"Sorry no help on command '/%s'", command);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
}

void CGameAppView::HandleServerMessageSTATS(char *str, int i)
{
	unsigned char buffer[256];
	int plrIdx;
	int mod_type;
	char stats[256];

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;

	
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type>3) sprintf(stats,"[NORMAL ACCOUNT]");
	else sprintf(stats,"[MODERATOR-%d]",mod_type);

	sprintf((char *)&buffer[2],"Stats for %s: %s",m_player[plrIdx].name,stats);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
}

void CGameAppView::HandleServerMessageKICK(char *str, int i)
{
	unsigned char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	int mod_type;
	int kmod_type;
	char name[256];
	char *message;
	//char *name;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;

	
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	if(mod_type>3 || mod_type<0)
		{
		sprintf((char *)&buffer[2],"Only Admins / Moderators can kick users off server");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	
	GetStrWord(name, str);
	message = GetStrStart(GetStrEnd(str));
	
	if(str==NULL) //name==NULL)
		{
		sprintf((char *)&buffer[2],"Usage: /kick <user> [reason]\r\nWarning this command kicks a user off the whole server!");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	
	// name is a proper name.
	sockIdx = m_lobby->FindPlayerSockIdxi(name); // Get socket index of player you wish to message.noncase sensi.
	if(sockIdx==-1) // do other, full name e.g. "Freeda Reds" case-sensi string compare aswell.
	sockIdx = m_lobby->FindPlayerSockIdx(name); // Get socket index of player you wish to message.noncase sensi.

	if(sockIdx==-1)
	{
	sprintf((char *)&buffer[2],"User '%s' is not online", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
	else {
	
	kmod_type = GetPlayerType(name); // Get the Mod Type

	if(kmod_type<0 || (kmod_type==6 && sockIdx==-1) ) 
		{
		sprintf((char *)&buffer[2],"'%s' doesn't exist", name);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	

	if(kmod_type<=mod_type)
		{
		sprintf((char *)&buffer[2],"Can't kick Admin / Moderator '%s' (%d)", name, kmod_type);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	// so we can kick here.
	sprintf((char *)&buffer[2],"Kicking '%s'", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

	{
	char str[256];
	sprintf(str,"%s %s: %s Kicked '%s'", m_stringShortDate, m_stringShortTime, m_player[plrIdx].name, name);
	AddLog("LogModerators.txt", str);
	}


	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 73;		// MSGGAME_KICK
	buffer[2] = 0;
	buffer[3] = 0;		// Reason flag.

	if(!message)
	{
	if(mainShell) mainShell->Server->SendToQueue(buffer, 4, sockIdx); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
	else {
	buffer[3] = 1; // reason supplied.
	sprintf((char *)&buffer[4],"%s", message);
	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[4])+5, sockIdx); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
	
	// [+] Kick Timeout 5 seconds as last pre-caution
		
//	((CSocketEx *)mainShell->Server->m_socketList[sockIdx])->Kick();
	} // end else
}

void CGameAppView::HandleServerMessageSTATUS(char *str, int i)
{
	unsigned char buffer[256];
	int plrIdx;
	int sockIdx;
	char stats[256];

	plrIdx = -1;
	if(str==NULL)
	{
	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	sprintf((char *)&buffer[2],"Your status is currently set to: %s (#%d)",g_status_strlst[m_player[plrIdx].state&PLRSTATE_STATUSMASK],m_player[plrIdx].id);
	}
	else {
	sockIdx = m_lobby->FindPlayerSockIdxi(str);
	if(sockIdx==-1)
	sockIdx = m_lobby->FindPlayerSockIdx(str);

	if(sockIdx==-1)
		{
		sprintf((char *)&buffer[2],"User '%s' is not online", str);
		}
	else {
		plrIdx = m_lobby->GetPlayerIdx(sockIdx);
		sprintf((char *)&buffer[2],"%s's status is currently set to: %s (#%d)",str, g_status_strlst[m_player[plrIdx].state&PLRSTATE_STATUSMASK],m_player[plrIdx].id);
		}
	}
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.



	return;
}

void CGameAppView::HandleServerMessageSETSTATUS(BYTE state, int i)
{
	unsigned char buffer[256];
	int plrIdx;
	char stats[256];

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	//mod_idx = m_moderator->CheckName(m_player[plrIdx].name);
	//if(mod_idx==-1) sprintf(stats,"[NORMAL ACCOUNT]");
	//else sprintf(stats,"[MODERATOR-%d]",mod_idx);

	m_player[plrIdx].state&=PLRSTATE_STATUSMASK^PLRSTATE_MASK; // destroy status bits
	m_player[plrIdx].state|= state;

	sprintf((char *)&buffer[2],"Status changed to: %s",g_status_strlst[m_player[plrIdx].state&PLRSTATE_STATUSMASK]);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

	SendPlayerChangeData(plrIdx, PLAYERCHANGE_STATUS);
	return;
}

void CGameAppView::HandleServerMessageHOSTCHECK(int i)
{
	unsigned char buffer[256];
	sprintf((char *)&buffer[2],"Host checking");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) {
				  mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

				  // Tell client to set up a temp hosting socket, and server will attempt to join it!

				  buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
				  buffer[1] = 70;		// MSGGAME_HOSTCHECK
				  buffer[2] = 0;
				  buffer[3] = 0;

				  mainShell->Server->SendToQueue(buffer, 4, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
				  }
	return;
}

void CGameAppView::HandleServerMessageBAN(char *str, int i)
{
	unsigned char buffer[256];
	int sockIdx;
	int plrIdx;
	int mod_type;
	int kmod_type;
	char name[256];
	char *message;
	int banflag;
	banflag = 0;//

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	if(mod_type>3 || mod_type<0)
		{
		sprintf((char *)&buffer[2],"Only Admins / Moderators can ban users");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	
	GetStrWord(name, str);
	message = GetStrStart(GetStrEnd(str));
	if(str==NULL) //name==NULL)
		{
		sprintf((char *)&buffer[2],"Usage: /ban <user>\r\nWarning this command kicks a user off the whole server!");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	
	
	kmod_type = GetPlayerType(name); // Get the Mod Type of Banee
	
	if(kmod_type<0 || kmod_type==6) 
		{
		if(kmod_type==6) sprintf((char *)&buffer[2],"Sorry, cannot Ban Guests.");
			else sprintf((char *)&buffer[2],"'%s' doesn't exist", name);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	if(kmod_type<=mod_type)
		{
		sprintf((char *)&buffer[2],"Can't ban Admin / Moderator '%s' (%d)", name,kmod_type);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	// so we can Ban here.
	sprintf((char *)&buffer[2],"Banning '%s'", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.


	if(GetMemberIDEx(name)==-1)
		{
		sprintf((char *)&buffer[2],"'%s' Doesn't exist", name,kmod_type);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	int status = BanPlayer(name);
	if(status==TRUE) 
		{
		sprintf((char *)&buffer[2],"Player %s has been Banned", name);
		banflag=1;

		{
		char str[256];
		sprintf(str,"%s Banned '%s'",m_player[plrIdx].name,name);
		AddLog("LogModerators.txt", str);
		}

		}
	else if(status==FALSE) sprintf((char *)&buffer[2],"Player %s is already Banned", name);
		

	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

	if(banflag)
		{
		// Kick player if he's online!
		sockIdx = m_lobby->FindPlayerSockIdxi(name); // Get socket index of player you wish to message.noncase sensi.
		if(sockIdx==-1) // do other, full name e.g. "Freeda Reds" case-sensi string compare aswell.
		sockIdx = m_lobby->FindPlayerSockIdx(name); // Get socket index of player you wish to message.noncase sensi.

		if(sockIdx!=-1)
			{
			buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
			buffer[1] = 73;		// MSGGAME_KICK
			buffer[2] = 1;		// Ban flag.
			buffer[3] = 0;		// Reason flag. - no reason for now, can't be assed to code a reason.

			if(mainShell) mainShell->Server->SendToQueue(buffer, 4, sockIdx); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
			}
		}
	
}


void CGameAppView::HandleServerMessageUNBAN(char *str, int i)
{
	// move player into banned directory.
	unsigned char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	char name[256];
	char *message;
	int mod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	

	if(mod_type==MODTYPE_LEADMODERATOR || mod_type==MODTYPE_ADMIN); // Lead Moderators & Admin can use this command
	else
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}

	GetStrWord(name, str);
	message = GetStrStart(GetStrEnd(str));

	if(str==NULL)
		{
		sprintf((char *)&buffer[2],"Usage: /unban <user>\r\nThis command unbans and previously banned player");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	int ps = PlayerStatus(name);

	if(ps&2) //==PLAYER_BANNED)
		{
		BOOL status = UnbanPlayer(name);
		sprintf((char *)&buffer[2],"Player %s has been unbanned", name);

		{
		char str[256];
		sprintf(str,"%s Unbanned '%s'",m_player[plrIdx].name,name);
		AddLog("LogModerators.txt", str);
		}

		}
	else{
		if(ps==PLAYER_INVALID) sprintf((char *)&buffer[2],"Error: Player %s doesn't exist", name);
			else sprintf((char *)&buffer[2],"Error: Player %s is not banned", name);
		}

	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
}

void CGameAppView::HandleServerMessageMUTE(char *str, int i)
{ // "/msg <user_name> <message>"
	//char name[80];
	char name[256];
	char *message;
	unsigned char buffer[256];
	int n;
	int sockIdx;
	int plrIdx;
	int mod_type;
	int kplrIdx;
	int kmod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	

	if(mod_type>3 || mod_type<0)
		{
		sprintf((char *)&buffer[2],"Only Admins / Moderators can mute users");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	if(str==NULL)
	{
	sprintf((char *)&buffer[2],"Usage: /mute <user>");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}
	GetStrWord(name, str);

	
	sockIdx = m_lobby->FindPlayerSockIdxi(name); // Get socket index of player you wish to message.noncase sensi.
	if(sockIdx==-1)
	{
	sprintf((char *)&buffer[2],"User '%s' is not online", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
	else {



	kplrIdx = m_lobby->GetPlayerIdx(sockIdx); // get player index of kickee.
	kmod_type = GetPlayerType(name); // Get the Mod Type of Banee

	if(kmod_type<0 || (kmod_type==6 && sockIdx==-1) ) 
		{
		sprintf((char *)&buffer[2],"'%s' doesn't exist", name);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	if(kmod_type<=mod_type)
		{
		sprintf((char *)&buffer[2],"Can't mute Admin / Moderator '%s' (%d)", name,kmod_type);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	if(kplrIdx!=-1)
		{
	m_player[kplrIdx].state2|=PLRSTATE2_MUTE;
	if(kmod_type!=6) SavePlayer(m_player[kplrIdx].name, &m_player[kplrIdx]); // Guests have no account
	{
	char str[256];
	sprintf(str,"%s Muted '%s'",m_player[plrIdx].name,name);
	AddLog("LogModerators.txt", str);
	}

	sprintf((char *)&buffer[2],"User '%s' has been muted", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		}
	} // end if
}

void CGameAppView::HandleServerMessageUNMUTE(char *str, int i)
{ // "/msg <user_name> <message>"
	//char name[80];
	char name[256];
	char *message;
	unsigned char buffer[256];
	int n;
	int sockIdx;
	int plrIdx;
	int mod_type;
	int kplrIdx;
	int kmod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type>3 || mod_type<0)
		{
		sprintf((char *)&buffer[2],"Only Admins / Moderators can unmute users");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	if(str==NULL)
	{
	sprintf((char *)&buffer[2],"Usage: /unmute <user>");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}
	GetStrWord(name, str);

	
	sockIdx = m_lobby->FindPlayerSockIdxi(name); // Get socket index of player you wish to message.noncase sensi.
	if(sockIdx==-1)
	{
	sprintf((char *)&buffer[2],"User '%s' is not online", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
	else {

	kplrIdx = m_lobby->GetPlayerIdx(sockIdx); // get player index of kickee.
	kmod_type = GetPlayerType(name); // Get the Mod Type of Banee

	if(kmod_type<0 || (kmod_type==6 && sockIdx==-1) )
		{
		if(kmod_type==6) sprintf((char *)&buffer[2],"Sorry, cannot Ban, Wall, Block, Deny Guests. This will be fixed very soon");
			else sprintf((char *)&buffer[2],"'%s' doesn't exist", name);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	
	if(kmod_type<=mod_type)
		{
		sprintf((char *)&buffer[2],"Can't unmute Admin / Moderator '%s' (%d)", name,kmod_type);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	if(kplrIdx!=-1)
		{
	m_player[kplrIdx].state2|=PLRSTATE2_MUTE; // force to 1
	m_player[kplrIdx].state2^=PLRSTATE2_MUTE; // force to 0
	if(kmod_type!=6) SavePlayer(m_player[kplrIdx].name, &m_player[kplrIdx]); // Guests have no Account
	{
	char str[256];
	sprintf(str,"%s Unmuted '%s'",m_player[plrIdx].name,name);
	AddLog("LogModerators.txt", str);
	}

	sprintf((char *)&buffer[2],"User '%s' has been unmuted", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		}
	} // end if
}

void CGameAppView::HandleServerMessageHOSTCHECKTIMEOUT(char *str, int i)
{
	unsigned char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	int mod_type;
	char name[256];
	char *message;
	int oldsecs;
	int secs;


	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type>3 || mod_type<0)
		{
		sprintf((char *)&buffer[2],"Only Admins / Moderators can use this command");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}




	secs = -1;
	if(str==NULL)
		{
		sprintf((char *)&buffer[2],"Usage: /hostchecktimeout <seconds>");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		}
	else	{
			oldsecs = m_hostchecktimeoutK/GAMEAPP_FPS;

			sscanf(str,"%d",&secs);

			m_hostchecktimeoutK = GAMEAPP_FPS*secs;

			sprintf((char *)&buffer[2],"Setting Host-Checking Timeout to %d seconds (was %d seconds)", secs, oldsecs);
			buffer[0] = MSGCODE_TEXT;
			buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
			}

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
}

char *tfmt_color_lst[] = {
"Normal", // 0
"Blue",
"Peach",
"Pink",
"Mud",
"Red",
"Yellow",
"LtBlue",
"Green", // 8
"Tan",
"Jade",
"Rose",
"SoftGreen",
"White",
"White",
"White", // 15
// ---------------------- //
"ABlue",
"APurple",
"AOrange",
"ATeal",
"MRed",
"MBlue",
"MYellow",
"MGreen",
"MGray",
};

DWORD tfmt_colorrgb_lsta[] = {
RGB(215,215,215),		// Normal/Default
RGB(64,150,236),		// Blue
RGB(255,202,99),		// Peach
RGB(255,187,255),		// Pink
RGB(158,145,118),		// Mud
RGB(255,85,85),			// Red
RGB(225,225,110),		// Yellow
RGB(166,255,255),		// Ocean
RGB(0,249,0),			// Green (8)
RGB(182,182,107),		// Tan
RGB(110,240,213),		// Jade
RGB(255,0,128),			// Rose
RGB(159,255,159),		// SoftGreen
RGB(255,255,255),		// Unused
RGB(255,255,255),		// Unused
RGB(255,255,255),		// Unused (15)


RGB(33,188,233), 		// ABlue (16)
RGB(168,0,168),			// APurple (17)
RGB(255,167,79),		// AOrange (18)
RGB(0,125,125),			// ATeal (19)
RGB(217,0,0),			// MRed (21)
RGB(0,87,174),			// MBlue (22)
RGB(210,210,0),			// MYellow (23)
RGB(0,174,0),			// MGreen (24)
RGB(255,255,255),		// MWhite (25)
};

DWORD tfmt_colorrgb_lstb[] = {
RGB(5,5,5),				// Normal/Default
RGB(64,150,236),		// Blue
RGB(219,162,52),		// Peach
RGB(212,47,212),		// Pink
RGB(105,88,52),			// Mud
RGB(235,0,0),			// Red
RGB(190,190,0),			// Yellow
RGB(2,163,92),			// Ocean
RGB(0,220,0),			// Green (8)
RGB(147,122,67),		// Tan
RGB(57,149,130),		// Jade
RGB(255,0,128),			// Rose
RGB(102,172,102),		// SoftGreen
RGB(255,255,255),		// Unused
RGB(255,255,255),		// Unused
RGB(255,255,255),		// Unused (15)

RGB(18,158,199), 		// ABlue (16)
RGB(145,0,145),			// APurple (17)
RGB(206,122,37),		// AOrange (18)
RGB(0,125,125),			// ATeal (19)
RGB(168,17,17),			// MRed (21)
RGB(0,87,174),			// MBlue (22)
RGB(150,150,0),			// MYellow (23)
RGB(0,174,0),			// MGreen (24)
RGB(65,65,65),			// MGray (25)
};

DWORD tfmt_colorrgbadjust_lst[] = { // note: this is used only for names of players (labels) to distinguish between text
RGB(128,128,128),		// Grey // (0)
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(15,15,15),			// Normal/Default
RGB(128,128,128),		// Grey (8)
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey (15)

RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey
RGB(128,128,128),		// Grey


};

/*
void CGameAppView::HandleServerMessageTEXT(char *str, int i) // for admin only
{
	// Adjust a player's rating.
	char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	int mod_idx;																   
	int kmod_idx;
	char format[256];
	char *message;
	int banflag;
	int mod_type;
	int supermod;
	char inv[256];
	unsigned char not_purchased;
	char text_buf[512];

	format[0] = 0;
	banflag = 0;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type>4) 
		{
		// Don't Let Trialists Use Text Command //
		SendServerMessage("This feature is only available to Registered Members", i);
		return;
		}

	
	/////
	if(mod_type==MODTYPE_LEADMODERATOR) supermod = 1;
	else if(mod_type==MODTYPE_ADMIN) supermod = 2;
	else if(mod_type==MODTYPE_MODERATOR || mod_type==MODTYPE_SMODERATOR) supermod=0;
	else supermod=-1;
	
	GetStrWord(format, str);
	message = GetStrStart(GetStrEnd(str));



	// Get a List of Colours player's have purchased //
	strcpy(inv, "Normal");
	if(m_player[plrIdx].inventory&1) strcat(inv, " | blue");
	if(m_player[plrIdx].inventory&2) strcat(inv, " | peach");
	if(m_player[plrIdx].inventory&4) strcat(inv, " | pink");
	if(m_player[plrIdx].inventory&8) strcat(inv, " | mud");
	if(m_player[plrIdx].inventory&16) strcat(inv, " | red");
	if(m_player[plrIdx].inventory&32) strcat(inv, " | yellow");
	if(m_player[plrIdx].inventory&64) strcat(inv, " | ltblue");
	if(m_player[plrIdx].inventory&128) strcat(inv, " | green");
	if(m_player[plrIdx].inventory&256) strcat(inv, " | tan");
	if(m_player[plrIdx].inventory&512) strcat(inv, " | jade");
	if(m_player[plrIdx].inventory&1024) strcat(inv, " | rose");
	if(m_player[plrIdx].inventory&2048) strcat(inv, " | softgreen");


	if(str==NULL)
		{
		// Show the User Which Colours they have ///
		if(supermod==-1) sprintf(text_buf, "Usage: /text %s\r\nThis command changes the Text Color. Use '/buy' to purchase new text colors", inv);
		else if(supermod==0) sprintf(text_buf, "Usage: /text %s\r\nExtra: mred | mblue | myellow | mgreen |mgray\r\nThis command changes the Text Color. Use '/buy' to purchase new text colors", inv);
		else sprintf(text_buf, "Usage: /text %s\r\nExtra: ablue | apurple | aorange | ateal | mred | mblue | myellow | mgreen | mgray\r\nThis command changes the Text Color. Use '/buy' to purchase new text colors", inv);
				
		SendServerMessage(text_buf, i);
		return;		
		}

	else {
			int textFormat = TEXTFORMAT_DEFAULT;
			int val = -1;
			char *ptr;
			
			if(str[0] == '+' || format[0] == '-') ptr = &format[1];
			else ptr = format;

			textFormat = m_player[plrIdx].textFormat;

			//// Only Mods, Senior Mods and Admins get these styles ////
			if(supermod>-1)
				{
				if( strcmpi(ptr, "italic") == 0 ) val = TEXTFORMAT_ITALIC;
				//if( strcmpi(ptr, "underline") == 0 ) val = TEXTFORMAT_UNDERLINE;
				}
			
			
			if( strcmpi(ptr, "bold") == 0 )
				{
				if(supermod==2) val = TEXTFORMAT_BOLD;
				else{
					// Only Admins get this //
					SendServerMessage("This feature is only available to Admins", i);
					return;
					}
				}
			
			if( strcmpi(ptr, "comic") == 0 )
				{
				if(supermod>-1) val = TEXTFORMAT_COMIC;
				else{
					// Only Admins get this //
					SendServerMessage("This feature is only available to Mods, Senior Mods & Admins", i);
					return;
					}
				}
			


			if( strcmpi(ptr, "normal") == 0 ) val = TEXTFORMAT_DEFAULT;

			/////// The Inventory Colors.. So must check that we have purchased these before allowing use ///
			not_purchased=0;
			if( strcmpi(ptr, "blue") == 0 ) 
				{
				val = TEXTFORMAT_BLUE;
				if(!(m_player[plrIdx].inventory&1)) not_purchased=1;
				}
			else if( strcmpi(ptr, "peach") == 0 ) 
				{
				val = TEXTFORMAT_PEACH;
				if(!(m_player[plrIdx].inventory&2)) not_purchased=1;
				}
			else if( strcmpi(ptr, "pink") == 0 ) 
				{
				val = TEXTFORMAT_PINK;
				if(!(m_player[plrIdx].inventory&4)) not_purchased=1;
				}
			else if( strcmpi(ptr, "mud") == 0 ) 
				{
				val = TEXTFORMAT_MUD;
				if(!(m_player[plrIdx].inventory&8)) not_purchased=1;
				}
			else if( strcmpi(ptr, "red") == 0 ) 
				{
				val = TEXTFORMAT_RED;
				if(!(m_player[plrIdx].inventory&16)) not_purchased=1;
				}
			else if( strcmpi(ptr, "yellow") == 0 ) 
				{
				val = TEXTFORMAT_YELLOW;
				if(!(m_player[plrIdx].inventory&32)) not_purchased=1;
				}
			else if( strcmpi(ptr, "ltblue") == 0 ) 
				{
				val = TEXTFORMAT_LTBLUE;
				if(!(m_player[plrIdx].inventory&64)) not_purchased=1;
				}
			else if( strcmpi(ptr, "green") == 0 ) 
				{
				val = TEXTFORMAT_GREEN;
				if(!(m_player[plrIdx].inventory&128)) not_purchased=1;
				}
			else if( strcmpi(ptr, "tan") == 0 ) 
				{
				val = TEXTFORMAT_TAN;
				if(!(m_player[plrIdx].inventory&256)) not_purchased=1;
				}
			else if( strcmpi(ptr, "jade") == 0 ) 
				{
				val = TEXTFORMAT_JADE;
				if(!(m_player[plrIdx].inventory&512)) not_purchased=1;
				}
			else if( strcmpi(ptr, "rose") == 0 ) 
				{
				val = TEXTFORMAT_ROSE;
				if(!(m_player[plrIdx].inventory&1024)) not_purchased=1;
				}
			else if( strcmpi(ptr, "softgreen") == 0 ) 
				{
				val = TEXTFORMAT_SOFTGREEN;
				if(!(m_player[plrIdx].inventory&2048)) not_purchased=1;
				}
			
			if(not_purchased==1)
				{
				SendServerMessage("This text color is not available. Use '/buy' to purchase new text colors", i);
				return;	
				}			
			
			
			if( strcmpi(ptr, "ablue") == 0 ) val = TEXTFORMAT_ABLUE;
			else if( strcmpi(ptr, "apurple") == 0 ) val = TEXTFORMAT_APURPLE;
			else if( strcmpi(ptr, "aorange") == 0 ) val = TEXTFORMAT_AORANGE;
			else if( strcmpi(ptr, "ateal") == 0 ) val = TEXTFORMAT_ATEAL;
			
			else if( strcmpi(ptr, "mred") == 0 ) val = TEXTFORMAT_MRED;
			else if( strcmpi(ptr, "mblue") == 0 ) val = TEXTFORMAT_MBLUE;
			else if( strcmpi(ptr, "myellow") == 0 ) val = TEXTFORMAT_MYELLOW;
			else if( strcmpi(ptr, "mgreen") == 0 ) val = TEXTFORMAT_MGREEN;
			else if( strcmpi(ptr, "mgray") == 0 ) val = TEXTFORMAT_MGRAY;


			if(not_purchased==1)
				{
				SendServerMessage("This text color is not available. Use '/buy' to purchase new text colors", i);
				return;	
				}
			

			// Only Mods, Senior Mods, Admins can use These Colours //
			if(supermod==-1) 
				{
				if(val==TEXTFORMAT_ABLUE || val==TEXTFORMAT_APURPLE || val==TEXTFORMAT_AORANGE || val==TEXTFORMAT_ATEAL
				|| val==TEXTFORMAT_MRED || val==TEXTFORMAT_MBLUE || val==TEXTFORMAT_MYELLOW || val==TEXTFORMAT_MGREEN || val==TEXTFORMAT_MGRAY)
					{
					SendServerMessage("Colors only available to Admins, Lead Moderators & Moderators", i);
					return;
					}
				}

			// Only Admins and Senior Mods can use These Colours //
			if(supermod==0)
				{
				if(val==TEXTFORMAT_ABLUE || val==TEXTFORMAT_APURPLE || val==TEXTFORMAT_AORANGE || val==TEXTFORMAT_ATEAL)
					{
					SendServerMessage("Colors only available to Admins & Lead Moderators", i);
					return;
					}
				}


				
			if(val!=-1)
				{
					if(val&TEXTFORMAT_COLOR) // A color setting
					{
					textFormat&=TEXTFORMAT_NCOLOR; // Strip off the color value
					textFormat|=val;				// set new color value.

					m_player[plrIdx].textFormat = textFormat;
					SendPlayerTextFormat(i, textFormat);

					// Update the Database, of this Text Change //
					TextChanged(m_player[plrIdx].name, m_player[plrIdx].textFormat);
					}
					else 
					{
					if(format[0] == '+') textFormat|= val; // add
					else if(format[0] == '-') textFormat&= ~val; // remove
					else textFormat = val; // set
					
					m_player[plrIdx].textFormat = textFormat;
					SendPlayerTextFormat(i, textFormat);
					// Update the Database, of this Cue Change //
					TextChanged(m_player[plrIdx].name, m_player[plrIdx].textFormat);
					}

					
					if(format[0] == '+') // add
					{
						if(val == TEXTFORMAT_DEFAULT) sprintf(buffer,"Text is un-changed");
						else if(val == TEXTFORMAT_ITALIC) sprintf(buffer,"Text 'Italic' has been added");
						//else if(val == TEXTFORMAT_UNDERLINE)  sprintf(buffer,"Text 'Underline'  has been added");
						else if(val == TEXTFORMAT_COMIC)  sprintf(buffer,"Text Style 'Comic' has been set");
						else if(val == TEXTFORMAT_BOLD)  sprintf(buffer,"Text Style 'Bold' has been set");
						else if(val&TEXTFORMAT_COLOR)
						{
						if(val&0x08) sprintf(buffer,"Text colour changed to '%s'", tfmt_color_lst[16+((val>>4)&0xf)]);
						else sprintf(buffer,"Text colour changed to '%s'", tfmt_color_lst[(val>>4)&0xf]);
						}

						//else if(val == TEXTFORMAT_BLUE)  sprintf(buffer,"Text colour 'Blue' has been added");
						//else if(val == TEXTFORMAT_GREEN)  sprintf(buffer,"Text colour 'Green' has been added");
						//else if(val == TEXTFORMAT_ORANGE)  sprintf(buffer,"Text colour 'Orange' has been added");
					}
					else if(format[0] == '-') // remove
					{
						if(val == TEXTFORMAT_DEFAULT) sprintf(buffer,"Text is un-changed");
						else if(val == TEXTFORMAT_ITALIC) sprintf(buffer,"Text 'Italic' has been removed");
						//else if(val == TEXTFORMAT_UNDERLINE)  sprintf(buffer,"Text 'Underline'  has been removed");
						else if(val == TEXTFORMAT_COMIC)  sprintf(buffer,"Text Style 'Comic' has been set");
						else if(val == TEXTFORMAT_BOLD)  sprintf(buffer,"Text Style 'Bold' has been set");
						else if(val&TEXTFORMAT_COLOR)
						{
						if(val&0x08) sprintf(buffer,"Text colour changed to '%s'", tfmt_color_lst[16+((val>>4)&0xf)]);
						else sprintf(buffer,"Text colour changed to '%s'", tfmt_color_lst[(val>>4)&0xf]);
						}

						//else if(val == TEXTFORMAT_BLUE)  sprintf(buffer,"Text colour 'Blue' has been removed");
						//else if(val == TEXTFORMAT_GREEN)  sprintf(buffer,"Text colour 'Green' has been removed");
						//else if(val == TEXTFORMAT_ORANGE)  sprintf(buffer,"Text colour 'Orange' has been removed");
					}
					else // set
					{
						if(val == TEXTFORMAT_DEFAULT)  sprintf(buffer,"Text is now back to 'Normal'");
						else if(val == TEXTFORMAT_ITALIC) sprintf(buffer,"Text 'Italic' has been set");
						//else if(val == TEXTFORMAT_UNDERLINE)  sprintf(buffer,"Text 'Underline'  has been set");
						else if(val == TEXTFORMAT_COMIC)  sprintf(buffer,"Text Style 'Comic' has been set");
						else if(val == TEXTFORMAT_BOLD)  sprintf(buffer,"Text Style 'Bold' has been set");
						else if(val&TEXTFORMAT_COLOR)
						{
						if(val&0x08) sprintf(buffer,"Text colour changed to '%s'", tfmt_color_lst[16+((val>>4)&0xf)]);
						else sprintf(buffer,"Text colour changed to '%s'", tfmt_color_lst[(val>>4)&0xf]);
						}

						//else if(val == TEXTFORMAT_BLUE)  sprintf(buffer,"Text colour 'Blue' has been set");
						//else if(val == TEXTFORMAT_GREEN)  sprintf(buffer,"Text colour 'Green' has been set");
						//else if(val == TEXTFORMAT_ORANGE)  sprintf(buffer,"Text colour 'Orange' has been set");						
					}
					SendServerMessage(buffer, i);
				} 
			else{
					//Unrecognized format '%s'\n 
					//sprintf(buffer,"Usage: /text [+/-]'normal'|'green'|'orange'|'blue'|'italic'|'underline'\nThis command changes chat text style");
					//sprintf(buffer, "Usage: /text [+/-][style]\r\nstyle = 'normal' | 'green' | 'orange' | 'blue' | 'italic' | 'underline'\r\nAdds/Removes/Sets Administrator's chat text style");
					//SendServerMessage(buffer, i);
					if(supermod==-1) sprintf(text_buf, "Usage: /text %s\r\nChanges Text Color. Use '/buy' to purchase new text colors", inv);
					else if(supermod==0) sprintf(text_buf, "Usage: /text %s\r\nExtra: mred | mblue | myellow | mgreen | mgray\r\nChanges Text Color. Use '/buy' to purchase new text colors", inv);
					else sprintf(text_buf, "Usage: /text %s\r\nExtra: ablue | apurple | aorange | ateal | mred | mblue | myellow | mgreen | mgray\r\nChanges Text Color. Use '/buy' to purchase new text colors", inv);
					SendServerMessage(text_buf, i);
			
				}	
		}
}
*/




void CGameAppView::HandleServerMessageGREETING(char *str, int i)
{
	// move player into banned directory.
	unsigned char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	char name[256];
	char *message;
	int mod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	


	//if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
	if(mod_type==MODTYPE_LEADMODERATOR || mod_type==MODTYPE_ADMIN  || mod_type==MODTYPE_SMODERATOR); // Lead Moderators & Admin can use this command
	else {
		sprintf((char *)&buffer[2],"Only Admins can use this command");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}


	if(str==NULL)
		{
		sprintf((char *)&buffer[2],"Usage: /greeting <greeting message>\r\nThis command sets the greeting message");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	//GetStrWord(m_greeting, str);
	strcpy(m_greeting, str);

	sprintf((char *)&buffer[2],"Greeting:\r\n%s",m_greeting);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
}



//char *cue_names[] = {"House", "Black & White", "Blue Lightning", "Proton Pink", "Purple Chrome", "Wood", "Dungeon", "Dark Knight"};
//char *cue_names_id[] = {"house", "blackwhite", "bluelightning", "protonpink", "purplechrome", "wood", "dungeon", "darkknight"};
//int cue_prices[] = {0, 3000, 4000, 4000, 5000, 5000, 15000, 30000};


void CGameAppView::HandleServerMessageBUY(char *str, int i) // for Members 
{
	// Adjust a player's rating.
	char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	char format[256];
	char *message;
	int banflag;
	int mod_type;
	int supermod;
	char inv[256];
	unsigned char not_purchased;
	char text_buf[256];
	int n;

	format[0] = 0;
	banflag = 0;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type>4) 
		{
		// Don't Let Trialists Use Text Command //
		SendServerMessage("This feature is only available to Registered Members", i);
		return;
		}

	
	if(mod_type==MODTYPE_LEADMODERATOR) supermod = 1;
	else if(mod_type==MODTYPE_ADMIN) supermod = 2;
	else if(mod_type==MODTYPE_MODERATOR || mod_type==MODTYPE_SMODERATOR) supermod=0;
	else supermod=-1;
	

	message = str;
	if(str==NULL)
		{
		sprintf(text_buf, "Usage: '/buy text' or '/buy cue'");
		SendServerMessage(text_buf, i);
		return;		
		}

	else{
		if(!strcmpi(message, "text") ) 
			{
			strcpy(inv, "Colors: ");
			if(!(m_player[plrIdx].inventory&1)) strcat(inv, " 'blue'");
			if(!(m_player[plrIdx].inventory&2)) strcat(inv, " 'peach'");
			if(!(m_player[plrIdx].inventory&4)) strcat(inv, " 'pink'");
			if(!(m_player[plrIdx].inventory&8)) strcat(inv, " 'mud'");
			if(!(m_player[plrIdx].inventory&16)) strcat(inv, " 'red'");
			if(!(m_player[plrIdx].inventory&32)) strcat(inv, " 'yellow'");
			if(!(m_player[plrIdx].inventory&64)) strcat(inv, " 'ltblue'");
			if(!(m_player[plrIdx].inventory&128)) strcat(inv, " 'green'");
			if(!(m_player[plrIdx].inventory&256)) strcat(inv, " 'tan'");
			if(!(m_player[plrIdx].inventory&512)) strcat(inv, " 'jade'");
			if(!(m_player[plrIdx].inventory&1024)) strcat(inv, " 'rose'");
			if(!(m_player[plrIdx].inventory&2048)) strcat(inv, " 'softgreen'");
			sprintf(text_buf, "Usage: /buy <color> - Colors cost $10.00 (Virtual Cash) each'\r\n%s", inv);
			SendServerMessage(text_buf, i);
			return;		
			}


		if(!strcmpi(message, "cue") ) 
			{
			strcpy(inv, "House: ");
			if(!(m_player[plrIdx].inventory&(1<<17))) strcat(inv, " 'Black & White'");  // 2
			if(!(m_player[plrIdx].inventory&(1<<18))) strcat(inv, " 'Blue Lightning'");    // 4
			if(!(m_player[plrIdx].inventory&(1<<19))) strcat(inv, " 'Proton Pink'");		 // 8
			if(!(m_player[plrIdx].inventory&(1<<20))) strcat(inv, " 'Purple Chrome'");	 // 10
			if(!(m_player[plrIdx].inventory&(1<<21))) strcat(inv, " 'Wood'");     // 40
			if(!(m_player[plrIdx].inventory&(1<<22))) strcat(inv, " 'Dungeon'");		 // 20
			if(!(m_player[plrIdx].inventory&(1<<23))) strcat(inv, " 'Dark Knight'");		 // 80
			sprintf(text_buf, "Usage: /buy <cue> - Cues cost virtual cash'\r\n%s", inv);
			SendServerMessage(text_buf, i);
			return;		
			}


	
		int purchased = -1;

		// Text Color Purchases //
		if(!strcmpi(message, "blue") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&1) purchased=10; // Already Purchased 
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|1; // New Purchased 
			}
		if(!strcmpi(message, "peach") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&2) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|2; // New Purchased 
			}
		if(!strcmpi(message, "pink") )
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&4) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|4; // New Purchased 
			}
		if(!strcmpi(message, "mud") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&8) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|8; // New Purchased 
			}
		if(!strcmpi(message, "red") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&16) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|16; // New Purchased 
			}
		if(!strcmpi(message, "yellow") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&32) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|32; // New Purchased 
			}
		if(!strcmpi(message, "ltblue") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&64) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|64; // New Purchased 
			}
		if(!strcmpi(message, "green") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&128) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|128; // New Purchased 
			}
		if(!strcmpi(message, "tan") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&256) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|256; // New Purchased 
			}
		if(!strcmpi(message, "jade") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&512) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|512; // New Purchased 
			}
		if(!strcmpi(message, "rose") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&1024) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|1024; // New Purchased 
			}
		if(!strcmpi(message, "softgreen") ) 
			{
			if(m_player[plrIdx].cash<1000) { SendServerMessage("You must be at least $10.00 (Virtual Cash) to purchase a Text Color", i); return; }
				else if(m_player[plrIdx].inventory&2048) purchased=10;
				else purchased=1, m_player[plrIdx].inventory = m_player[plrIdx].inventory|2048; // New Purchased 
			}
		
		///////////////////////////////

		int cue_bidx = 0;
		int chalk_bidx = 0;
		/*
		 * Cue Purchases
		 */

		// char *cue_names[] = {"House", "Black & White", "Blue Lightning", "Proton Pink", "Purple Chrome", "Wood", "Dungeon", "Dark Knight"};
		// int cue_prices[] = {0, 3000, 4000, 4000, 5000, 5000, 15000, 30000};

		char buf[128];

		for(n=0;n<MAX_CUES;n++)
		{
			cue_bidx = n;
			if(!strcmpi(message, cue_names_id[n]) ) 
			{
				if(m_player[plrIdx].cash < cue_prices[n]) 
				{ 
					sprintf(buf, "You don't have enough Virtual Cash ($%.2f vCash is required to purchase %s cue", (float)(cue_prices[n]) / 100.0f, cue_names[n]);
					SendServerMessage(buf, i); 
					return; 
				}
				else if(m_player[plrIdx].inventory&(1<<(16+n))) 
				{
					purchased=11;		// Already Purchased 
					break;
				}
				else
				{
					purchased=2;
					m_player[plrIdx].inventory |= (1<<(16+n));	// Allowed multiples cues //
					break;
				}
			}
		}

		/*
		 * Chalk Purchases
		 */

		// char *chalk_names_id[] = {"blue", "pink", "brown", "gray", "green", "orange", "black", "purple", "red", "tan", "white"};
		// int chalk_prices[] = {0, 1000, 1200, 1400, 800, 900, 1000, 1100, 1200, 1300, 1500};


		for(n=0;n<MAX_CHALKS;n++)
		{
			chalk_bidx = n;
			if(!strcmpi(message, chalk_names_id[n]) ) 
			{
				if(m_player[plrIdx].cash < chalk_prices[n]) 
				{ 
					sprintf(buf, "You don't have enough Virtual Cash ($%.2f vCash is required to purchase %s chalk", (float)(chalk_prices[n]) / 100.0f, chalk_names[n]);
					SendServerMessage(buf, i); 
					return; 
				}
				else if(m_player[plrIdx].chalktype&(1<<(16+n))) 
				{
					purchased=12;		// Already Purchased This Chalk
					break;
				}
				else
				{
					purchased=3;
					m_player[plrIdx].chalktype |= (1<<(16+n));	// Allowed multiples Chalks //
					break;
				}
			}
		}

		if(purchased>=10)
		{	
			if(purchased==10) SendServerMessage("You have purchased this color already", i);
			else if(purchased==11) SendServerMessage("You already have this Cue", i);
			else if(purchased==12) SendServerMessage("You already have this Chalk", i);
			else;
			return;
		}	
		else if(purchased==-1)
		{
			SendServerMessage("Invalid purchase Item. Type '/buy text', '/buy cue' or '/buy chalk' to see available Items to purchase", i);
			return;
		}
		else
		{
			if(purchased==1) // Purchased a Text Color
			{
				// Buy the Color for $10 (1000 cents) //
				m_player[plrIdx].cash -= 1000;
				SendPlayerChangeData(plrIdx, PLAYERCHANGE_RATING);
				SavePlayer(m_player[plrIdx].name, &m_player[plrIdx]);
				

				sprintf(buffer,"%s purchased '%s' text for $10.00 (Virtual Cash). New Cash is $%ld.%02ld, (old cash: $%ld.%02ld)",m_player[plrIdx].name, message, m_player[plrIdx].cash/100, (m_player[plrIdx].cash)%100, (m_player[plrIdx].cash+1000)/100, (m_player[plrIdx].cash+1000)%100);
				AddLog("LogInventBuy.txt", buffer);
				
				sprintf(buffer,"You have purchased '%s' text for $10.00 (Virtual Cash). New Cash is $%ld.%02ld, (old cash: $%ld.%02ld)\r\nType /text to change text color.", message, m_player[plrIdx].cash/100, (m_player[plrIdx].cash)%100, (m_player[plrIdx].cash+1000)/100, (m_player[plrIdx].cash+1000)%100);
				SendServerMessage(buffer, i);
			}
			else if(purchased==2) // Purchased a Cue
			{
				
				n = cue_bidx;

				sprintf(buffer,"%s purchased '%s' Cue for $%.2f vCash (New vCash %.2f, Old vCash).",m_player[plrIdx].name, cue_names[n], (float)(cue_prices[n]) / 100.0f, (float)(m_player[plrIdx].cash) / 100.0f, (float)(m_player[plrIdx].cash + cue_prices[n]) / 100.0f);
				AddLog("LogInventBuy.txt", buffer);
				
				sprintf(buffer,"You have purchased '%s' Cue for $%.2f vCash.", cue_names[n], (float)(cue_prices[n]) / 100.0f);
				SendServerMessage(buffer, i);

				// Buy the Cue, Change to it, then update Database
				m_player[plrIdx].cash -= cue_prices[n];
				m_player[plrIdx].cuetype = n;//(n+1);
				SavePlayer(m_player[plrIdx].name, &m_player[plrIdx]);
				
				// Update the Database, of this Cue Change //
				// CueChanged(m_player[plrIdx].name, m_player[plrIdx].cuetype);

				SendPlayerChangeData(plrIdx, PLAYERCHANGE_VCASHCUE);
				
						
				sprintf(text_buf, "cue changed to: %s", cue_names[n]);
				SendServerMessage(text_buf, i);		

			}
			else if(purchased==3) // Purchased a Chalk
			{
				n = chalk_bidx;

				sprintf(buffer,"%s purchased '%s' Chalk for $%.2f vCash (New vCash %.2f, Old vCash).",m_player[plrIdx].name, chalk_names[n], (float)(chalk_prices[n]) / 100.0f, (float)(m_player[plrIdx].cash) / 100.0f, (float)(m_player[plrIdx].cash + chalk_prices[n]) / 100.0f);
				AddLog("LogInventBuy.txt", buffer);
				
				sprintf(buffer,"You have purchased '%s' Chalk for $%.2f vCash.", chalk_names[n], (float)(chalk_prices[n]) / 100.0f);
				SendServerMessage(buffer, i);

				// Buy the Chalk, Change to it, then update Database
				m_player[plrIdx].cash -= chalk_prices[n];
				m_player[plrIdx].chalktype &= 0xffffff00;				// Set first 8-Bits to off, so when we & with n, we get n for our first 8 bits
				m_player[plrIdx].chalktype |= n;						// We use the first 8 bits for our chalktype (gives us up to 256 values), last 16 are for Chalk Inventory, so we have 8 bits free
				SavePlayer(m_player[plrIdx].name, &m_player[plrIdx]);
	
				SendPlayerChangeData(plrIdx, PLAYERCHANGE_VCASHCHALK);
				
						
				sprintf(text_buf, "chalk changed to: %s", chalk_names[n]);
				SendServerMessage(text_buf, i);		

			}
		}
	}
}



// Change Cue Type //
void CGameAppView::HandleServerMessageCUE(char *str, int i)
{
	// Adjust a player's rating.
	// char *cue_lst[] = {"Standard", "BlackWhite", "Charcoal", "Sea", "Stealth", "Vampire", "Demon", "Wood"};
	char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	int mod_idx;																   
	int kmod_idx;
	char format[256];
	char message[256];
	int banflag;
	int mod_type;
	int supermod;
	char inv[256];
	unsigned char not_purchased;
	char text_buf[512];
	int n;

	format[0] = 0;
	banflag = 0;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type>4) 
		{
		// Don't Let Trialists Use Text Command //
		SendServerMessage("This feature is only available to Registered Members", i);
		return;
		}

	
	/////
	if(mod_type==MODTYPE_LEADMODERATOR) supermod = 1;
	else if(mod_type==MODTYPE_ADMIN) supermod = 2;
	else if(mod_type==MODTYPE_MODERATOR || mod_type==MODTYPE_SMODERATOR) supermod=0;
	else supermod=-1;
	
	GetStrWord(message, str);
	
	// Get a List of Colours player's have purchased //
	for(n=0;n<MAX_CUES;n++)
	{
		if(n == 0)
		{
			strcpy(inv, "House");
		}
		else
		{
			if(m_player[plrIdx].inventory&(1<<(16+n))) 
			{
				strcat(inv, " | ");
				strcat(inv, cue_names[n]);
			}
		}
	}

	/*
	strcpy(inv, "Standard");
	if(m_player[plrIdx].inventory&(1<<17)) strcat(inv, " | BlackWhite");
	if(m_player[plrIdx].inventory&(1<<18)) strcat(inv, " | Charcoal");
	if(m_player[plrIdx].inventory&(1<<19)) strcat(inv, " | Sea");
	if(m_player[plrIdx].inventory&(1<<20)) strcat(inv, " | Stealth");
	if(m_player[plrIdx].inventory&(1<<21)) strcat(inv, " | Vampire");
	if(m_player[plrIdx].inventory&(1<<22)) strcat(inv, " | Demon");
	if(m_player[plrIdx].inventory&(1<<23)) strcat(inv, " | Wood");
	*/

	if(str==NULL)
		{
		// Show the User Which Colours they have ///
		sprintf(text_buf, "Usage: /text %s\r\nThis command changes the Cue type. Use '/buy' to purchase new cues", inv);
		SendServerMessage(text_buf, i);
		return;		
		}

	else{

		/////// The Inventory Cues - So must check that we have purchased these before allowing use ///

		int val=-1;
		not_purchased=0;
		int cue_idx=0;
		
		for(n=0;n<MAX_CUES;n++)
		{
			if( strcmpi(message, cue_names_id[n]) == 0 )
			{
				val = n;
				cue_idx = n;
				
				// Skip House cue, as we always should be able to change to this
				if(n>0)
				{
					if(!(m_player[plrIdx].inventory&(1<<(16+n)))) not_purchased=1;
				}
			}
		}
		
				
		if(not_purchased==1)
			{
			SendServerMessage("This cue type is not available. Use '/buy' to purchase new cue", i);
			return;	
			}			
		
						
		if(val!=-1)
			{
			m_player[plrIdx].cuetype = val;
			
			// Update the Database, of this Cue Change //
			CueChanged(m_player[plrIdx].name, m_player[plrIdx].cuetype);

			SendPlayerChangeData(plrIdx, PLAYERCHANGE_CUE);
						
			sprintf(text_buf, "cue changed to: %s", cue_names[cue_idx]);
			SendServerMessage(text_buf, i);					
			}	
		else{
			sprintf(text_buf, "Usage: /cue %s\r\nChanges cue type. Use '/buy' to purchase new cues", inv);
			SendServerMessage(text_buf, i);
			}	
		}
}


// Change Chalk Type //
void CGameAppView::HandleServerMessageCHALK(char *str, int i)
{
	char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	int mod_idx;																   
	int kmod_idx;
	char format[256];
	char message[256];
	int banflag;
	int mod_type;
	int supermod;
	char inv[256];
	unsigned char not_purchased;
	char text_buf[512];
	int n;

	format[0] = 0;
	banflag = 0;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type>4) 
		{
		// Don't Let Trialists Use Text Command //
		SendServerMessage("This feature is only available to Registered Members", i);
		return;
		}

	
	/////
	if(mod_type==MODTYPE_LEADMODERATOR) supermod = 1;
	else if(mod_type==MODTYPE_ADMIN) supermod = 2;
	else if(mod_type==MODTYPE_MODERATOR || mod_type==MODTYPE_SMODERATOR) supermod=0;
	else supermod=-1;
	
	GetStrWord(message, str);
	
	// Get a List of Colours player's have purchased //
	for(n=0;n<MAX_CHALKS;n++)
	{
		if(n == 0)
		{
			strcpy(inv, "Blue");
		}
		else
		{
			if(m_player[plrIdx].inventory&(1<<(16+n))) 
			{
				strcat(inv, " | ");
				strcat(inv, chalk_names[n]);
			}
		}
	}



	if(str==NULL)
		{
		// Show the User Which Colours they have ///
		sprintf(text_buf, "Usage: /text %s\r\nThis command changes the Chalk type. Use '/chalk' to purchase new chalks", inv);
		SendServerMessage(text_buf, i);
		return;		
		}

	else{

		/////// The Inventory Chalks - So must check that we have purchased these before allowing use ///

		int chalk_idx = -1;
		
		for(n=0;n<MAX_CHALKS;n++)
		{
			if( strcmpi(message, chalk_names_id[n]) == 0 )
			{
				chalk_idx = n;
				break;
			}
		}

		if(chalk_idx != -1)
			{
			m_player[plrIdx].chalktype &= 0xffffff00;				// Set first 8-Bits to off, so when we & with n, we get n for our first 8 bits
			m_player[plrIdx].chalktype |= n;						// We use the first 8 bits for our chalktype (gives us up to 256 values), last 16 are for Chalk Inventory, so we have 8 bits free
			
			// Update the Database, of this Cue Change //
			ChalkChanged(m_player[plrIdx].name, m_player[plrIdx].chalktype);

			SendPlayerChangeData(plrIdx, PLAYERCHANGE_CHALK);
						
			sprintf(text_buf, "chalk changed to: %s", chalk_names[chalk_idx]);
			SendServerMessage(text_buf, i);					
			}	
		else{
			sprintf(text_buf, "Usage: /chalk %s\r\nChanges chalk type. ", inv);
			SendServerMessage(text_buf, i);
			}	
		}
}

void CGameAppView::HandleServerMessageSELL(char *str, int i) // for Members 
{
	/*
	// Adjust a player's rating.
	char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	char format[256];
	char *message;
	int banflag;
	int mod_type;
	int supermod;
	char inv[256];
	unsigned char not_purchased;
	char text_buf[256];
	int val;

	format[0] = 0;
	banflag = 0;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type>4) 
		{
		// Don't Let Trialists Use Text Command //
		SendServerMessage("This feature is only available to Registered Members", i);
		return;
		}

	
	if(mod_type==MODTYPE_LEADMODERATOR) supermod = 1;
	else if(mod_type==MODTYPE_ADMIN) supermod = 2;
	else if(mod_type==MODTYPE_MODERATOR || mod_type==MODTYPE_SMODERATOR) supermod=0;
	else supermod=-1;
	

	message = str;
	if(str==NULL)
		{
		sprintf(text_buf, "Usage: /sell <rating pts> - (1pt = $0.02)\r\n");
		SendServerMessage(text_buf, i);
		return;		
		}

	else{
		// Must have at least 1200 in rating to sell points for Cash (1pt = $0.02) //
		if(m_player[plrIdx].rating<1200)
			{
			SendServerMessage("You must be over 1200 in rating, to sell rating points for Cash ", i);
			return;
			}

		val = 0;
		sscanf(message,"%d",&val);


		if(val<=0)
			{
			SendServerMessage("Invalid number of points to sell, please enter a whole number of points to sell.", i);
			return;
			}

		if((m_player[plrIdx].rating-val)<1200)
			{
			sprintf(buffer, "Insufficient rating pts. You may only sell %d rating pts", m_player[plrIdx].rating-1200); 
			SendServerMessage(buffer, i);
			return;
			}


		// Buy the Cash (1pt = $0.02) 2 cents //
		m_player[plrIdx].cash += val*2;
		m_player[plrIdx].rating -= val;
		SendPlayerChangeData(plrIdx, PLAYERCHANGE_RATING);
		SavePlayer(m_player[plrIdx].name, &m_player[plrIdx]);

		
		sprintf(buffer,"%s sold %d rating points for $%ld.%02ld Virtual Cash", m_player[plrIdx].name, val, (val*2)/100, (val*2)%100);
		AddLog("LogInventBuy.txt", buffer);
		
	
		sprintf(buffer,"You have sold %d rating points for $%ld.%02ld Virtual Cash", val, (val*2)/100, (val*2)%100);
		SendServerMessage(buffer, i);

		}
	*/
}





void CGameAppView::HandleServerMessageCLEARTABLE(char *str, int i)
{
	// clear table %idx%
	unsigned char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	char name[256];
	char *message;
	int tblIdx = 0;
	int mod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	



	if(mod_type>3 || mod_type<0)
		{
		sprintf((char *)&buffer[2],"Only Admins / Moderators can use this command");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
		
	//message = GetStrStart(GetStrEnd(str));

	if(str==NULL)
		{
		sprintf((char *)&buffer[2],"Usage: /cleartable <table no.>\r\nThis command clears a table");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	GetStrWord(name, str);
	//strcpy(m_greeting, str);

	sscanf(name, "%d", &tblIdx);
	tblIdx--;
	if(tblIdx >= 0 && tblIdx <= (MAX_LOBBY_TABLES-1))
	{
		{
	char str[256];
	sprintf(str,"%s Cleared Table %d",m_player[plrIdx].name,tblIdx);
	AddLog("LogModerators.txt", str);
		}

		sprintf((char *)&buffer[2],"Table %d has been cleared!", tblIdx+1);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

		//
		// send out clear table msg to all
		SendClearTable(tblIdx);
		//
	}
	else
	{
		sprintf((char *)&buffer[2],"Please choose a table in the range of 1-%d", MAX_LOBBY_TABLES);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
}

void CGameAppView::HandleServerMessageBROADCAST(char *str, int i)
{ // "/broadcast  <message>"
	//char name[80];
	char name[256];
	char *message;
	unsigned char buffer[256];
	int n;
	int plrIdx;
	int mod_type;

	
	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type

	if(mod_type>3 || mod_type<0)
		{
		sprintf((char *)&buffer[2],"Only Admins / Moderators can use this command");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	message = str;
	if(str==NULL)
	{
	sprintf((char *)&buffer[2],"Usage: /broadcast <message>");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}
		
	{
	// Tell Sender that message is being sent.
	sprintf((char *)&buffer[2],"To Everyone: %s", message);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfe; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
					  
	// Send message to all players except yourself.
	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	if(mod_type == 0) // 0 = admin
		sprintf((char *)&buffer[2],"Admin Broadcast (From %s): %s", m_player[plrIdx].name, message);
	else if(mod_type == 1) // 1 = mod
		sprintf((char *)&buffer[2],"Moderator Broadcast (From %s): %s", m_player[plrIdx].name, message);
	else // -1 = nothing.
		sprintf((char *)&buffer[2],"Broadcast (From %s): %s", m_player[plrIdx].name, message);

	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfe; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell)
	{
	int j;
	// Send to all sockets on server except sender. - the only messages not logged in fact!
	char *lpBuf;
	int nBufLen;
	lpBuf = (char *) buffer;
	nBufLen = strlen((char *)&buffer[2])+3;
	for(j=0;j<mainShell->Server->m_socketList_n;j++)
	if(j!=i)
	if(mainShell->Server->m_socketList[j])
		{
		((CAsyncSocketEx *)mainShell->Server->m_socketList[j])->SendToQueue(lpBuf, nBufLen);
		}
	}

	//if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
}




void CGameAppView::HandleServerMessageMODS(char *str, int i)
{ // "/broadcast  <message>"
	//char name[80];
	char name[256];
	char *message;
	unsigned char buffer[256];
	int n;
	int plrIdx;
	int mod_type;


	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	

	if(mod_type>3 || mod_type<0)
		{
		sprintf((char *)&buffer[2],"Only Admins / Moderators can use this command");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	message = str;
	if(str==NULL)
	{
	sprintf((char *)&buffer[2],"Usage: /mods <message>");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}
		
	{
	// Tell Sender that message is being sent.
	sprintf((char *)&buffer[2],"To Mods: %s", message);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfe; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
					  
	// Send message to all Mods/Admins except yourself.
	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	if(mod_type==0) // 0 = admin
		sprintf((char *)&buffer[2],"Admin BroadcastMods (From %s): %s", m_player[plrIdx].name, message);
	else if(mod_type==1 || mod_type==2 || mod_type==3) // 1 = mod
		sprintf((char *)&buffer[2],"Moderator BroadcastMods (From %s): %s", m_player[plrIdx].name, message);
	else // -1 = nothing.
		sprintf((char *)&buffer[2],"BroadcastMods (From %s): %s", m_player[plrIdx].name, message);

	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfe; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell)
	{
	int j;
	// Send to all sockets on server except sender. - the only messages not logged in fact!
	char *lpBuf;
	int nBufLen;
	lpBuf = (char *) buffer;
	nBufLen = strlen((char *)&buffer[2])+3;
	for(j=0;j<mainShell->Server->m_socketList_n;j++)
	if(j!=i)
		{
		// Only Send if the receiver is a Moderator, Admin or Server //
		plrIdx = m_lobby->GetPlayerIdx(j);
		if(j == 0 || plrIdx != -1)
			{
			mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
			if((mod_type>=0 && mod_type<=3) || j==0)
			if(mainShell->Server->m_socketList[j])
				{
				((CAsyncSocketEx *)mainShell->Server->m_socketList[j])->SendToQueue(lpBuf, nBufLen);
				}
			}
		}
	}

	//if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
}




char *_GATEstr[] = {
"closed",
"open",
};

void CGameAppView::HandleServerMessageGATE(char *str, int i)
{
	// move player into banned directory.
	unsigned char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	int mod_type;
	char name[256];
	char *message;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	

	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		sprintf((char *)&buffer[2],"Only Admins can use this command");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
		
	//message = GetStrStart(GetStrEnd(str));
	if(str)
	{
	if(!strcmpi(str,"open")) m_bGateopen = TRUE;
	else if(!strcmpi(str,"close")) m_bGateopen = FALSE;
	else str = NULL;
	}

	if(str==NULL)
		{
		sprintf((char *)&buffer[2],"Usage: /gate <'close'>|<'open'>\r\nThis command enables/disables posting to gateway\r\nGate Currently %s",_GATEstr[m_bGateopen]);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
		
	if(m_bGateopen) sprintf((char *)&buffer[2],"Gate Open");
	else sprintf((char *)&buffer[2],"Gate Closed");

	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
}

char *_SERVERstr[] = {
"hide",
"show",
};

void CGameAppView::HandleServerMessageSERVER(char *str, int i)
{
	// move player into banned directory.
	unsigned char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	int mod_type;
	char name[256];
	char *message;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	

	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		sprintf((char *)&buffer[2],"Only Admins can use this command");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
		
	//message = GetStrStart(GetStrEnd(str));
	if(str)
	{
	if(!strcmpi(str,"show")) {
							 if(m_bServerState == FALSE)
								{
								AfxGetMainWnd()->ShowWindow(SW_SHOW);
								//ShowWindow(SW_NORMAL);
								//SetForegroundWindow();
								//SetFocus();	   
   								}
							 m_bServerState = TRUE;
							 }
	else if(!strcmpi(str,"hide")) {
								  if(m_bServerState == TRUE)
									{
									AfxGetMainWnd()->ShowWindow(SW_HIDE);
									}
								  m_bServerState = FALSE;
								  }
	else str = NULL;
	}

	if(str==NULL)
		{
		sprintf((char *)&buffer[2],"Usage: /server <'show'>|<'hide'>\r\nThis command shows/hides server\r\nCurrently in %s state",_SERVERstr[m_bServerState]);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
		
	if(m_bServerState) sprintf((char *)&buffer[2],"Server Show");
	else sprintf((char *)&buffer[2],"Server Hidden");

	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
}

void CGameAppView::HandleServerMessageSTING(char *str, int i)
{ // "/sting <name>"
	//char name[80];
	char *name;//[80];
	unsigned char buffer[256];
	int n;
	int plrIdx;
	int sockIdx;
	int mod_type;
	int kplrIdx;
	int kmod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;

	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}

	if(str==NULL)
	{
	sprintf((char *)&buffer[2],"Usage: /sting <player name>");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}

	// search for this name (could be a name)
	//name = GetStrStart(GetStrEnd(str));
	name = str;

	{

		

	sockIdx = m_lobby->FindPlayerSockIdxi(name); // Get socket index of player you wish to message.noncase sensi.
	if(sockIdx==-1)
	{
	sprintf((char *)&buffer[2],"User '%s' is not online", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}
	else {

	kplrIdx = m_lobby->GetPlayerIdx(sockIdx); // get player index of kickee.
	kmod_type = GetPlayerType(name); // Get the Mod Type of Banee

	if(kmod_type<=mod_type) // you can't ban this moderator.
		{
		sprintf((char *)&buffer[2],"Moderator '%s' out-ranks you! (%d)", name,kmod_type);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	}


	sprintf((char *)&buffer[2],"Stung %s", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

	{
	char str[256];
	sprintf(str,"%s Stung '%s'",m_player[plrIdx].name, name);
	AddLog("LogModerators.txt", str);
	}

	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 85;		// MSGGAME_STING
	buffer[2] = 0;
	buffer[3] = 0;		// Reason flag.

	if(mainShell) mainShell->Server->SendToQueue(buffer, 4, sockIdx); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}	
}

void CGameAppView::HandleServerMessageCRASH(char *str, int i)
{ // "/sting <name>"
	//char name[80];
	char *name;//[80];
	unsigned char buffer[256];
	int n;
	int plrIdx;
	int sockIdx;
	int mod_type;
	int kplrIdx;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type



	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}

	if(str==NULL)
	{
	sprintf((char *)&buffer[2],"Usage: /crash <player name>");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}

	// search for this name (could be a name)
	//name = GetStrStart(GetStrEnd(str));
	name = str;

	{
	int kmod_idx;
	int kmod_type;
	//kmod_idx = m_moderator->CheckName(name); // get mod index of banee
	//sockIdx = m_lobby->FindPlayerSockIdxi(name); // Get socket index of player you wish to message.noncase sensi.
	sockIdx = m_lobby->FindPlayerSockIdxi(name); // Get socket index of player you wish to message.noncase sensi.
	if(sockIdx==-1)
	{
	sprintf((char *)&buffer[2],"User '%s' is not online", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}
	else {

	kplrIdx = m_lobby->GetPlayerIdx(sockIdx); // get player index of kickee.
	kmod_type = GetPlayerType(name); // Get the Mod Type of Banee

	if(kmod_type<0) 
		{
		sprintf((char *)&buffer[2],"'%s' doesn't exist", name);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	}


	sprintf((char *)&buffer[2],"Crashing %s", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

	{
	char str[256];
	sprintf(str,"%s Crashed '%s'",m_player[plrIdx].name, name);
	AddLog("LogModerators.txt", str);
	}

	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 86;		// MSGGAME_CRASH
	buffer[2] = 0;
	buffer[3] = 0;		// Reason flag.

	if(mainShell) mainShell->Server->SendToQueue(buffer, 4, sockIdx); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	}	
}


// mode 0: Wall
// mode 1: Deny
// mode 2: Block
void CGameAppView::HandleServerMessageWallDenyBlock(char *str, int i, char mode)
{
	unsigned char buffer[256];
	int plrIdx;
	int mod_type;
	int kmod_type;
	char name[256];
	char *message;

	
	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
					

	if(mod_type==MODTYPE_LEADMODERATOR || mod_type==MODTYPE_ADMIN || mod_type==MODTYPE_SMODERATOR);
	else {
		SendServerMessage("Only Admins and Senior Moderators can use this command", i);
		return;
		}

	// mod_idx a proper number.
	GetStrWord(name, str);
	message = GetStrStart(GetStrEnd(str));

	//name = str;//GetStrStart(GetStrEnd(str));
	if(str==NULL) //name==NULL)
		{
		if(mode==0)	sprintf((char *)&buffer[2],"Usage: /wall <user>");
			else if(mode==1) sprintf((char *)&buffer[2],"Usage: /deny <user>");
			else if(mode==2) sprintf((char *)&buffer[2],"Usage: /block <user>");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	

	Player kplr;
	kplr.ssysid[0] = 0;
	kplr.playertype = -1;
	if(!LoadPlayerFileEx(name, &kplr)) 
		{
		kplr.playertype = -1;
		// Check if this is a Guest //
		for(int n=0;n<MAX_LOBBY_PLAYERS;n++)
		if(m_player[n].status)
		if(!strcmpi(name, m_player[n].name))
			{
			strcpy(kplr.name, "guest");
			if(mode==0) sprintf(kplr.ssysid, "%lx%04x", m_player[n].sysID, m_player[n].cpuID);	
				else if(mode==1) sprintf(kplr.smacid, "%lx%lx", m_player[n].macID_U, m_player[n].macID_L);
				else if(mode==2) sprintf(kplr.sip, "%s", m_player[n].playerLocalIP);
			kplr.playertype = 6;	// Guest Rank //
			break;
			}
		}


	kmod_type = kplr.playertype; // Get the Mod Type of Wallee'
	if(kmod_type==-1)
		{
		sprintf((char *)&buffer[2],"'%s' doesn't exist", name);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	
	if(kmod_type<=mod_type)
		{
		if(mode==0) sprintf((char *)&buffer[2],"Can't Wall Admin / Moderator '%s' (%d)", name,kmod_type);
		else if(mode==1) sprintf((char *)&buffer[2],"Can't Deny Admin / Moderator '%s' (%d)", name,kmod_type);
		else if(mode==2) sprintf((char *)&buffer[2],"Can't Block Admin / Moderator '%s' (%d)", name,kmod_type);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	// Don't allow Walling, Denying or Blocking of 0 //
	if(kplr.ssysid == 0 || kplr.smacid == 0 || kplr.sip == 0)
		{
		if(mode == 0) sprintf((char *)&buffer[2],"This player has no sysid, cannot Wall");
			else if(mode == 1) sprintf((char *)&buffer[2],"This player has no macid, cannot Deny");
			else if(mode == 2) sprintf((char *)&buffer[2],"This player has no ip, cannot Block");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	// so we can Wall here.
	if(mode==0) sprintf((char *)&buffer[2],"Walling '%s'", name);
	else if(mode==1) sprintf((char *)&buffer[2],"Denying '%s'", name);
	else if(mode==2) sprintf((char *)&buffer[2],"Blocking '%s'", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

	int status;
	if(mode==0) status = WallSysID(kplr.ssysid);
	else if(mode==1) status = DenyMacID(kplr.smacid);
	else if(mode==2) status = BlockIP(kplr.sip);

	if(status==TRUE) 
		{
		if(mode==0) sprintf((char *)&buffer[2],"Player %s has been Walled", name);
		else if(mode==1) sprintf((char *)&buffer[2],"Player %s has been Denied", name);
		else if(mode==2) sprintf((char *)&buffer[2],"Player %s has been Blocked", name);
		}
	else if(status==FALSE)
		{
		if(mode==0) sprintf((char *)&buffer[2],"Player %s is already Walled", name);
		else if(mode==1) sprintf((char *)&buffer[2],"Player %s is already Denied", name);
		else if(mode==2) sprintf((char *)&buffer[2],"Player %s is already Blocked", name);
		}
	
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
}




void CGameAppView::HandleServerMessageUnWallDenyBlock(char *str, int i, char mode)
{
	unsigned char buffer[256];
	int plrIdx;
	int mod_type;
	int kmod_type;
	char name[256];
	char *message;

	
	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
					

	if(mod_type==MODTYPE_LEADMODERATOR || mod_type==MODTYPE_ADMIN || mod_type==MODTYPE_SMODERATOR);
	else {
		SendServerMessage("Only Admins and Senior Moderators can use this command", i);
		return;
		}

	// mod_idx a proper number.
	GetStrWord(name, str);
	message = GetStrStart(GetStrEnd(str));

	//name = str;//GetStrStart(GetStrEnd(str));
	if(str==NULL) //name==NULL)
		{
		sprintf((char *)&buffer[2],"Usage: /unwall <user>");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	

	Player kplr;
	kplr.ssysid[0] = 0;
	kplr.playertype = -1;
	if(!LoadPlayerFileEx(name, &kplr)) 
		{
		kplr.playertype = -1;
		// Check if this is a Guest //
		for(int n=0;n<MAX_LOBBY_PLAYERS;n++)
		if(m_player[n].status)
		if(!strcmpi(name, m_player[n].name))
			{
			strcpy(kplr.name, "guest");
			sprintf(kplr.ssysid, "%lx%04x",m_player[n].sysID, m_player[n].cpuID);	
			kplr.playertype = 6;	// Guest Rank //
			break;
			}
		}


	kmod_type = kplr.playertype; // Get the Mod Type of Wallee'
	if(kmod_type==-1)
		{
		sprintf((char *)&buffer[2],"'%s' doesn't exist", name);
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}
	

	// UnWall //
	sprintf((char *)&buffer[2],"UnWalling '%s'", name);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

	sprintf(kplr.ssysid, "%lx%04x",kplr.trialsysid, kplr.trialcpuid);

	int status;
	status = UnWallSysID(kplr.ssysid);

	if(status==TRUE) sprintf((char *)&buffer[2],"Player %s has been UnWalled", name);
	else if(status==FALSE) sprintf((char *)&buffer[2],"Player %s is already UnWalled", name);
	
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
}







void CGameAppView::HandleServerMessageDEBUG(char *str, int i)
{
	char *message;
	unsigned char buffer[256];
	int n;
	int plrIdx;
	int sockIdx;
	int mod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}

	m_reqManager->ClearSlots(); // just incase it builds up.

	sprintf((char *)&buffer[2],"Done");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
}

void CGameAppView::HandleServerMessageADDMOD(char *str, int i)
{ // "/unwall <hex>"

	char *message;
	unsigned char buffer[256];
	int n;
	int plrIdx;
	int mod_idx;
	int sockIdx;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	if(m_player[plrIdx].state&PLRSTATE_ADMIN);
	else {
		sprintf((char *)&buffer[2],"Only Admins can use this command");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	
	if(str==NULL)
	{
	sprintf((char *)&buffer[2],"Usage: /addmod <name> for admins|<+name> for mods|<^name> for smods.");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}

	m_moderator->AddModerator(str);
	{
	char path[256];	
	sprintf(path,"%smoderators.txt", g_basedir);	
	m_moderator->SaveModerators(path);
	}

	sprintf((char *)&buffer[2],"Added %s", str);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

}

void CGameAppView::HandleServerMessageDELMOD(char *str, int i)
{ // "/unwall <hex>"
	char *message;
	unsigned char buffer[256];
	int n;
	int plrIdx;
	int mod_idx;
	int sockIdx;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	if(m_player[plrIdx].state&PLRSTATE_ADMIN);
	else {
		sprintf((char *)&buffer[2],"Only Admins can use this command");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	
	if(str==NULL)
	{
	sprintf((char *)&buffer[2],"Usage: /delmod <player name> for admins|<+player name> for mods.");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
	}

	m_moderator->DeleteModerator(str);
	{
	char path[256];	
	sprintf(path,"%smoderators.txt", g_basedir);	
	m_moderator->SaveModerators(path);
	}


	sprintf((char *)&buffer[2],"Deleted %s", str);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.

}


void CGameAppView::HandleServerMessageMODLIST(char *str, int i)
{ // "/unwall <hex>"
	char *message;
	unsigned char buffer[1024];
	int n;
	int plrIdx;
	int mod_idx;
	int sockIdx;
	char note[32];
	note[0] = 0;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	if(m_player[plrIdx].state&PLRSTATE_ADMIN);
	else {
		sprintf((char *)&buffer[2],"Only Admins can use this command");
		buffer[0] = MSGCODE_TEXT;
		buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

		if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
		return;
		}

	if(str==NULL);
	else {
	if(!strcmpi(str, "reload")) {
							
								char path[256];	
								sprintf(path,"%smoderators.txt", g_basedir);	
								m_moderator->LoadModerators(path);
								
								sprintf(note," (reloaded)");
								}
	}

	int count;
	count = m_moderator->m_name_lst_idx;

	char *pBuf;
	pBuf = (char *)&buffer[2];

	if(count==1) sprintf(pBuf,"There is 1 moderator%s:\r\n",note);
	else sprintf(pBuf,"There are %d moderators%s:\r\n",count,note);
	pBuf+=strlen(pBuf);

	for(n=0;n<m_moderator->m_name_lst_idx;n++)
	{
	if(m_moderator->m_type_lst[n]) sprintf(pBuf,"%d: %s (Moderator)\r\n", n, m_moderator->m_name_lst[n]);
	else sprintf(pBuf,"%d: %s\r\n", n, m_moderator->m_name_lst[n]);
	pBuf+=strlen(pBuf);
	}

	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
}

void CGameAppView::HandleServerMessageRATING(char *str, int i)
{
	// Adjust a player's rating.
	char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	int mod_idx;
	int kmod_idx;
	char name[256];
	char *message;
	int banflag;
	int mod_type;

	banflag = 0;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	if(mod_type==MODTYPE_ADMIN); // Admin can use this command
	else {
		SendServerMessage("Only Admins can use this command", i);
		return;
		}
	
	GetStrWord(name, str);
	message = GetStrStart(GetStrEnd(str));

	if(str==NULL)
		{
		SendServerMessage("Usage: /rating <user> [+/-][rating]\r\nChecks/Adds/Substracts/Sets player's rating", i);
		return;		
		}

	Player plr;
	int val;
	strcpy(plr.name, name);

	if(LoadPlayerProfile(&plr, ".txt"))
	{
	if(message==NULL)
		{
		sprintf(buffer,"%s's rating is: %d ", plr.name, plr.rating);
		SendServerMessage(buffer, i);
		}
	else {
		val = -1;
		sscanf(message,"%d",&val);

		if(val!=-1)
			{
			int old;
			old = plr.rating;
			if(message[0] == '+' || message[0] == '-') plr.rating+= val; // add or subtract the number
			else plr.rating = val;
			SavePlayerProfile(&plr, ".bak");
			SavePlayerProfile(&plr, ".txt");
			DeletePlayerProfile(&plr, ".bak");
			sprintf(buffer,"%s's new rating %d (%d)", plr.name, plr.rating, old);
			SendServerMessage(buffer, i);
			// Update Player Stats (if online) //
			int UplrIdx;
			UplrIdx = m_lobby->FindPlayerIdx(plr.name); // get player index, from that we can determine hex
			if(UplrIdx!=-1)
				{
				m_player[UplrIdx].rating = plr.rating;
				SendPlayerChangeData(UplrIdx, PLAYERCHANGE_RATING);
				}
			{
			char str[256];
			sprintf(str,"%s Adjusted %s's rating %d (%d) '%s'",m_player[plrIdx].name,name, plr.rating, old, message);
			AddLog("LogModerators.txt", str);
			}


			} 
		else {
			sprintf(buffer,"Unrecognized value '%s'", message);
			SendServerMessage(buffer, i);
			}
		}
	} else {
	sprintf(buffer,"Player '%s' doesn't exist", plr.name);
	SendServerMessage(buffer, i);
	}
}

void CGameAppView::HandleServerMessagePLAYERS(char *str, int i)
{
	unsigned char buffer[256];
	//GetTime();

	// calculate how many players are in this lobby + breakdown of Admin/Mod/Members/guests
	int n;
	int totalPlayers = 0;
	int totalAdmin = 0;
	int totalModerators = 0;
	int totalMembers = 0;
	int totalGuests = 0;
	int total = 0;
	for(n=0;n<MAX_LOBBY_PLAYERS;n++)
	if(m_player[n].status)
	{
		// group 1 -> Admin
		if( (m_player[n].state&PLRSTATE_AUTHMASK) == PLRSTATE_ADMIN )
		{
			totalAdmin++;
			continue;
		}
		// group 2 -> Moderators
		else if( (m_player[n].state&PLRSTATE_AUTHMASK) == PLRSTATE_MODERATOR ||
				 (m_player[n].state&PLRSTATE_AUTHMASK) == PLRSTATE_LEADMODERATOR)
		{
			totalModerators++;
			continue;
		}
		// group 3 -> Members
		else if(!m_player[n].bIsGuest)
		{
			totalMembers++;
			continue;			
		}
		else // group 4 -> guests
		{
			totalGuests++;
			continue;
		}
	}

	total = totalAdmin + totalModerators + totalMembers + totalGuests;

	sprintf((char *)&buffer[2],"%d Player(s) are curently in this Lobby -\n%d Administrator(s),\n%d Moderator(s),\n%d Member(s),\n%d Guest(s)",
								total, totalAdmin, totalModerators, totalMembers, totalGuests);//m_stringFullTime);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
}

void CGameAppView::HandleServerMessageAUTOINVITE(char *str, int i)
{
	// automatically invite someone to an arbitrary table...
	char buffer[256];
	int sockIdx;
	int plrIdx;
	int kplrIdx;
	char name[256];
	char *message;
	int banflag;
	int mod_type;

	banflag = 0;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx == -1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}
	
	GetStrWord(name, str);
	message = GetStrStart(GetStrEnd(str));

	if(str==NULL)
		{
		//SendServerMessage("Usage: /rating <user> [+/-][rating]\r\nChecks/Adds/Substracts/Sets player's rating", i);
		SendServerMessage("Usage: /autoinvite <user> <table> [seat = 0,1,2]\r\nInvites a player to an arbitrary table", i);
		return;
		}

	
	int invitedPlrIdx = m_lobby->FindPlayerIdx(name); // get invited player's index if online
	int invitedTable;

	if(message==NULL)
	{
		SendServerMessage("Usage: /autoinvite <user> <table> [seat = 0,1,2]\r\nInvites a player to an arbitrary table", i);
		return;
	}
	else
	{
		if(invitedPlrIdx != -1)
		{
			invitedTable = -1;
			sscanf(message,"%d",&invitedTable);

			if(invitedTable!=-1)
			if(invitedTable >= 1 && invitedTable <= 50)
				{
					int invitedPlrSockIdx = m_lobby->FindPlayerSockIdx(name);
					if( (invitedPlrSockIdx != -1) && (i != -1) )
					{
						// check for optional 'enterType' field...
						int enterType = -1;
						message = GetStrStart(GetStrEnd(message));
						if(message!=NULL)
						{
							sscanf(message,"%d",&enterType);

							if(enterType!=-1)
							if(enterType >= 0 && enterType <= 2)
							{
								SendInvitePressed(i, invitedPlrSockIdx, m_player[plrIdx].name, name, FALSE, NULL, invitedTable-1, invitedTable-1, enterType); // network game only!

								sprintf(buffer,"Invited %s to table #%d, in seat %d.", name, invitedTable, enterType);
								SendServerMessage(buffer, i);
								return;
							}
						}

						// without 'enterType' field...
						SendInvitePressed(i, invitedPlrSockIdx, m_player[plrIdx].name, name, FALSE, NULL, invitedTable-1, invitedTable-1); // network game only!

						sprintf(buffer,"Invited %s to table #%d.", name, invitedTable);
						SendServerMessage(buffer, i);
					}
				}			 
			else {
				sprintf(buffer,"Unrecognized value '%s'", message);
				SendServerMessage(buffer, i);
				}
		}
		else 
		{
			sprintf(buffer,"Player '%s' not online!", name);
			SendServerMessage(buffer, i);
		}
	}
}


void CGameAppView::HandleServerMessageCLEARMOSTRUNOUTS(char *str, int i)
{
	// pool lobby hiscores command...
	unsigned char buffer[256];
	int plrIdx;
	int mod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}
	
	SendAllHighBreaksReset();
													 	
	sprintf((char *)&buffer[2],"Cleared Most Run-Outs List!");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
}

void CGameAppView::HandleServerMessageCLEARHIGHBREAKS(char *str, int i)
{
	// pool lobby hiscores command...
	unsigned char buffer[256];
	int plrIdx;
	int mod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}
	
	SendAllHighBreaksReset();
													 	
	sprintf((char *)&buffer[2],"Cleared High Breaks List!");
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
}


void CGameAppView::HandleServerMessageMOSTRUNOUTS(char *str, int i)
{
	// pool lobby hiscores command...
	unsigned char buffer[256];
	int plrIdx;
	int mod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}
													 	
	sprintf((char *)&buffer[2],"Most Run-Outs List: %d/%d", m_serverAllPlayersStats->m_plrList_idx, m_serverAllPlayersStats->m_plrList_n);
	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
}

	/*
	m_sLobbyHighBreakName[0] = _T("...");
	m_sLobbyHighBreakName[1] = _T("...");
	m_sLobbyHighBreakName[2] = _T("...");
	m_sLobbyHighBreak[0] = 0;
	m_sLobbyHighBreak[1] = 0;
	m_sLobbyHighBreak[2] = 0;
	m_sLobbyPHighBreakName[0] = _T("...");
	m_sLobbyPHighBreakName[1] = _T("...");
	m_sLobbyPHighBreakName[2] = _T("...");
	m_sLobbyPHighBreak[0] = 0;
	m_sLobbyPHighBreak[1] = 0;
	m_sLobbyPHighBreak[2] = 0;
	
	m_sLobbyUKHighBreakName[0] = _T("...");
	m_sLobbyUKHighBreakName[1] = _T("...");
	m_sLobbyUKHighBreakName[2] = _T("...");
	m_sLobbyUKHighBreak[0] = 0;
	m_sLobbyUKHighBreak[1] = 0;
	m_sLobbyUKHighBreak[2] = 0;
	*/

void CGameAppView::HandleServerMessageLEADERBOARD(char *str, int i)
{
	// pool lobby hiscores command...
	unsigned char buffer[256];
	int plrIdx;
	int mod_type;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	
	// Get the Most Runout Leader //

	// sName.Format("%d. %s", n+1, m_sLobbyHighBreakName[n]);
	// sBreak.Format("%d", m_sLobbyHighBreak[n]);

	

#ifdef THE_POOL_CLUB
	// iPool //
	// Display the 8-Ball, 9-Ball and English Pool Most RunOut Leaders //
	sprintf((char *)&buffer[2],"8-Ball Most Run-Outs: %s - %d\r\n9-Ball Most Run-Outs: %s - %d\r\nEnglish Pool Most Run-Outs: %s - %d\r\n", m_sLobbyHighBreakName[0], m_sLobbyHighBreak[0], m_sLobbyPHighBreakName[0], m_sLobbyPHighBreak[0], m_sLobbyUKHighBreakName[0], m_sLobbyUKHighBreak[0]);
#else
	// iSnooker //
	// Display the Semi Pro and Pro High Break Leadesr //
	sprintf((char *)&buffer[2],"Semi Pro High Break: %s - %d\r\nPro High Break: %s - %d", m_sLobbyHighBreakName[0], m_sLobbyHighBreak[0], m_sLobbyPHighBreakName[0], m_sLobbyPHighBreak[0]);
#endif


	buffer[0] = MSGCODE_TEXT;
	buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)

	if(mainShell) mainShell->Server->SendToQueue(buffer, strlen((char *)&buffer[2])+3, i); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	return;
}

void CGameAppView::HandleServerMessageTOPUP(char *str, int i)
{ // "/msg <user_name> <message>"
	//char name[80];
	char name[256];
	char *message;
	unsigned char buffer[256];
	int n;
	int sockIdx;
	int plrIdx;
	int mod_type;
	int kplrIdx;
	int days;

	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}

	if(str==NULL)
	{
	SendServerMessage("Usage: /topup <user> <days>", i);
	return;
	}
	GetStrWord(name, str);
	message = GetStrStart(GetStrEnd(str));
	if(message==NULL)
	{
	SendServerMessage("Usage: /topup <user> <days>", i);
	return;
	}

	days = 0;
	sscanf(message,"%d",&days);
	TopUpPlayer(name, days);

	sprintf((char *) buffer,"Topped up %s by %d days", name, days);
	SendServerMessage((char *) buffer, i);
}

//	int m_list_n;
//	DWORD m_list_idx;
void CGameAppView::HandleServerMessageSYSID(char *str, int i)
{
	char *message;
	char buffer[256];
	int plrIdx;
	int mod_type;


	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}
	sprintf(buffer,"Sys Bank: %d/%d",m_syslist->m_list_idx,m_syslist->m_list_n);
	SendServerMessage(buffer, i);
}


void CGameAppView::HandleServerMessageMACID(char *str, int i)
{
	char *message;
	char buffer[256];
	int plrIdx;
	int mod_type;


	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}
	sprintf(buffer,"MAC Bank: %d/%d",m_maclist->m_maclist_idx,m_maclist->m_maclist_n);
	SendServerMessage(buffer, i);
}


void CGameAppView::HandleServerMessageSPONSOR(char *str, int i)
{
	char *message;
	char buffer[256];
	int plrIdx;
	int mod_type;
	char name[256];


	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;

	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}

	if(str==NULL)
	{
	SendServerMessage("Usage: /sponsor <text>", i);
	return;
	}

	strcpy(m_sponsortxt,str); // change sponsor txt on server. and broadcast to everyone else.

	// Update //

/*	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 101;		// MSGGAME_TABLECHANGEDATA
	buffer[2] = TABLECHANGE_SPONSOR;
	buffer[3] = 0;

	sprintf(&buffer[4],"%s",m_sponsortxt);

	if(mainShell) mainShell->Server->SendToQueue(buffer, siz);
*/
	UpdateSponsor();	

	// new people that log on will need this info aswell
	// ------ //
}

void CGameAppView::HandleServerMessageSPONSORURL(char *str, int i)
{
	char *message;
	char buffer[256];
	int plrIdx;
	int mod_type;
	char name[256];


	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}

	if(str==NULL)
	{
	SendServerMessage("Usage: /sponsorurl <url>", i);
	return;
	}

	strcpy(m_sponsorurl,str); // change sponsor txt on server. and broadcast to everyone else.

	// Update //

/*	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 101;		// MSGGAME_TABLECHANGEDATA
	buffer[2] = TABLECHANGE_SPONSOR;
	buffer[3] = 0;

	sprintf(&buffer[4],"%s",m_sponsortxt);

	if(mainShell) mainShell->Server->SendToQueue(buffer, siz);
*/
	UpdateSponsor();	

	// new people that log on will need this info aswell
	// ------ //
}

void CGameAppView::HandleServerMessageSPONSORBACK(char *str, int i)
{
	char *message;
	char buffer[256];
	int plrIdx;
	int mod_type;
	char name[256];


	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type

	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}

	if(str==NULL)
	{
	SendServerMessage("Usage: /sponsorback <on/off>", i);
	return;
	}

	if(!strcmpi(str,"on")) g_sponsorback = TRUE;
	else if(!strcmpi(str,"off")) g_sponsorback = FALSE;
	else {
	SendServerMessage("Usage: /sponsorback <on/off>", i);
	return;
	}
	
	if(g_sponsorback==TRUE) SendServerMessage("Sponsorback on", i);
	if(g_sponsorback==FALSE) SendServerMessage("Sponsorback off", i);

	// Update //

/*	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 101;		// MSGGAME_TABLECHANGEDATA
	buffer[2] = TABLECHANGE_SPONSOR;
	buffer[3] = 0;

	sprintf(&buffer[4],"%s",m_sponsortxt);

	if(mainShell) mainShell->Server->SendToQueue(buffer, siz);
*/
	UpdateSponsor();	

	// new people that log on will need this info aswell
	// ------ //
}

void CGameAppView::HandleServerMessageSTEALTH(char *str, int i)
{
	char *message;
	char buffer[256];
	int plrIdx;
	int mod_type;
	char name[256];


	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}

	SendServerMessage("Stealth Mode Enabled", i);

	m_player[plrIdx].state2|=PLRSTATE2_STEALTH; // force to 1
	SavePlayer(m_player[plrIdx].name, &m_player[plrIdx]);
	SendPlayerChangeData(plrIdx, PLAYERCHANGE_STATUS2);
}

void CGameAppView::HandleServerMessageUNSTEALTH(char *str, int i)
{
	char *message;
	char buffer[256];
	int plrIdx;
	int mod_type;
	char name[256];


	plrIdx = m_lobby->GetPlayerIdx(i);
	if(plrIdx==-1) return;
	mod_type = m_player[plrIdx].playertype;	// Get the Mod Type
	
	if(mod_type!=0) // 0 = admin, 1 = mod, -1 = nothing.
		{
		SendServerMessage("Only Admins can use this command", i);
		return;
		}

	SendServerMessage("Stealth Mode Disabled", i);

	m_player[plrIdx].state2|=PLRSTATE2_STEALTH; // force to 1
	m_player[plrIdx].state2^=PLRSTATE2_STEALTH; // force to 0
	SavePlayer(m_player[plrIdx].name, &m_player[plrIdx]);
	SendPlayerChangeData(plrIdx, PLAYERCHANGE_STATUS2);
}

void CGameAppView::SendPlayerChangeData(int plrIdx, BYTE type, int round, int roundval)
{
	char buffer[24];
	int siz;
	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 82;		// MSGGAME_PLAYERCHANGEDATA
	buffer[2] = type;
	buffer[3] = m_player[plrIdx].playerSocketIdx;
	siz = 4;

	switch(type)
	{
		case PLAYERCHANGE_STATUS:buffer[4] = m_player[plrIdx].state;
								siz = 5;
								break;
		case PLAYERCHANGE_RATING:memcpy(&buffer[4], &m_player[plrIdx].rating, 4);
								siz = 8;
								break;
		case PLAYERCHANGE_RATINGANDROUND:
								memcpy(&buffer[4], &m_player[plrIdx].rating, 4);
								memcpy(&buffer[8], &round, 4);
								memcpy(&buffer[12], &roundval, 4);
								memcpy(&buffer[16], &m_player[plrIdx].cash, 4);
								memcpy(&buffer[20], &m_player[plrIdx].ladderPoints, 4);
								siz = 24;
								break;
		case PLAYERCHANGE_STATUS2:memcpy(&buffer[4], &m_player[plrIdx].state2, 4);
								siz = 8;
								break;
		case PLAYERCHANGE_CUE:	memcpy(&buffer[4], &m_player[plrIdx].cuetype, 4);
								siz = 8;
								break;
		case PLAYERCHANGE_VCASHCUE:
								memcpy(&buffer[4], &m_player[plrIdx].cash, 4);
								memcpy(&buffer[8], &m_player[plrIdx].cuetype, 4);
								siz = 12;
								break;
		case PLAYERCHANGE_CHALK:memcpy(&buffer[4], &m_player[plrIdx].chalktype, 4);
								siz = 8;
								break;
		case PLAYERCHANGE_VCASHCHALK:
								memcpy(&buffer[4], &m_player[plrIdx].cash, 4);
								memcpy(&buffer[8], &m_player[plrIdx].chalktype, 4);
								siz = 12;
								break;
		case PLAYERCHANGE_REALCASH:
								memcpy(&buffer[4], &m_player[plrIdx].realcash, 4);
								siz = 8;
								break;

	}
	
	if(mainShell) mainShell->Server->SendToQueue(buffer, siz);
}

void CGameAppView::ReceivePlayerChangeData(char *buffer, int siz)
{
	int plrSockIdx;
	int plrIdx;
	int chalk_index;
	int cue_index;
	BYTE type;
	type = buffer[2];
	plrSockIdx = buffer[3];
	plrIdx = m_lobby->GetPlayerIdx(plrSockIdx);
	if(plrIdx==-1) return; // if socket nolonger exists, then forget it.


	// BAP_FIX6 //
	/*
	if(!m_inviteDlg.m_hWnd) m_inviteDlg.Create(IDD_INVITE);
	if(!m_bootDlg.m_hWnd) m_bootDlg.Create(IDD_BOOT);
	if(!m_playerListDlg.m_hWnd) m_playerListDlg.Create(IDD_PLAYERLIST);
	*/
	switch(type)
		{
		case PLAYERCHANGE_STATUS:
								{
								 m_player[plrIdx].state = buffer[4];
									///////////////////////////////////////					
									// check stats dlg's player name status					
									int state = PLRSTATE_AVAILABLE;
								 
									// check player state and display appropriate dialogue heading
									if(plrIdx!=-1)
									{			
										state = m_player[plrIdx].state&PLRSTATE_STATUSMASK;
										switch(state)
										{
										case PLRSTATE_AVAILABLE:
										if(m_statsTabCtrlDlg.m_hWnd) m_statsTabCtrlDlg.SetWindowText("Player Profile - (Status: Available)");
										break;
										case PLRSTATE_BUSY:
										if(m_statsTabCtrlDlg.m_hWnd) m_statsTabCtrlDlg.SetWindowText("Player Profile - (Status: Busy)");
										break;
										case PLRSTATE_BRB:
										if(m_statsTabCtrlDlg.m_hWnd) m_statsTabCtrlDlg.SetWindowText("Player Profile - (Status: Be Right Back)");
										break;
										case PLRSTATE_AWAY:
										case PLRSTATE_AWAY2:
										if(m_statsTabCtrlDlg.m_hWnd) m_statsTabCtrlDlg.SetWindowText("Player Profile - (Status: Away)");
										break;
										case PLRSTATE_PHONE:
										if(m_statsTabCtrlDlg.m_hWnd) m_statsTabCtrlDlg.SetWindowText("Player Profile - (Status: Phone)");
										break;
										case PLRSTATE_LUNCH:
										if(m_statsTabCtrlDlg.m_hWnd) m_statsTabCtrlDlg.SetWindowText("Player Profile - (Status: Lunch)");
										break;
										case PLRSTATE_DND:
										if(m_statsTabCtrlDlg.m_hWnd) m_statsTabCtrlDlg.SetWindowText("Player Profile - (Status: Do Not Disturb)");
										break;						
										}
									}
									///////////////////////////////////////
								 m_lobby->RefreshPlayerItem();
								 m_inviteDlg.RefreshPlayerItem();
								 m_bootDlg.RefreshPlayerItem();
							 	 m_playerListDlg.RefreshPlayerItem();
								 RefreshListBox();
								 break;
								}
		case PLAYERCHANGE_RATING:memcpy(&m_player[plrIdx].rating, &buffer[4], 4);
								 m_lobby->RefreshPlayerItem();
								 m_inviteDlg.RefreshPlayerItem();
								 m_bootDlg.RefreshPlayerItem();
							 	 m_playerListDlg.RefreshPlayerItem();
								 RefreshListBox();
								 break;
		case PLAYERCHANGE_RATINGANDROUND:
			{
								 int round;
								 int roundval;
								 memcpy(&m_player[plrIdx].rating, &buffer[4], 4);
								 memcpy(&round, &buffer[8], 4);
								 memcpy(&roundval, &buffer[12], 4);
								 memcpy(&m_player[plrIdx].cash, &buffer[16], 4);
								 memcpy(&m_player[plrIdx].ladderPoints, &buffer[20], 4);
								 if(roundval != -1)
								 switch(round)
								 {
										case 100+0:
											m_player[plrIdx].winner = roundval;										
											break;
										case 0:
											m_player[plrIdx].runnerUp = roundval;										
											break;
										case 1:
											m_player[plrIdx].semiFinals = roundval;										
											break;
										case 2:
											m_player[plrIdx].quarterFinals = roundval;										
											break;
										case 3:
											m_player[plrIdx].last16 = roundval;										
											break;
										case 4:
											m_player[plrIdx].last32 = roundval;										
											break;
								 }

								 m_lobby->RefreshPlayerItem();
								 m_inviteDlg.RefreshPlayerItem();
								 m_bootDlg.RefreshPlayerItem();
							 	 m_playerListDlg.RefreshPlayerItem();
								 RefreshListBox();
								 break;
			}
		case PLAYERCHANGE_STATUS2:memcpy(&m_player[plrIdx].state2, &buffer[4], 4);
								 m_lobby->RefreshPlayerItem();
								 m_inviteDlg.RefreshPlayerItem();
								 m_bootDlg.RefreshPlayerItem();
							 	 m_playerListDlg.RefreshPlayerItem();
								 RefreshListBox();
								 break;
		case PLAYERCHANGE_CUE:	 memcpy(&m_player[plrIdx].cuetype, &buffer[4], 4);

								 // If this is us, then update Cue Changer
								 if( plrIdx == this->m_playerIdx )
								 {
									 int cue_index = m_player[plrIdx].cuetype;	// cue_index starts from 0
									 m_cueChanger->SelectCue(cue_index);
								 }
								 break;

		case PLAYERCHANGE_VCASHCUE:
								 memcpy(&m_player[plrIdx].cash, &buffer[4], 4);
								 memcpy(&m_player[plrIdx].cuetype, &buffer[8], 4);

						

								 // If both Rating and Cue were Changed, it means this was a purchase, so update our Inventory and Stats Dialogs
								 cue_index = m_player[plrIdx].cuetype;	// cue_index starts from 0
								 m_player[plrIdx].inventory |= (1<<(16+cue_index));
								 // m_player[plrIdx].cash -= cue_prices[cue_index];
								 
								 // If it's us that's changing the cue, we need to update our Stats Dialogts and Cue Changer
								 if( plrIdx == this->m_playerIdx )
								 {
									// Update Local Variable //
									// m_player[plrIdx].inventory |= (1<<(16+cue_index));
									// m_player[plrIdx].cash -= cue_prices[cue_index];

									g_gameAppView->UpdateStatsDialogs();
									m_cueChanger->SelectCue(cue_index);
								 }

								 // Update Lists
								 m_lobby->RefreshPlayerItem();
								 m_inviteDlg.RefreshPlayerItem();
								 m_bootDlg.RefreshPlayerItem();
							 	 m_playerListDlg.RefreshPlayerItem();
								 RefreshListBox();
								 break;

			case PLAYERCHANGE_CHALK:
			
								 memcpy(&m_player[plrIdx].chalktype, &buffer[4], 4);

								 // If this is us, then update Chalk Changer
								 if( plrIdx == this->m_playerIdx )
								 {
		 							 // Get our Chalk Index (which is the first 8 bits of chalk_type
									 chalk_index = (m_player[plrIdx].chalktype & 0x0f);	
	
									 m_chalkChanger->SelectChalk(chalk_index);
								 }
								 break;

			case PLAYERCHANGE_VCASHCHALK:
								 memcpy(&m_player[plrIdx].cash, &buffer[4], 4);
								 memcpy(&m_player[plrIdx].chalktype, &buffer[8], 4);

						
								 // Get our Chalk Index (which is the first 8 bits of chalk_type
								 chalk_index = (m_player[plrIdx].chalktype & 0x0f);	
								
								 
								 // If it's us that's changing the cue, we need to update our Stats Dialogts and Cue Changer
								 if( plrIdx == this->m_playerIdx )
								 {
									// g_gameAppView->UpdateStatsDialogs(); // No stats for Chalk yet
									m_chalkChanger->SelectChalk(chalk_index);
								 }

								 // Update Lists
								 m_lobby->RefreshPlayerItem();
								 m_inviteDlg.RefreshPlayerItem();
								 m_bootDlg.RefreshPlayerItem();
							 	 m_playerListDlg.RefreshPlayerItem();
								 RefreshListBox();
								 break;

			case PLAYERCHANGE_REALCASH:
								memcpy(&m_player[plrIdx].chalktype, &buffer[4], 4);
								break;

		}
}


void CGameAppView::ReceiveTableChangeData(char *buffer, int siz)
{
	int plrSockIdx;
	int plrIdx;
	BYTE type;
	type = buffer[2];

	g_ftpupload = buffer[4];

	switch(type)
		{
		case TABLECHANGE_SPONSOR:
								{
								switch(buffer[3])
									{
									case 0:strcpy(m_sponsortxt,&buffer[4]);
										   break;
									case 1:strcpy(m_sponsorurl,&buffer[4]);
										   break;
									case 2:g_sponsorback = FALSE;
										   break;
									case 3:g_sponsorback = TRUE;
										   break;
									}
								}
								break;
		}
}

BOOL CGameAppView::InitiateHostCheck(int sockIdx)
{
	  if(m_hostcheckactive!=-1) return FALSE; // still doing another one
	  m_hostcheckactive = sockIdx;
	  m_hostchecktimeout = m_hostchecktimeoutK; // e.g. 5 seconds timeout.
	  buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	  buffer[1] = 70;		// MSGGAME_HOSTCHECK
	  buffer[2] = 0;
	  buffer[3] = 0;

	  mainShell->Server->SendToQueue(buffer, 4, sockIdx); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
	  return TRUE;
}

void CGameAppView::SendKickRequest(void)
{
	unsigned char buffer[32];

	buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	buffer[1] = 73;		// MSGGAME_KICK
	buffer[2] = 0;		// socket index.
	buffer[3] = 0;
	if(mainShell)
	{
		mainShell->Client->SendToQueue(buffer, 4, 0);
	}
}

void CGameAppView::ReceiveKickRequest(int plrSockIdx)
{
	//((CAsyncSocketEx *)mainShell->Server->m_socketList[plrSockIdx])->Kick();	
	mainShell->Server->Kick(plrSockIdx);
	// [+] kill of the timeout for this socket index (like a 5 second timeout) - prevents hacks to stay online.
}

void DateToStr(char *str, int day, int month, int year)
{
	sprintf(str,"[%d/%d/%d]",day,month,year);
}

void StrToDate(char *str, int *day, int *month, int *year)
{
	int n;
	int tick;
	int start;
	int ptr_s;
	int ptr_e;
	tick = 0;
	start = 0;
	ptr_s = -1;
	ptr_e = -1;
	for(n=0;n<256;n++)
	{
	if(!str[n]) break;

	if(start)
		{
		ptr_s = n;
		}
	start = 0;
	if(tick==0) 
		{
		if(str[n]=='[') tick=1,start=1;
		}
	else {
	if(str[n]=='/' || str[n]==']') tick++,start=1;
		}

	if(start)
		{
		ptr_e = n;
		if(ptr_s!=-1)
			{
			str[ptr_e] = 0;
			switch(tick)
				{
				case 2:sscanf(&str[ptr_s],"%d",day);
						break;
				case 3:sscanf(&str[ptr_s],"%d",month);
						break;
				case 4:sscanf(&str[ptr_s],"%d",year);
						break;
				}
			}
		}
	
	}
}

int DaysLeft(int c_d,int c_m,int c_y, 
			 int x_d,int x_m,int x_y)
{
	// x - c = days left
	CTime c;
	CTime x;
	CTimeSpan s;
	c = CTime(c_y,c_m,c_d, 0,0,0);
	x = CTime(x_y,x_m,x_d, 0,0,0);
	s = x-c;
	return s.GetDays();
}

void CGameAppView::GetTime(void)
{
	// example for CTime::Format and CTime::FormatGmt
//	CTime t;//( 1999, 3, 19, 22, 15, 0 ); 
	//CTime m_time = CTime::GetCurrentTime();

	m_time = CTime::GetCurrentTime();

	m_stringFullDate = m_time.Format( "%A, %B %d, %Y" );
	m_stringShortDate = m_time.Format( "%a %b %d, %Y" );

	m_stringFullTime = m_time.Format( "%#I:%M:%S%p (GMT)" );
	m_stringShortTime = m_time.Format( "%H:%M:%S (GMT)" );

	m_stringTimeStamp = m_time.Format( "[%A, %B %d] %H:%M");


	m_ExpDateDay = m_time.GetDay();
	m_ExpDateMonth = m_time.GetMonth();
	m_ExpDateYear = m_time.GetYear();




/*
%a   Abbreviated weekday name
%A   Full weekday name
%b   Abbreviated month name
%B   Full month name
%c   Date and time representation appropriate for locale
%d   Day of month as decimal number (01  31)
%H   Hour in 24-hour format (00  23)
%I   Hour in 12-hour format (01  12)
%j   Day of year as decimal number (001  366)
%m   Month as decimal number (01  12)
%M   Minute as decimal number (00  59)
%p   Current locales A.M./P.M. indicator for 12-hour clock
%S   Second as decimal number (00  59)
%U   Week of year as decimal number, with Sunday as first day of week (00  51)
%w   Weekday as decimal number (0  6; Sunday is 0)
%W   Week of year as decimal number, with Monday as first day of week (00  51)
%x   Date representation for current locale
%X   Time representation for current locale
%y   Year without century, as decimal number (00  99)
%Y   Year with century, as decimal number
%z, %Z   Time-zone name or abbreviation; no characters if time zone is unknown
%%   Percent sign
*/
}

BOOL CGameAppView::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	//char buf[256];
	//sprintf(buf, "wParam = %d", wParam);
	//ErrorMessage(g_wnd, buf);

	if(lParam == SIZE_MAXIMIZED)
	{
		int p;
		p =1;
	}

	// if strike is in progress - don't update mouse data
	#ifndef MAIN_SERVER
	if( m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20)
			return CView::OnNotify(wParam, lParam, pResult);
	#endif //!MAIN_SERVER

	MSGFILTER * lpMsgFilter = (MSGFILTER *)lParam;

	// check whether user has requested the context menu for m_editExChat window
	if ((wParam == IDC_WINDOWCHATVIEW) && (lpMsgFilter->nmhdr.code == EN_MSGFILTER)   
    && (lpMsgFilter->msg == WM_RBUTTONDOWN))                                       
  
    {//if we get through here, we have trapped the right click event of the richeditctrl! 
     CPoint point;                                            
     ::GetCursorPos(&point); //where is the mouse?
     //CMenu menu; //lets display out context menu :) 
	 pMenu1 = new CMenu;//--
	 DWORD dwSelectionMade;                                       
     VERIFY(pMenu1->/*menu.*/LoadMenu(IDR_MENU1) );  
     CMenu *pmenuPopup = pMenu1->/*menu.*/GetSubMenu(0);
     m_pMenuPopup = pmenuPopup;
	 
	 ASSERT(pmenuPopup != NULL);
	 

	 // dim-out certain menu items
	 pmenuPopup->EnableMenuItem(0,MF_GRAYED | MF_BYPOSITION);
	 pmenuPopup->EnableMenuItem(2,MF_GRAYED | MF_BYPOSITION);
     
	 dwSelectionMade = pmenuPopup->TrackPopupMenu( (TPM_LEFTALIGN|TPM_LEFTBUTTON|
                                                       TPM_NONOTIFY|TPM_RETURNCMD),
                                                       point.x, point.y, this
                                );
//	pmenuPopup->DestroyMenu(); // caused crash on ME??? (don't need to destroy context menu)
	m_pMenuPopup = NULL;
	delete pMenu1;//--
	pMenu1 = 0;//--

		 // deal with the user's choice here
		 //char buffer[80];
		 switch(dwSelectionMade)
		 {											  
		 //case ID_EDIT_CUT:
		 //m_editExChat.Cut();
		 //break;
		 case ID_EDIT_COPY:
		 m_editExChat.Copy();
		 break;
		 //case ID_EDIT_PASTE:
		 //m_editExChat.Paste();
		 //break;				   
		 case ID_EDIT_SELECTALL:
		 m_editExChat.SetFocus();
		 DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
		 m_editExChat.SetSel(ss,FALSE);
		 break;
		 }	 		 

     }

	// check whether user has requested the context menu for m_sendEdit window
	else if ((wParam == IDC_WINDOWSENDVIEW) && (lpMsgFilter->nmhdr.code == EN_MSGFILTER)   
    && (lpMsgFilter->msg == WM_RBUTTONDOWN))                                       
  
    {//if we get through here, we have trapped the right click event of the richeditctrl! 
     CPoint point;                                            
     ::GetCursorPos(&point); //where is the mouse?
     //CMenu menu; //lets display out context menu :) 
	 pMenu2 = new CMenu;//--
     DWORD dwSelectionMade;                                       
     VERIFY(pMenu2->/*menu.*/LoadMenu(IDR_MENU1) );  
     CMenu *pmenuPopup = pMenu2->/*menu.*/GetSubMenu(0);
	 m_pMenuPopup = pmenuPopup;
     ASSERT(pmenuPopup != NULL);                                       
     dwSelectionMade = pmenuPopup->TrackPopupMenu( (TPM_LEFTALIGN|TPM_LEFTBUTTON|
                                                       TPM_NONOTIFY|TPM_RETURNCMD),
                                                       point.x, point.y, this
                                );                                
     //pmenuPopup->DestroyMenu(); 
	 m_pMenuPopup = NULL;	
	 delete pMenu2;//--
	 pMenu2 = 0;//--
	 
	 CString strText;

		 // deal with the user's choice here
		 //char buffer[80];
		 switch(dwSelectionMade)
		 {
		 case ID_EDIT_CUT:
		 m_sendEdit.Cut();

		 break;
		 case ID_EDIT_COPY:
		 m_sendEdit.Copy();
		 break;
		 case ID_EDIT_PASTE:
		 {
		 //////////////////////
		//////////////////////
		CHARFORMAT2 cf;
		m_sendEdit.Paste();
		m_sendEdit.SetSel(0,-1);
		strcpy(cf.szFaceName, "System");
		cf.dwEffects = 0;
		cf.crTextColor = RGB(15,15,15);
		cf.dwMask = CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR | CFM_BOLD | CFM_FACE | CFM_SIZE;
		cf.yHeight = 200;
		cf.cbSize = sizeof(CHARFORMAT2);
		m_sendEdit.SetSelectionCharFormat(cf);
		
		// BAP_FIX8
		CString strText = m_sendEdit.GetSelText();

		int iTotalTextLength;
		iTotalTextLength = m_sendEdit.GetWindowTextLength();
		m_sendEdit.SetSel(iTotalTextLength,iTotalTextLength);

		 m_sendEdit.TextAdjust();

		 }
		 break;
		 case ID_EDIT_SELECTALL:
		 m_sendEdit.SetFocus();
		 DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
		 m_sendEdit.SetSel(ss,FALSE);
		 break;
		 }	 		 
     }
	
	// check whether user has requested the context menu for the lobby player list window	
	//else if ((wParam == IDC_LISTCTRLPLAYERS) && (lpMsgFilter->nmhdr.code == EN_MSGFILTER)   
	//	&& (lpMsgFilter->msg == WM_RBUTTONDOWN))

	else if ((wParam == IDC_WINDOWLISTBOX) && (lpMsgFilter->nmhdr.code == EN_MSGFILTER)   
		&& (lpMsgFilter->msg == WM_RBUTTONDOWN))
	{

		CPoint point;                                            
     ::GetCursorPos(&point); //where is the mouse?
     //CMenu menu; //lets display out context menu :) 
	 pMenu2 = new CMenu;//--
     DWORD dwSelectionMade;
     VERIFY(pMenu2->/*menu.*/LoadMenu(IDR_MENU1) );
     CMenu *pmenuPopup = pMenu2->/*menu.*/GetSubMenu(0);
	 m_pMenuPopup = pmenuPopup;
     ASSERT(pmenuPopup != NULL);                                       
     dwSelectionMade = pmenuPopup->TrackPopupMenu( (TPM_LEFTALIGN|TPM_LEFTBUTTON|
                                                       TPM_NONOTIFY|TPM_RETURNCMD),
                                                       point.x, point.y, this
                                );                                
     //pmenuPopup->DestroyMenu(); 
	 m_pMenuPopup = NULL;	
	 delete pMenu2;//--
	 pMenu2 = 0;//--
	 CString strText;
	

	switch(dwSelectionMade)
	{
		case ID_EDIT_CUT:
			m_sendEdit.Cut();
		 
			// If no text in the string, set the button to inactive
			m_sendEdit.GetWindowText(strText);

			break;
			case ID_EDIT_COPY:
			m_sendEdit.Copy();
			break;

		case ID_EDIT_PASTE:
			{
			//////////////////////
			CHARFORMAT2 cf;
			m_sendEdit.Paste();
			m_sendEdit.SetSel(0,-1);
			strcpy(cf.szFaceName, "System");
			cf.dwEffects = 0;
			cf.crTextColor = RGB(15,15,15);
			cf.dwMask = CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR | CFM_BOLD | CFM_FACE | CFM_SIZE;
			cf.yHeight = 200;
			cf.cbSize = sizeof(CHARFORMAT2);
			m_sendEdit.SetSelectionCharFormat(cf);
		
			// BAP_FIX8
			CString strText = m_sendEdit.GetSelText();

			int iTotalTextLength;
			iTotalTextLength = m_sendEdit.GetWindowTextLength();
			m_sendEdit.SetSel(iTotalTextLength,iTotalTextLength);
			}
			break;

		case ID_EDIT_SELECTALL:
			m_sendEdit.SetFocus();
			DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
			m_sendEdit.SetSel(ss,FALSE);
			break;
		}	 		 
	}
	
	//m_sendEdit.SetFocus();

	return CView::OnNotify(wParam, lParam, pResult);
}

void CGameAppView::OnEditPaste() 
{
	// TODO: Add your command handler code here
	//////////////////////
	CWnd *focus = GetFocus();
	if(focus == &m_sendEdit)
	{
		
		//////////////////////
		CHARFORMAT2 cf;
		cf.dwMask = CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR | CFM_BOLD | CFM_FACE | CFM_SIZE;
		m_sendEdit.Paste();
		m_sendEdit.SetSel(0,-1);
		strcpy(cf.szFaceName, "System");
		cf.dwEffects = 0;
		cf.crTextColor = RGB(15,15,15);
		cf.yHeight = 200;
		cf.cbSize = sizeof(CHARFORMAT2);
		m_sendEdit.SetSelectionCharFormat(cf);
		
		// BAP_FIX8
		CString strText = m_sendEdit.GetSelText();

		int iTotalTextLength;
		iTotalTextLength = m_sendEdit.GetWindowTextLength();
		m_sendEdit.SetSel(iTotalTextLength,iTotalTextLength);

	}
}		 

void CGameAppView::OnEditCopy() 
{
	// TODO: Add your command handler code here
	CWnd *focus = GetFocus();
	if(focus == &m_sendEdit) m_sendEdit.Copy();
	else if(focus == &m_editExChat) m_editExChat.Copy();
}

void CGameAppView::OnEditCut() 
{
	// TODO: Add your command handler code here
	CWnd *focus = GetFocus();
	if(focus == &m_sendEdit) m_sendEdit.Cut();
	
	CString strText;
	// If no text in the string, set the button to inactive
	m_sendEdit.GetWindowText(strText);

}

void CGameAppView::OnEditSelectall() 
{
	// TODO: Add your command handler code here

	CWnd *focus = GetFocus();
	if(focus == &m_sendEdit)
	{
		DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
		m_sendEdit.SetSel(ss,FALSE);
	}
	else
	{
		DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
		m_editExChat.SetSel(ss,FALSE);
	}
}

BOOL LoadGfxDetails(void)
{
	int success;
	FILE *fptr = NULL;

	char fname_full[128];
	sprintf(fname_full, "%s%s", g_build.savepath, "GFXDetails.txt");

	fptr = fopen(fname_full,"r");
	if(fptr)
	{
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsLowgfx);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsMediumgfx);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsHighgfx);
		if(success == EOF) goto end;
		
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptions2DMode);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptions2D3DMode);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptions2DTVAutoMode);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptions2D3DFreeMode);
		if(success == EOF) goto end;


		success = fscanf(fptr,"%d",&g_gfxDetails.bFrameRateDisplay);
		if(success == EOF) goto end;

		success = fscanf(fptr,"%d",&g_gfxDetails.bSoundBalls);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.bSoundClapping);
		if(success == EOF) goto end;
						  
		success = fscanf(fptr,"%d",&g_gfxDetails.bEyeCamDrawCueTip);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.bEyeCamDrawCueTransparent);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.bEyeCamDrawCueSolid);
		if(success == EOF) goto end;
		
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsAntiAliasing);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsWireframe);
		if(success == EOF) goto end;


		//-----------------------------------------//
		// load screen coords.
		success = fscanf(fptr,"%d",&g_gfxDetails.x);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.y);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.cx);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.cy);
		if(success == EOF) goto end;
		//-----------------------------------------//

		success = fscanf(fptr,"%d",&g_gfxDetails.bHighPerformance);
		if(success == EOF) goto end;

		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsShowMiniCam);
		if(success == EOF) goto end;
		
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsComplexShadows);
		if(success == EOF) goto end;

		success = fscanf(fptr,"%d",&g_gfxDetails.optionsSetRefreshRate);
		if(success == EOF) goto end;

		//-----------------------------------------//
		// 'Game'->'Invitations'
		success = fscanf(fptr,"%d",&g_gfxDetails.bDeclineAllGuests);
		if(success == EOF) goto end;
		success = fscanf(fptr,"%d",&g_gfxDetails.bDeclineAll);
		if(success == EOF) goto end;		
		//-----------------------------------------//

		success = fscanf(fptr,"%d",&g_gfxDetails.bShowLoginWizard);
		if(success == EOF) goto end;		

		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsDrawColourSL);
		if(success == EOF) goto end;		

		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsDrawErrorSL);
		if(success == EOF) goto end;		
		
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsDrawStaticPower);
		if(success == EOF) goto end;

		//-----------------------------------------//
		// set up this ghost cue-ball variable first - just in case we don't have it in file
		g_gfxDetails.bOptionsDrawGhostCueBall = g_gfxDetails.bOptionsDrawErrorSL;
		if(g_gfxDetails.bOptionsDrawErrorSL) g_gfxDetails.bOptionsDrawCueBallLE = 0;
		else g_gfxDetails.bOptionsDrawCueBallLE = 1;
		
		// override - if in file
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsDrawGhostCueBall);
		if(success == EOF) goto end;
		//-----------------------------------------//
		// override - if in file
		success = fscanf(fptr,"%d",&g_gfxDetails.bOptionsDrawCueBallLE);
		if(success == EOF) goto end;
		//-----------------------------------------//
		
		// 'File'->'Auto Save Frames'
		success = fscanf(fptr,"%d",&g_gfxDetails.bAutoSaveFrames);
		if(success == EOF) goto end;
	
		// 'Sound Voices '
		success = fscanf(fptr,"%d",&g_gfxDetails.bSoundVoices);
		if(success == EOF) goto end;

		// 'WideScreenMode'
		success = fscanf(fptr,"%d",&g_WideScreenEnabled);
		if(success == EOF) goto end;

		int garbage;
		// 'Remember Password'
		success = fscanf(fptr,"%d",&garbage );
		// success = fscanf(fptr,"%d",&g_RememberPassword );
		if(success == EOF) goto end;


		// 'Default Color Scheme'
		success = fscanf(fptr,"%d",&g_gfxDetails.bDefaultColorScheme);
		if(success == EOF) goto end;

		// 'Show Show In LobbyTV'
		success = fscanf(fptr,"%d",&g_gfxDetails.bShowShotInLobbyTV);
		if(success == EOF) goto end;

		success = fscanf(fptr,"%d",&g_gfxDetails.iOptionsSensitivity);
		if(success == EOF) goto end;

		// 'Colour Blind Option'
		success = fscanf(fptr, "%d", &g_gfxDetails.bOptionsColourBlind);
		if (success == EOF) goto end;

		// 'Dotted Cue Ball Option'
		success = fscanf(fptr, "%d", &g_gfxDetails.bOptionsDottedCueBall);
		if (success == EOF) goto end;

		// 'Mini Cam Show Helpers Option'
		success = fscanf(fptr, "%d", &g_gfxDetails.bOptionsMiniCamShowHelpers);
		if (success == EOF) goto end;

		// 'Mini Cam Lock Mouse Option'
		success = fscanf(fptr, "%d", &g_gfxDetails.bOptionsMiniCamLockMouse);
		if (success == EOF) goto end;

		// g_gameAppView->m_snooker->SetMouseSensitivity(g_gfxDetails.iOptionsSensitivity); 

		//-----------------------------------------//
				
		end:;

		return TRUE;
	}
	
	return FALSE;
}

BOOL SaveGfxDetails(void)
{
	FILE *fptr = NULL;

	char fname_full[128];
	sprintf(fname_full, "%s%s", g_build.savepath, "GFXDetails.txt");

	fptr = fopen(fname_full,"w");
	if(fptr)
	{
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsLowgfx);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsMediumgfx);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsHighgfx);

		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptions2DMode);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptions2D3DMode);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptions2DTVAutoMode);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptions2D3DFreeMode);


		fprintf(fptr,"%d\r\n",g_gfxDetails.bFrameRateDisplay);

		fprintf(fptr,"%d\r\n",g_gfxDetails.bSoundBalls);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bSoundClapping);

		fprintf(fptr,"%d\r\n",g_gfxDetails.bEyeCamDrawCueTip);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bEyeCamDrawCueTransparent);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bEyeCamDrawCueSolid);

		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsAntiAliasing);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsWireframe);


		//-----------------------------------------//
		// save screen coords.
		fprintf(fptr,"%d\r\n",g_gfxDetails.x);
		fprintf(fptr,"%d\r\n",g_gfxDetails.y);
		fprintf(fptr,"%d\r\n",g_gfxDetails.cx);
		fprintf(fptr,"%d\r\n",g_gfxDetails.cy);
		//-----------------------------------------//

		fprintf(fptr,"%d\r\n",g_gfxDetails.bHighPerformance);

		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsShowMiniCam);

		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsComplexShadows);

		fprintf(fptr,"%d\r\n",g_gfxDetails.optionsSetRefreshRate);

		//-----------------------------------------//
		// 'Game'->'Invitations'
		fprintf(fptr,"%d\r\n",g_gfxDetails.bDeclineAllGuests);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bDeclineAll);
		//-----------------------------------------//

		fprintf(fptr,"%d\r\n",g_gfxDetails.bShowLoginWizard);

		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsDrawColourSL);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsDrawErrorSL);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsDrawStaticPower);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsDrawGhostCueBall);
		fprintf(fptr,"%d\r\n",g_gfxDetails.bOptionsDrawCueBallLE);

		//-----------------------------------------//
		// 'File'->'Auto Save Frames'
		fprintf(fptr,"%d\r\n",g_gfxDetails.bAutoSaveFrames);
		
		// 'SoundVocies' //
		fprintf(fptr,"%d\r\n",g_gfxDetails.bSoundVoices);
		
		// WideScreenMode
		fprintf(fptr,"%d\r\n",g_WideScreenEnabled);

		// Remember Password
		fprintf(fptr,"%d\r\n",g_RememberPassword);

		// Default Color Scheme
		fprintf(fptr,"%d\r\n",g_gfxDetails.bDefaultColorScheme);
		
		// Show Shot In LobbyTV
		fprintf(fptr,"%d\r\n",g_gfxDetails.bShowShotInLobbyTV);
		

		// Mouse Sensitivity
		fprintf(fptr,"%d\r\n",g_gfxDetails.iOptionsSensitivity);
		
		// Color Blind
		fprintf(fptr, "%d\r\n", g_gfxDetails.bOptionsColourBlind);

		// Dotted Cue Ball
		fprintf(fptr, "%d\r\n", g_gfxDetails.bOptionsDottedCueBall);

		// Mini Cam Show Helpers
		fprintf(fptr, "%d\r\n", g_gfxDetails.bOptionsMiniCamShowHelpers);

		// Mini Cam Lock Mouse
		fprintf(fptr, "%d\r\n", g_gfxDetails.bOptionsMiniCamLockMouse);


		//-----------------------------------------//
														
		fclose(fptr);

		return TRUE;
	}
	
	return FALSE;
}

BOOL LoadSetupDetails(void)
{
	int success;
	FILE *fptr = NULL;

	char fname_full[128];
	sprintf(fname_full, "%s%s", g_build.savepath, "SetupDetails.txt");

	fptr = fopen(fname_full,"r");
	if(fptr)
	{
		// GFX quality state for app.
		success = fscanf(fptr,"%d",&g_setupDetails.bGfxQuality);
		if(success == EOF) goto end;

		success = fscanf(fptr,"%s",&g_setupDetails.appNameToExecute);
		if(success == EOF) goto end;
						
		end:;

		fclose(fptr);

		return TRUE;
	}
	
	return FALSE;
}

// Computer Code (This is for AI opponent play)
void CGameAppView::ComputerPracticeInit(void) 
{
	#ifndef MAIN_SERVER
/*	// Set up the start-up table position
	m_snooker->Init(RERACK_START);
	m_snooker->m_bPracticeMode = TRUE;
	//m_snooker->m_bComputerMode = FALSE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	if(m_snooker->m_playersType == PLAYERS_1PVSCPU) ChangeTitle(" 1P Vs CPU");
	else if(m_snooker->m_playersType == PLAYERS_CPUVS1P) ChangeTitle(" CPU Vs 1P");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();*/

	m_snooker->m_customTable->ChangeGameType(0); // revert back to default game type
	OnPracticeStart();
	#endif //!MAIN_SERVER
}

void CGameAppView::ComputerPracticeDeinit(void) 
{
	#ifndef MAIN_SERVER

	#endif //!MAIN_SERVER
}

void CGameAppView::ComputerPracticeProcess(void) 
{
	#ifndef MAIN_SERVER

	#endif //!MAIN_SERVER
}

void CGameAppView::ComputerPracticeDraw(void) 
{
	#ifndef MAIN_SERVER

	#endif //!MAIN_SERVER
}

void CGameAppView::ComputerPracticeOnDraw(CDC* pDC, int x, int y)
{
	#ifndef MAIN_SERVER
#if 0
	// draw seats
	for(int n=0;n<2;n++)
	{
		RECT rect;
		int offset;
		char buffer[81];
		offset = n * (160 + 40);

		CPen pen2(PS_NULL, 0, RGB(20,20,20));
		CBrush brush2(RGB(243,246,29));
		//CBrush brush2(RGB(0,0,0));
		CBrush *oldBrush2 = pDC->SelectObject(&brush2);
		CPen *oldPen2 = pDC->SelectObject(&pen2);
		pDC->Rectangle(40+n*(x-160-80)+160-offset, x*0.5f+8, 40+n*(x-160-80)+160-offset+40, x*0.5f+8+24); // P1
		pDC->SelectObject(oldBrush2);
		pDC->SelectObject(oldPen2);
		RectangleShaded(pDC,40+n*(x-160-80)+160-offset, -7 + x*0.5f+8, 40+n*(x-160-80)+160-offset+40, 9 + x*0.5f+8+24, RGB(243,246,29)); //P1
/*
		if(m_state==SEAT_EMPTY) // Only Draw Button if empty.
		{
		m_button.SetWindowPos(NULL, 40+n*(x-160-80)+160-offset, x*0.5f+8, 40, 24, SWP_SHOWWINDOW);//SWP_NOREDRAW);//
		m_button.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
		}
*/
		
//		m_button.GetWindowRect(&rect);
		
		CPen pen(PS_SOLID, 0, RGB(20,20,20));
		CBrush brush(RGB(255,255,255));//RGB(25,25,115));//RGB(243,246,29));
		CBrush *oldBrush = pDC->SelectObject(&brush);
		CPen *oldPen = pDC->SelectObject(&pen);

		pDC->Rectangle(40+n*(x-160-80), x*0.5f+8, 40+n*(x-160-80)+160, x*0.5f+24+8); // P1
		
		pDC->SelectObject(oldBrush);
		pDC->SelectObject(oldPen);

//		if(m_state==SEAT_TAKEN)
//		{
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetBkColor(RGB(255,255,225));//RGB(25,25,115));//RGB(243,246,29));//RGB(255,255,225));
		
		if(m_snooker->m_playersType == PLAYERS_1PVSCPU)
		{
			if(n==0) pDC->TextOut(40+n*(x-160-80)+8, x*0.5f+4+8, "Human");//m_name);
			else pDC->TextOut(40+n*(x-160-80)+8, x*0.5f+4+8, "CPU");//m_name);
		}
		else if(m_snooker->m_playersType == PLAYERS_CPUVS1P)
		{
			if(n==0) pDC->TextOut(40+n*(x-160-80)+8, x*0.5f+4+8, "CPU");//m_name);
			else pDC->TextOut(40+n*(x-160-80)+8, x*0.5f+4+8, "Human");//m_name);
		}

//		}
		//pDC->TextOut(50, 50, "Chobby");
			
		// display 1P / 2P
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetBkColor(RGB(243,246,29));
		//pDC->SetBkColor(RGB(0,0,0));
		sprintf(buffer, "P%d", n+1);
		pDC->TextOut(0+n*(x-160+80+40)+8, x*0.5f+4+8, buffer);
		/*
		// display scores
		sprintf(buffer, "%d", ((CGameAppView *)m_pParentWnd)->m_snooker->m_score1P);
		pDC->TextOut(160+125+n*(x+(-160-125)*2), x*0.5f+4+8, buffer);
		*/
	}
#endif //0
	#endif //!MAIN_SERVER
}				 
/*
void CGameAppView::OnPlayers1pvscpu() 
{
	// TODO: Add your command handler code here
	#ifndef MAIN_SERVER
	CMenu *subMenu = AfxGetMainWnd()->GetMenu()->GetSubMenu(PLAYERS_MENU);
	m_snooker->m_playersType = PLAYERS_1PVSCPU;
	subMenu->CheckMenuItem(PLAYERS_1PVSCPU, MF_CHECKED | MF_BYPOSITION);
	subMenu->CheckMenuItem(PLAYERS_CPUVS1P, MF_UNCHECKED | MF_BYPOSITION);

	// Set up the start-up table position
//	m_snooker->Init(RERACK_START);
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = TRUE;
	m_snooker->m_seat = 0; // force player to sit in 1P seat

	// refresh
	m_EndPracticeButton.EnableWindow(FALSE);
	m_EndPracticeButton.ShowWindow(SW_HIDE);
	m_practiceEditDlg.DestroyWindow();
	m_practiceEditDlg.m_commentDlg.DestroyWindow();
	m_replayDlg.DestroyWindow();

	// clear out all the text in the chat window
	DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
	m_editExChat.SetSel(ss,FALSE);
	m_editExChat.ReplaceSel(_T(""));
	//m_editExChat.Clear(); // Beep
	m_sendEdit.SetSel(ss,FALSE);
	m_sendEdit.ReplaceSel(_T(""));

	ChangeTitle(" 1P Vs CPU");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
	
	#endif //!MAIN_SERVER
}

void CGameAppView::OnPlayersCpuvs1p() 
{
	// TODO: Add your command handler code here
	#ifndef MAIN_SERVER
	CMenu *subMenu = AfxGetMainWnd()->GetMenu()->GetSubMenu(PLAYERS_MENU);
	m_snooker->m_playersType = PLAYERS_CPUVS1P;
	subMenu->CheckMenuItem(PLAYERS_1PVSCPU, MF_UNCHECKED | MF_BYPOSITION);
	subMenu->CheckMenuItem(PLAYERS_CPUVS1P, MF_CHECKED | MF_BYPOSITION);

	// Set up the start-up table position
//	m_snooker->Init(RERACK_START);
	m_snooker->m_bPracticeMode = TRUE;
	m_snooker->m_bComputerMode = TRUE;
	m_snooker->m_seat = 1; // force player to sit in 2P seat

	// refresh
	m_EndPracticeButton.EnableWindow(FALSE);
	m_EndPracticeButton.ShowWindow(SW_HIDE);
	m_practiceEditDlg.DestroyWindow();
	m_practiceEditDlg.m_commentDlg.DestroyWindow();
	m_replayDlg.DestroyWindow();

	// clear out all the text in the chat window
	DWORD ss = 0x0000ffff; // LWORD = 0, HWORD = -1
	m_editExChat.SetSel(ss,FALSE);
	m_editExChat.ReplaceSel(_T(""));
	//m_editExChat.Clear(); // Beep
	m_sendEdit.SetSel(ss,FALSE);
	m_sendEdit.ReplaceSel(_T(""));

	ChangeTitle(" CPU Vs 1P");
	g_bMenuSelect = 0;
	m_bDisableOnDraw = 0;
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	PreviousWndEditSetFocus();
	#endif //!MAIN_SERVER
}

void CGameAppView::OnUpdatePlayers1pvscpu(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && !gameShell))
		pCmdUI->Enable(TRUE);
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdatePlayersCpuvs1p(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && !gameShell))
		pCmdUI->Enable(TRUE);
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}
*/

void CGameAppView::OnRegisterNewaccount() 
{
	// TODO: Add your command handler code here
	if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		m_connectStyle = CONNECTSTYLE_NEWACC;
		ShowTerms(); // This Function Calls up ConnectToLobby if User Agrees with Terms - ConnectToLobby(TRUE);
	}
	else
	{
		m_connectStyle = CONNECTSTYLE_NEWACC;
		ShowTerms(); // This Function Calls up ConnectToLobby if User Agrees with Terms - ConnectToLobby(TRUE);
		// ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thepoolclub.com/register.php"),_T(""),NULL,0);	
	}
}

void CGameAppView::OnRegisterTopupaccount() 
{
	// TODO: Add your command handler code here
	m_connectStyle = CONNECTSTYLE_TOPUP;
	ShowTerms(); // This Function Calls up ConnectToLobby if User Agrees with Terms - ConnectToLobby(TRUE);
}

void CGameAppView::OnRegisterPurchase() 
{
	// TODO: Add your command handler code here
	if(g_build.gameType == GAMETYPE_SNOOKER)
	ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thesnookerclub.com/register.php"),_T(""),NULL,0);	
	else if(g_build.gameType == GAMETYPE_POOL)
	ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"), _T("http://www.thepoolclub.com/register.php"),_T(""),NULL,0);	
}

void CGameAppView::OnUpdateRegisterNewaccount(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( !m_lobby->m_bInLobby && 
		m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) ==-1 )		
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdateRegisterTopupaccount(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	if( !m_lobby->m_bInLobby && 
		m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) ==-1 )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);

#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

void CGameAppView::OnUpdateRegisterPurchase(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
#ifndef MAIN_SERVER
	
	if( !m_lobby->m_bInLobby && 
		m_lobby->GetTableIdxFromPlayer(m_playerSockIdx) ==-1 )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	
#else
	pCmdUI->Enable(FALSE);
#endif //MAIN_SERVER 
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
// shell / lobby / gameshell code - Note: this code has now been moved here into the gameappview file

void CGameAppView::DrawSeatsOnly(int x, int y)
{

}

void CGameAppView::DrawSeats(int x, int y)
{


}				 

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////



void CGameAppView::SitName(int idx, char *name, int plrSockIdx)
{
	if(idx == 0)
	{
		strcpy(m_sit1PButton.m_name, name);
		
		// if this is me sitting/standing
		if(plrSockIdx == m_playerSockIdx)
		{
			if(m_sit1PButton.m_name[0] == 0)
				m_snooker->m_seat = -1;
			else
				m_snooker->m_seat = 0;
		}
	}
	else if(idx == 1)
	{
		strcpy(m_sit2PButton.m_name, name);

		// if this is me sitting/standing
		if(plrSockIdx == m_playerSockIdx)
		{
			if(m_sit2PButton.m_name[0] == 0)
				m_snooker->m_seat = -1;
			else
				m_snooker->m_seat = 1;
		}
	}
	else if(idx == 2)
	{
		strcpy(m_sit1PButtonB.m_name, name);
		
		// if this is me sitting/standing
		if(plrSockIdx == m_playerSockIdx)
		{
			if(m_sit1PButtonB.m_name[0] == 0)
				m_snooker->m_seat = -1;
			else
				m_snooker->m_seat = 2;
		}
	}
	else if(idx == 3)
	{
		strcpy(m_sit2PButtonB.m_name, name);

		// if this is me sitting/standing
		if(plrSockIdx == m_playerSockIdx)
		{
			if(m_sit2PButtonB.m_name[0] == 0)
				m_snooker->m_seat = -1;
			else
				m_snooker->m_seat = 3;
		}
	}

	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////

void CGameAppView::SitClicked(int id)
{
	if(id < 4)
		{
			// handle sending of sit/stand request via mainShell
			int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
			if(plrIdx!=-1)
			if( m_player[plrIdx].table!=-1) // must be in table (not pracitce table!!)
			{
				int enter;
				int tbl = m_player[plrIdx].table;
				int sockIdx = m_playerSockIdx;
				// 0 - Watch / 1 - 1P Join / 2 - 2P Join (bug here! what if player clicks join/watch together??)
				if(m_table[tbl].player1SockIdx == sockIdx) enter = 1;
				else if(m_table[tbl].player2SockIdx == sockIdx)	enter = 2;
				else if(m_table[tbl].player1bSockIdx == sockIdx) enter = 3;
				else if(m_table[tbl].player2bSockIdx == sockIdx) enter = 4;
				else enter = 0;
				
				if(!enter) // check if player is a watcher?
				{
					if(id == 0) SendPlayerSit(FALSE, sockIdx, -1, tbl, -1, -1);
					else if(id ==1) SendPlayerSit(FALSE, -1, sockIdx, tbl, -1, -1);
					else if(id ==2) 
						{
						SendPlayerSit(FALSE, -1, -1, tbl, sockIdx, -1);
						}
					else if(id ==3) SendPlayerSit(FALSE, -1, -1, tbl, -1, sockIdx);
				}
			}
		}
	else{ 
		if(m_standButtonEnabled == TRUE)
			{
			switch(id)
				{

				case 100: // Stand Up
						
						int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
						if(plrIdx!=-1)					
						if( m_player[plrIdx].table!=-1) // must be in table (not pracitce table!!)
						{
							int enter;
							int tbl = m_player[plrIdx].table;
							int sockIdx = m_playerSockIdx;
							if(m_table[tbl].player1SockIdx == sockIdx) enter = 1;
							else if(m_table[tbl].player2SockIdx == sockIdx) enter = 2;
							else if(m_table[tbl].player1bSockIdx == sockIdx) enter = 3;
							else if(m_table[tbl].player2bSockIdx == sockIdx) enter = 4;



							else enter = 0;
												
							if(enter) // check if player is NOT a watcher?
							{
								SendPlayerSit(FALSE, sockIdx, sockIdx, tbl, sockIdx, sockIdx);
							}
						}
				break;
				}
			}
		else{
			//Message("You cannot 'Stand' during a game", 10);
			}
		}
	
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////

void CGameAppView::RefreshListBox(void)
{
	
	m_listBox.m_totalItems = 0;


	int tblIdx = m_lobby->GetTableIdxFromPlayer(m_playerSockIdx);
	if(tblIdx!=-1)
	for(int g=0;g<6;g++)
	for(int n=0;n<MAX_LOBBY_PLAYERS;n++)
	{
		if( !m_lobby->IsPlayerInGroup(n, g) ) continue;

		if(m_player[n].status && m_player[n].table == tblIdx)
		{
			//AddPlayerItem(m_player[n].name, m_player[n].rating, m_player[n].table+1);
			CString name = m_player[n].name;
			int rating = m_player[n].rating;
			int tableNo = m_player[n].table+1;
			int level = m_player[n].level;

			CString items[3];
			items[0] = name;
			items[1].Format("%d", rating);
			items[2].Format("%d", level);
				
			m_listBox.CreateItem(m_listBox.m_totalItems, items );
		}
	}

	//m_listBox.RedrawItems(0, m_listBox.m_totalItems);

	

	// clear redraw flag - while we add items to list
	m_listBox.SetRedraw(FALSE);

	// clear dead players from end of list
	for(int n=m_listBox.m_totalItems;n<MAX_LOBBY_PLAYERS;n++)
	{
		m_listBox.DeleteItem(n);
	}
	
	// Set redraw flag - since we've finished adding items to list
	m_listBox.SetRedraw(TRUE);


	// search list for previous selection name (not the player list!)
	for(int n=0;n<MAX_LOBBY_PLAYERS;n++)
	{
		CString str;
			
		str = m_listBox.GetItemText(n, 0);
		if( strcmpi(str, m_listBox.m_lastSelectedName) == 0 )
		{
			m_listBox.SetItemState(n, LVIS_SELECTED, LVIS_SELECTED);
			break;
		}		
	}

	// we must force the scrollbar to be on, since SetRedraw screws with this //
	m_listBox.ShowScrollBar(SB_VERT);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////

void CGameAppView::OnDebugActivate() 
{
	// TODO: Add your command handler code here
	Message("Debug Activated!", 40);
	g_socketlog = TRUE;
}

void CGameAppView::OnDebugDeactivate() 
{
	// TODO: Add your command handler code here
	Message("Debug De-Activated!", 40);
	g_socketlog = FALSE;	
}

void CGameAppView::OnRabuseSend() 
{
	// TODO: Add your command handler code here
	if(m_snooker->m_bPracticeMode)
	{
		// do nothing if in practice mode
	}
	else
	{
			//if(!OptionNotForGuest(m_playerSockIdx))
			{
			m_recentLog->Report();
			}
	}
}

void CGameAppView::OnSponsorWebsite() 
{
	// TODO: Add your command handler code here
	if( strcmp(m_sponsorurl, "") == 0);
	else ShellExecute(AfxGetMainWnd()->m_hWnd,_T("open"),m_sponsorurl,_T(""),NULL,0);
/*
	char buf[256];
	sprintf(buf, "%s", m_sponsorurl);
	ErrorMessage(g_wnd, buf);	
*/
}

void CGameAppView::OnFileLoad() 
{
	// TODO: Add your command handler code here

	// check - bring up replay panel
	if(!m_bReplayMode)
	{
		m_replayDlg.DestroyWindow();
		m_replayDlg.Create(IDD_REPLAY);
		m_bReplayMode = TRUE;
		m_replayDlg.ShowWindow(SW_SHOW);
	}
	
	// & load dialog	
	m_replayDlg.ReplayLoad();
}

/*
 * This will Load a Replay File Name. Used in Drag Drop, since we don't bother opening a File Open Dialog etc.
 */
bool CGameAppView::LoadReplay(char *fname)
{

	if( m_snooker->m_bPracticeMode || m_bPlayOffline )
	{
		// Proceed
	}
	else return false;

	// Try to Load Replay File.

	// Create Replay Dialog by Default. If we fail to load Replay, we'll have to close this
	// check - bring up replay panel
	if(!m_bReplayMode)
	{
		m_replayDlg.DestroyWindow();
		m_replayDlg.Create(IDD_REPLAY);
		m_bReplayMode = TRUE;
		m_replayDlg.ShowWindow(SW_SHOW);
	}

	// & load dialog	
	if(m_replayDlg.LoadReplay(fname) == false)
	{
		// If we failed to Load Replay then close the Replay Dialog
		m_replayDlg.DestroyWindow();
		m_bReplayMode = FALSE;
		return false;
	}

	return true;
}


void CGameAppView::OnUpdateFileLoad(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
		pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER 
}

void CGameAppView::OnFileSave() 
{
	// TODO: Add your command handler code here
	m_bPlayOffline = FALSE;

	if(!m_bReplayMode)
	{
		m_replayDlg.DestroyWindow();
		m_replayDlg.Create(IDD_REPLAY);
		m_bReplayMode = TRUE;
		m_replayDlg.ShowWindow(SW_SHOW);
	}
	
	// & load dialog	
	m_replayDlg.ReplaySave();
}

void CGameAppView::OnUpdateFileSave(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && !gameShell))
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
		pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER 
}


// menu 'Game' selections (note: these are same as clicking buttons)
void CGameAppView::OnGameStart() 
{
	// TODO: Add your command handler code here
	OnButtonStart();
}

void CGameAppView::OnUpdateGameStart(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby || m_snooker->m_bPracticeMode) )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
	pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER 
}

void CGameAppView::OnGameRerack() 
{
	// TODO: Add your command handler code here
	OnButtonReRack();
}

void CGameAppView::OnUpdateGameRerack(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby || m_snooker->m_bPracticeMode) )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
	pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER 
}

void CGameAppView::OnGameConcede() 
{
	// TODO: Add your command handler code here
	OnButtonConcede();
}

void CGameAppView::OnUpdateGameConcede(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby || m_snooker->m_bPracticeMode) )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
	pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER 
}

void CGameAppView::OnGameStandup() 
{
	// TODO: Add your command handler code here
	m_standButton.Clicked();	
}

void CGameAppView::OnUpdateGameStandup(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && !m_snooker->m_bPracticeMode) )
	{
		if( m_standButton.IsWindowEnabled() ) pCmdUI->Enable(TRUE);
		else pCmdUI->Enable(FALSE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
	pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER
}

void CGameAppView::OnGameInvite() 
{
	// TODO: Add your command handler code here
	OnButtonInvite();
}

void CGameAppView::OnUpdateGameInvite(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby || m_snooker->m_bPracticeMode) )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
	pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER	
}

void CGameAppView::OnGameBoot() 
{
	// TODO: Add your command handler code here
	OnButtonBoot();
}

void CGameAppView::OnUpdateGameBoot(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby || m_snooker->m_bPracticeMode) )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
	pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER	
}

void CGameAppView::OnGameSetup() 
{
	// TODO: Add your command handler code here
	OnButtonSetup();		
}

void CGameAppView::OnUpdateGameSetup(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby || m_snooker->m_bPracticeMode) )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
	pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER	
}

void CGameAppView::OnGameExit() 
{
	// TODO: Add your command handler code here
	OnButtonExit();	
}

void CGameAppView::OnUpdateGameExit(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby || m_snooker->m_bPracticeMode) )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
	pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER	
}

void CGameAppView::OnGameUndo() 
{
	// TODO: Add your command handler code here
	OnButtonUndo();
}

void CGameAppView::OnUpdateGameUndo(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode && m_snooker->m_cueBallSelect == 0) )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
	pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER	
}

void CGameAppView::OnPLAYERS1PVs2P() 
{
	// TODO: Add your command handler code here
	
	// set menu 'players' - '1P Vs 2P'
	CMenu *menu = AfxGetMainWnd()->GetMenu();
	CMenu *subMenu;
	if(menu)
	{
		m_bPlayOffline^=1; // toggle ON/OFF	
		if( m_bPlayOffline ) m_snooker->m_playersType = PLAYERS_1PVS2P;
		else m_snooker->m_playersType = -1;
				
		subMenu = menu->GetSubMenu(PLAYERS_MENU);
		if(subMenu)
		{
			if(m_snooker->m_playersType == PLAYERS_1PVS2P)
				subMenu->CheckMenuItem(PLAYERS_1PVS2P, MF_CHECKED | MF_BYPOSITION);
			else
				subMenu->CheckMenuItem(PLAYERS_1PVS2P, MF_UNCHECKED | MF_BYPOSITION);
		}
	}
}

void CGameAppView::OnUpdatePLAYERS1PVs2P(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	pCmdUI->Enable(FALSE);

	#ifndef MAIN_SERVER
	if( (!m_lobby->m_bInLobby && m_snooker->m_bPracticeMode) )
	{
		pCmdUI->Enable(TRUE);
	}
	else
		pCmdUI->Enable(FALSE);
	#else
	pCmdUI->Enable(FALSE);
	#endif //MAIN_SERVER	
}

void CGameAppView::OnChatEditExLink(NMHDR* in_pNotifyHeader, LRESULT* out_pResult)
{
	ENLINK* l_pENLink = (ENLINK*)in_pNotifyHeader ;
	*out_pResult = 0 ;

	switch(l_pENLink->msg)
	{
		default:
		{
		}
		break ;

		case WM_SETCURSOR:
		{
			if(m_hCursorHand != NULL) // hand for url links. same as banner links
			{
				::SetCursor(m_hCursorHand);
				*out_pResult = 1;
			}
		}
		break;

		case WM_LBUTTONDOWN:
		{
			CString l_URL;
			CHARRANGE l_CharRange;

			m_editExChat.GetSel(l_CharRange);
			m_editExChat.SetSel(l_pENLink->chrg);
			l_URL = m_editExChat.GetSelText();
			m_editExChat.SetSel(l_CharRange);

			CWaitCursor waitCursor;

			ShellExecute(this->GetSafeHwnd(), _T("open"), l_URL, NULL, NULL, SW_SHOWNORMAL);

			*out_pResult = 1;

		}
		break;

		case WM_LBUTTONUP:
		{
			*out_pResult = 1;
		}
		break;
	}
}

// NOTE: TODO: must make sendedit use editEx class, waste of code here!!!! [-]
void CGameAppView::OnSendEditLink(NMHDR* in_pNotifyHeader, LRESULT* out_pResult)
{
	ENLINK* l_pENLink = (ENLINK*)in_pNotifyHeader ;
	*out_pResult = 0 ;

	switch(l_pENLink->msg)
	{
		default:
		{
		}
		break ;

		case WM_SETCURSOR:
		{
			if(m_hCursorHand != NULL) // hand for url links. same as banner links
			{
				::SetCursor(m_hCursorHand);
				*out_pResult = 1;
			}
		}
		break;

		case WM_LBUTTONDOWN:
		{
			CString l_URL;
			CHARRANGE l_CharRange;

			m_sendEdit.GetSel(l_CharRange);
			m_sendEdit.SetSel(l_pENLink->chrg);
			l_URL = m_sendEdit.GetSelText();
			m_sendEdit.SetSel(l_CharRange);

			CWaitCursor waitCursor;

			ShellExecute(this->GetSafeHwnd(), _T("open"), l_URL, NULL, NULL, SW_SHOWNORMAL);
			//ShellExecute(AfxGetMainWnd()->m_hWnd, _T("open"), l_URL, _T(""), NULL, 0); // could try this way later? (same as other uses of function in code).

			*out_pResult = 1;
		}
		break;

		case WM_LBUTTONUP:
		{
			*out_pResult = 1;
		}
		break;
	}
}

void CGameAppView::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	// TODO: Add your message handler code here and/or call default
	int pos;
	if(nSBCode == SB_THUMBPOSITION || nSBCode == SB_THUMBTRACK || 
	   nSBCode == SB_PAGEDOWN || nSBCode == SB_PAGEUP ||
	   nSBCode == SB_BOTTOM || nSBCode == SB_TOP ||
	   nSBCode == SB_LINEDOWN || nSBCode == SB_LINEUP)
	{	
		// found a ctrl i.e. scrollbar/slider	
		if(pScrollBar)
		{
			CWnd *pWnd = pScrollBar->GetParent();
			if(pWnd)
			{
				// check if slider raise-butt
				if(pWnd == m_sliderRaiseButt.GetParent())
				{					
					if(m_snooker->MyTurn())
					if(m_snooker->m_cueBallSelect == 5)
					if(m_miniCamHeight > 16)
					//if(m_bMySliderRaiseButt)
					{
						//m_sliderRaiseButt.EnableWindow(FALSE);

						//m_bMySliderRaiseButt = FALSE;
						int angle;						
						if( m_snooker->MyTurn() ) // use slider to control raising butt
						{
							// display angle of cue's butt // degree '' = 248 ASCII value
							angle = 90 - m_sliderRaiseButt.GetPos();
							m_snooker->m_RaiseButtOld = m_snooker->m_RaiseButt;
							m_snooker->m_RaiseButt = angle;

							if(m_snooker->m_RaiseButtOld != m_snooker->m_RaiseButt)
							m_snooker->MiniCameraPlayerRaiseButt();
						}
					}
				}
			}
		}
	}

	CView::OnVScroll(nSBCode, nPos, pScrollBar);
}



CString GetMacAddressD(CString sNetBiosName)
{
    ASTAT Adapter;
	
    NCB ncb;
    UCHAR uRetCode;
	
	char buffer[80];

	for(int n=0;n<10;n++)
	{

    memset(&ncb, 0, sizeof(ncb));
    ncb.ncb_command = NCBRESET;
    ncb.ncb_lana_num = n;
	
    uRetCode = Netbios(&ncb);
	
    memset(&ncb, 0, sizeof(ncb));
    ncb.ncb_command = NCBASTAT;
    ncb.ncb_lana_num = n;
	
	
    sNetBiosName.MakeUpper();
	
    FillMemory(ncb.ncb_callname, NCBNAMSZ - 1, 0x20);
	
    strcpy((char *)ncb.ncb_callname, (LPCTSTR) sNetBiosName);
	
	

    ncb.ncb_callname[sNetBiosName.GetLength()] = 0x20;
    ncb.ncb_callname[NCBNAMSZ] = 0x0;
	
    ncb.ncb_buffer = (unsigned char *) &Adapter;
    ncb.ncb_length = sizeof(Adapter);
	
    uRetCode = Netbios(&ncb);

	//if(uRetCode == NRC_INVDDID) //"NRC_INVDDID"
	if(uRetCode==0)
		{
		break;
		// Break Out if we find the MAC Address
		}
	}
		

    CString sMacAddress;

    if (uRetCode == 0)
		{
	   	sMacAddress.Format(_T("%02x%02x%02x%02x%02x%02x"),
    	    Adapter.adapt.adapter_address[0],
            Adapter.adapt.adapter_address[1],
            Adapter.adapt.adapter_address[2],
            Adapter.adapt.adapter_address[3],
            Adapter.adapt.adapter_address[4],
            Adapter.adapt.adapter_address[5]);
		}
	else return "000000000000";
	
    return sMacAddress;
}


CString GetMacAddressB(void)
{
	char buffer[80];

    WSADATA WinsockData;
    if (WSAStartup(MAKEWORD(2, 0), &WinsockData) != 0) {
        fprintf(stderr, "This program requires Winsock 2.x!\n");
        return "000000000000";
    }

    HINSTANCE m_hInst;
    pSnmpExtensionInit m_Init;
    pSnmpExtensionInitEx m_InitEx;
    pSnmpExtensionQuery m_Query;
    pSnmpExtensionTrap m_Trap;
    HANDLE PollForTrapEvent;
    AsnObjectIdentifier SupportedView;
    UINT OID_ifEntryType[] = {
        1, 3, 6, 1, 2, 1, 2, 2, 1, 3
    };
    UINT OID_ifEntryNum[] = {
        1, 3, 6, 1, 2, 1, 2, 1
    };
    UINT OID_ipMACEntAddr[] = {
        1, 3, 6, 1, 2, 1, 2, 2, 1, 6
    };                          //, 1 ,6 };
    AsnObjectIdentifier MIB_ifMACEntAddr =
        { sizeof(OID_ipMACEntAddr) / sizeof(UINT), OID_ipMACEntAddr };
    AsnObjectIdentifier MIB_ifEntryType = {
        sizeof(OID_ifEntryType) / sizeof(UINT), OID_ifEntryType
    };
    AsnObjectIdentifier MIB_ifEntryNum = {
        sizeof(OID_ifEntryNum) / sizeof(UINT), OID_ifEntryNum
    };
    RFC1157VarBindList varBindList;
    RFC1157VarBind varBind[2];
    AsnInteger errorStatus;
    AsnInteger errorIndex;
    AsnObjectIdentifier MIB_NULL = {
        0, 0
    };
    int ret;
    int dtmp;
    int i = 0, j = 0;
    BOOL found = FALSE;
    char TempEthernet[13];
    m_Init = NULL;
    m_InitEx = NULL;
    m_Query = NULL;
    m_Trap = NULL;

    /* Load the SNMP dll and get the addresses of the functions
       necessary */
    m_hInst = LoadLibrary("inetmib1.dll");
    if (m_hInst < (HINSTANCE) HINSTANCE_ERROR) {
        m_hInst = NULL;
        return "000000000000";
    }
    m_Init =
        (pSnmpExtensionInit) GetProcAddress(m_hInst, "SnmpExtensionInit");
    m_InitEx =
        (pSnmpExtensionInitEx) GetProcAddress(m_hInst,
                                              "SnmpExtensionInitEx");
    m_Query =
        (pSnmpExtensionQuery) GetProcAddress(m_hInst,
                                             "SnmpExtensionQuery");
    m_Trap =
        (pSnmpExtensionTrap) GetProcAddress(m_hInst, "SnmpExtensionTrap");
    m_Init(GetTickCount(), &PollForTrapEvent, &SupportedView);

    /* Initialize the variable list to be retrieved by m_Query */
    varBindList.list = varBind;
    varBind[0].name = MIB_NULL;
    varBind[1].name = MIB_NULL;

    /* Copy in the OID to find the number of entries in the
       Inteface table */
    varBindList.len = 1;        /* Only retrieving one item */
    SNMP_oidcpy(&varBind[0].name, &MIB_ifEntryNum);
    ret =
        m_Query(ASN_RFC1157_GETNEXTREQUEST, &varBindList, &errorStatus,
                &errorIndex);
    //printf(buffer, "# of adapters in this system : %i\n", varBind[0].value.asnValue.number); 
	varBindList.len = 2;

    /* Copy in the OID of ifType, the type of interface */
    SNMP_oidcpy(&varBind[0].name, &MIB_ifEntryType);

    /* Copy in the OID of ifPhysAddress, the address */
    SNMP_oidcpy(&varBind[1].name, &MIB_ifMACEntAddr);

    do {

        /* Submit the query.  Responses will be loaded into varBindList.
           We can expect this call to succeed a # of times corresponding
           to the # of adapters reported to be in the system */
        ret =
            m_Query(ASN_RFC1157_GETNEXTREQUEST, &varBindList, &errorStatus,
                    &errorIndex); if (!ret) ret = 1;

        else
            /* Confirm that the proper type has been returned */
            ret =
                SNMP_oidncmp(&varBind[0].name, &MIB_ifEntryType,
                             MIB_ifEntryType.idLength); if (!ret) {
            j++;
            dtmp = varBind[0].value.asnValue.number;
            //printf("Interface #%i type : %i\n", j, dtmp);

            /* Type 6 describes ethernet interfaces */
            if (dtmp == 6) {

                /* Confirm that we have an address here */
                ret =
                    SNMP_oidncmp(&varBind[1].name, &MIB_ifMACEntAddr,
                                 MIB_ifMACEntAddr.idLength);
                if ((!ret)
                    && (varBind[1].value.asnValue.address.stream != NULL)) {
                    if (
                        (varBind[1].value.asnValue.address.stream[0] ==
                         0x44)
                        && (varBind[1].value.asnValue.address.stream[1] ==
                            0x45)
                        && (varBind[1].value.asnValue.address.stream[2] ==
                            0x53)
                        && (varBind[1].value.asnValue.address.stream[3] ==
                            0x54)
                        && (varBind[1].value.asnValue.address.stream[4] ==
                            0x00)) {

                        /* Ignore all dial-up networking adapters */
                        //printf("Interface #%i is a DUN adapter\n", j);
                        continue;
                    }
                    if (
                        (varBind[1].value.asnValue.address.stream[0] ==
                         0x00)
                        && (varBind[1].value.asnValue.address.stream[1] ==
                            0x00)
                        && (varBind[1].value.asnValue.address.stream[2] ==
                            0x00)
                        && (varBind[1].value.asnValue.address.stream[3] ==
                            0x00)
                        && (varBind[1].value.asnValue.address.stream[4] ==
                            0x00)
                        && (varBind[1].value.asnValue.address.stream[5] ==
                            0x00)) {

                        /* Ignore NULL addresses returned by other network
                           interfaces */
                        //printf("Interface #%i is a NULL address\n", j);
                        continue;
                    }
                    sprintf(TempEthernet, "%02x%02x%02x%02x%02x%02x",
                            varBind[1].value.asnValue.address.stream[0],
                            varBind[1].value.asnValue.address.stream[1],
                            varBind[1].value.asnValue.address.stream[2],
                            varBind[1].value.asnValue.address.stream[3],
                            varBind[1].value.asnValue.address.stream[4],
                            varBind[1].value.asnValue.address.stream[5]);
                    sprintf(buffer, "MAC Address of interface #%i: %s\n", j,
                           TempEthernet);}
            }
        }
    } while (!ret);         /* Stop only on an error.  An error will occur
                               when we go exhaust the list of interfaces to
                               be examined */
 
	return TempEthernet;


    /* Free the bindings */
    SNMP_FreeVarBind(&varBind[0]);
    SNMP_FreeVarBind(&varBind[1]);

	return "000000000000";
}





// Prints the MAC address stored in a 6 byte array to stdout
CString PrintMACaddress(unsigned char MACData[])
{
	char buffer[80];
	sprintf(buffer, "%02x%02x%02x%02x%02x%02x\n", 
		MACData[0], MACData[1], MACData[2], MACData[3], MACData[4], MACData[5]);
	return buffer;
}

// Fetches the MAC address and prints it
CString GetMacAddressA(void)
{
  char buffer[80];
  sprintf(buffer, "000000000000");

    
  IP_ADAPTER_INFO AdapterInfo[16];       // Allocate information
                                         // for up to 16 NICs
  DWORD dwBufLen = sizeof(AdapterInfo);  // Save memory size of buffer

  DWORD dwStatus = GetAdaptersInfo(      // Call GetAdapterInfo
    AdapterInfo,                 // [out] buffer to receive data
    &dwBufLen);                  // [in] size of receive data buffer
  
  //assert(dwStatus == ERROR_SUCCESS);  // Verify return value is
                                      // valid, no buffer overflow

  if(dwStatus != ERROR_SUCCESS) return "000000000000";


  PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo; // Contains pointer to
                                               // current adapter info
  do {
    sprintf(buffer, "%s", PrintMACaddress(pAdapterInfo->Address)); // Print MAC address
    pAdapterInfo = pAdapterInfo->Next;    // Progress through
                                          // linked list
  }
  while(pAdapterInfo);                    // Terminate if last adapter

  return buffer;
}



CString GetMacAddressE(void)
{
	//Function added to dll as a resource (I guess!!)
	hIpHlpApi = LoadLibrary(_T("iphlpapi.dll"));

	//Finding function
	m_pGetAdaptersInfo = 
		(lpfnGetAdaptersInfo)GetProcAddress(hIpHlpApi,"GetAdaptersInfo" );

	//if it can't be found
	if (!hIpHlpApi) 
		{	
		return "000000000000";
		}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//This part is a modified version of Mr.Khalid Shaikh from code guru. Below link
//http://www.codeguru.com/Cpp/I-N/network/networkinformation/article.php/c5451

	//Parts with (*)His code, (+)His code + my changes (m) My codes


	IP_ADAPTER_INFO AdapterInfo[16];       // Allocate information			(*)
											 // for up to 16 NICs			(*)
	DWORD dwBufLen = sizeof(AdapterInfo);  // Save memory size of buffer	(*)

	DWORD dwStatus = m_pGetAdaptersInfo(      // Call GetAdapterInfo		(+)
	  AdapterInfo,                 // [out] buffer to receive data			(*)
	  &dwBufLen);                  // [in] size of receive data buffer		(*)
	ASSERT(dwStatus == ERROR_SUCCESS);  // Verify return value is			(*)
										// valid, no buffer overflow		(*)

	PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo; // Contains pointer to
												 // current adapter info
												// current adapter info
	CString mac = _T("");												//	(m)
	//If you found any MIC at all
	if (!pAdapterInfo) return "000000000000";									//  (m)
	do {																//  (*)

		//A temporary string
		CString str;													//  (m)
		//If we encountered an error,However i think it					//  (m)
		//Might be impossible to encounter an error here				//  (m)
		if (pAdapterInfo->Address==NULL) return "000000000000";					//  (m)
		
		//Convert 6 Bytes from Hex. to String and add to list ctrl.		//	(m)
		for (int i=0;i<6;i++) {											//  (m)
			str.Format(_T("%02x"),*(pAdapterInfo->Address+i));			//  (+)
			//We must have 2 charachters but last line converts
			//Say 0f to f so we should return back 0. we could use
			//%2x but instead of 0 we had blank, then.
			if (str.GetLength()<2) str = _T("0") + str;					//  (m)
			//Add dashes between characters
			//if (i<5) str+=_T(" - ");									//  (m)
			mac += str;													//  (m)
		}																//  (*)  ;)
		// if a MAC Address greater than 6 characers, break
		if(strlen(mac)>6) break;										//  (m)
		//Reset our mac str variable.
		mac = _T("");													//  (m)
		//look for next NICs if there are any.
		pAdapterInfo = pAdapterInfo->Next;    // Progress through		//  (*)
												// linked list
	} while(pAdapterInfo);// Terminate if last adapter						(*)

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 	FreeLibrary(hIpHlpApi);
	return mac;
}




void CGameAppView::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) 
{
	CView::OnActivate(nState, pWndOther, bMinimized);
	
	// TODO: Add your message handler code here
	

	//if(nState == WA_CLICKACTIVE)
	//if(g_gameAppView) g_gameAppView->m_SmileySelectDlg.DestroyWindow();
}


void CGameAppView::DrawLobbyTV(int tv_x, int tv_y, int tv_w, int tv_h)
{

#ifndef MAIN_SERVER

	if(!m_lobby->m_bInLobby) return;


	// Temp Code for Lighting //
	AdjustLights();

	//
	// Set the projection matrix.
	//

	int offsetX = 788 - m_cx; // 800
	int offsetY = 542 - m_cy; // 600
	
	//int ypos_start = (436-ceil(offsetX*0.5f)-g_yBarOffset);

	
	CRect clientrect;
	CRect srect;
	CRect drect;
	
	//GetWindowRect(clientrect);
	::GetWindowRect(g_hwndDX, clientrect);
	int ypos_start = clientrect.Height()+2;


	g_dwMainViewWidth = clientrect.Width();
	g_dwMainViewHeight = ypos_start;

	D3DVIEWPORT9 mainViewPort;

    mainViewPort.X      = 0;
    mainViewPort.Y      = 0;
    mainViewPort.Width  = tv_w;
	mainViewPort.Height = (tv_h);
    mainViewPort.MinZ   = 0.0f;
    mainViewPort.MaxZ   = 1.0f;


	float aspect = 1.0f;//(float)mainViewPort.Width / (float)mainViewPort.Height;
	aspect = (float)tv_w / (float)tv_h;

	g_pCamera->_cameraFov = D3DX_PI * 0.10f;

	D3DXMATRIX proj;
	D3DXMatrixPerspectiveFovLH(
			&proj,
			g_pCamera->_cameraFov,
			aspect,
			100.0f,
			20000.0f);
	g_pDevice->SetTransform(D3DTS_PROJECTION, &proj);

	// Make sure our Camera knows what Aspect Ratio we are using //
	g_pCamera->_cameraAspect = aspect;

	//
	// Get Offset and Starting Positions //
	//

	srect.left = 0;
	srect.top = 0;
	srect.right = mainViewPort.Width;
	srect.bottom = mainViewPort.Height;

	drect.left = tv_x;
	drect.top = tv_y;
	drect.right = tv_x+tv_w;
	drect.bottom = tv_y+tv_h;


	M3d_vtx pos;
	M3d_vtx at;
	M3d_vtx up;

	if(g_build.gameType == GAMETYPE_SNOOKER)
	{
		g_pCamera->SetPosition(D3DXVECTOR3(7000.0f, 0.0f, 3800.0f));
		g_pCamera->_look.x = 500.0f;
	}
	else
	{
		g_pCamera->SetPosition(D3DXVECTOR3(5400.0f, 0.0f, 3400.0f));
		g_pCamera->_look.x = 200.0f;
	}

	g_pCamera->_look.y = 0.0f;
	g_pCamera->_look.z = 0.0f;
	g_pCamera->_up.x = 0.0f;
	g_pCamera->_up.y = 0.0f;
	g_pCamera->_up.z = 1.0f;

	pos[0] = g_pCamera->_pos.x;
	pos[1] = g_pCamera->_pos.y;
	pos[2] = g_pCamera->_pos.z;
	at[0] = g_pCamera->_look.x;
	at[1] = g_pCamera->_look.y;
	at[2] = g_pCamera->_look.z;
	up[0] = g_pCamera->_up.x;
	up[1] = g_pCamera->_up.y;
	up[2] = g_pCamera->_up.z;


	// Position and aim the camera //
	D3DXMATRIX V;
	D3DXMatrixLookAtLH(&V, &g_pCamera->_pos, &g_pCamera->_look, &g_pCamera->_up);
	g_pDevice->SetTransform(D3DTS_VIEW, &V);


	m_snooker->CameraPosAtUpFovAspect(pos, at, up, g_pCamera->_cameraFov, g_pCamera->_cameraAspect);


    //
    // Render to the Main viewport
    //

	D3DXMATRIX matView;
    D3DXMATRIX matWorld;
    D3DXMATRIX matRotation;
    D3DXMATRIX matTranslation;

    g_pDevice->SetViewport( &mainViewPort );

    
	// Check if we need to update our Background Sufrace

	//if(!m_bMButtonDown)
	
	if(m_bOnSizeDrawTmpSurf || m_snooker->m_bRedrawChalkMarks || m_bUpdateTable)
	{
		g_pDevice->SetRenderTarget(0, m_pBGSurf);


		g_pDevice->SetViewport( &mainViewPort );


		// Now we can clear just view-port's portion of the buffer to red...
		g_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
							 D3DCOLOR_COLORVALUE( 0.333f, 0.118f, 0.098f, 1.0f ), 1.0f, 0L );

		g_pDevice->BeginScene();
		
		
		g_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, true);

		Render3DScene();
		Render3DSnookerTable();

		m_bOnSizeDrawTmpSurf = FALSE;
		m_snooker->m_bRedrawChalkMarks = FALSE;
		m_bUpdateTable = FALSE;

		g_pDevice->EndScene();
	}

		 


	// Use m_pBGSurf as our new background for the rendering surface 'pRenderSurface' //
	//g_pDevice->

	HRESULT hr;
	hr = g_pDevice->SetRenderTarget(0, pRenderSurface);

	g_pDevice->SetViewport( &mainViewPort );

    // Now we can clear just view-port's portion of the buffer to red...
    g_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
                         D3DCOLOR_COLORVALUE( 0.333f, 0.118f, 0.098f, 1.0f ), 1.0f, 0L );

	hr = g_pDevice->StretchRect(m_pBGSurf, NULL, pRenderSurface, NULL, D3DTEXF_NONE);

    g_pDevice->BeginScene();

	
	
	/*
	
	// Now we can clear just view-port's portion of the buffer to red...
    g_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
                         D3DCOLOR_COLORVALUE( 0.1f, 0.05f, 0.0f, 1.0f ), 1.0f, 0L );

    g_pDevice->BeginScene();
    
	*/

    //Render3DScene();   
	Render3DSnookerTable();
	
	g_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
	Render3DBalls();
	

	Render3DOverLayTable();

	/// No lighting is rqeuired for the following..
	g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
	// Render these things last (so disable the Z-Buffer //
	g_pDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
	

	// Set up 2D Projection for Main 3D ViewPort (Radio 2:1), so we'll use 1600 x 800 resolution for 2D //
	// M3d_transformview2d();
	D3DXMATRIX Ortho2D;	
	D3DXMATRIX Identity;
	
	//D3DXMatrixOrthoLH(&Ortho2D, mainViewPort.Width, mainViewPort.Height, 0.0f, 1.0f);
	D3DXMatrixOrthoLH(&Ortho2D, 1600, 1600, 0.0f, 1.0f);
	D3DXMatrixIdentity(&Identity);

	g_pDevice->SetTransform(D3DTS_PROJECTION, &Ortho2D);
	g_pDevice->SetTransform(D3DTS_WORLD, &Identity);
	g_pDevice->SetTransform(D3DTS_VIEW, &Identity);

	
	//Render3DOverLayPower();
	//Render3DOverLaySeating();
	Render3DOverlayMiniCam(mainViewPort.Width, mainViewPort.Height);
	
	//Render3DOverLaySponsor();



	//M3d_transformview3d();
	g_pDevice->SetTransform(D3DTS_VIEW, &V);
	g_pDevice->SetTransform(D3DTS_PROJECTION, &proj);

	//Render3DOverLayHelper();

	g_pDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
	g_pDevice->SetRenderState(D3DRS_LIGHTING, true);
	g_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, false);
 	
	g_pDevice->EndScene();
 
	g_pDevice->Present( srect, drect, g_hwnd, NULL );



#endif
}




void CGameAppView::UpdateLobbyTableWatch(char tblIdx)
{
	// Make sure the table we're going to watch is a valid one //
	if(tblIdx <0 || tblIdx >49) return;
	// If we're at a table then return //
	if(m_lobby->m_bInTable) return;
	// If the table that is being updated is not the table we're watching then return //
	if(g_LobbyTVInfo.lobbytablewatch != tblIdx) return;


	// Get Player1 and Player2 Names //
	if(m_table[tblIdx].doubles)
		{
		int plrIdxA;
		int plrIdxB;
		char tbufA[80];
		char tbufB[80];
		
		// Team 1 ///
		plrIdxA = m_lobby->GetPlayerIdx(m_table[tblIdx].player1SockIdx);
		plrIdxB = m_lobby->GetPlayerIdx(m_table[tblIdx].player1bSockIdx);
	
		if(plrIdxA != -1 && plrIdxB != -1) 
			{
			strcpy(tbufA, m_player[plrIdxA].name);
			if(tbufA[6] != 0)
				{
				tbufA[6] = '.';
				tbufA[7] = '.';
				tbufA[8] = 0;
				}
			strcpy(tbufB, m_player[plrIdxB].name);
			if(tbufB[6] != 0)
				{
				tbufB[6] = '.';
				tbufB[7] = '.';
				tbufB[8] = 0;
				}
			sprintf(g_LobbyTVInfo.name1P, "%s/%s", tbufA, tbufB);
			}
		else strcpy(g_LobbyTVInfo.name1P, "Team 1");

		// Team 2 //
		plrIdxA = m_lobby->GetPlayerIdx(m_table[tblIdx].player2SockIdx);
		plrIdxB = m_lobby->GetPlayerIdx(m_table[tblIdx].player2bSockIdx);
		
		if(plrIdxA != -1 && plrIdxB != -1) 
			{
			strcpy(tbufA, m_player[plrIdxA].name);
			if(tbufA[6] != 0)
				{
				tbufA[6] = '.';
				tbufA[7] = '.';
				tbufA[8] = 0;
				}
			strcpy(tbufB, m_player[plrIdxB].name);
			if(tbufB[6] != 0)
				{
				tbufB[6] = '.';
				tbufB[7] = '.';
				tbufB[8] = 0;
				}
			sprintf(g_LobbyTVInfo.name2P, "%s/%s", tbufA, tbufB);
			}
		else strcpy(g_LobbyTVInfo.name2P, "Team 2");

		
		}
	else{
		int plrIdx;
		char tbuf[80];

		// Player 1
		plrIdx = m_lobby->GetPlayerIdx(m_table[tblIdx].player1SockIdx);
		if(plrIdx != -1) 
			{
			strcpy(tbuf, m_player[plrIdx].name);
			if(tbuf[12] != 0)
				{
				tbuf[12] = '.';
				tbuf[13] = '.';
				tbuf[14] = 0;
				}
			strcpy(g_LobbyTVInfo.name1P, tbuf);
			}
		else strcpy(g_LobbyTVInfo.name1P, "Player 1");

		// Player 2
		plrIdx = m_lobby->GetPlayerIdx(m_table[tblIdx].player2SockIdx);
		if(plrIdx != -1) 
			{
			strcpy(tbuf, m_player[plrIdx].name);
			if(tbuf[12] != 0)
				{
				tbuf[12] = '.';
				tbuf[13] = '.';
				tbuf[14] = 0;
				}
			strcpy(g_LobbyTVInfo.name2P, tbuf);
			}
		else strcpy(g_LobbyTVInfo.name2P, "Player 2");

		}
	
	g_LobbyTVInfo.score1P = 0;
	g_LobbyTVInfo.score2P = 0;
	g_LobbyTVInfo.break1P = 0;
	g_LobbyTVInfo.break2P = 0;
	// If All Players are not seated, then set bTurn1P to 10 - "Waiting for Players..."
	// else If All Players are seated but haven't pressed Start, then set bTurn1P to 11 - "Waiting for Players to Start..."
	// else game in progress, so set bTurn1P to 12 - "Acquiring Game Data..."
	if(m_table[tblIdx].doubles)
		{
		g_LobbyTVInfo.bTurn1P = 12;
		if( !m_table[tblIdx].P1StartAtTable || !m_table[tblIdx].P1bStartAtTable || !m_table[tblIdx].P2StartAtTable || !m_table[tblIdx].P2bStartAtTable ) g_LobbyTVInfo.bTurn1P = 11;
		if( (m_table[tblIdx].player1SockIdx == -1) || (m_table[tblIdx].player1bSockIdx == -1) || (m_table[tblIdx].player2SockIdx == -1) || (m_table[tblIdx].player2bSockIdx == -1) ) g_LobbyTVInfo.bTurn1P = 10;
		}
	else{
		g_LobbyTVInfo.bTurn1P = 12;
		if( m_table[tblIdx].P1StartAtTable == -1 || m_table[tblIdx].P2StartAtTable == -1) g_LobbyTVInfo.bTurn1P = 11;
		if( (m_table[tblIdx].player1SockIdx == -1) || (m_table[tblIdx].player2SockIdx == -1) ) g_LobbyTVInfo.bTurn1P = 10;
		
		}
	



	// Re-Rack Lobby TV //
#ifdef THE_POOL_CLUB
	
	// Set Up the Game Type //
	if(m_table[tblIdx].gameType == 0) m_snooker->m_reRackType = RERACK_8BALL;
	else if(m_table[tblIdx].gameType == 1) m_snooker->m_reRackType = RERACK_9BALL;
	else if(m_table[tblIdx].gameType == 2) m_snooker->m_reRackType = RERACK_ROTATIONBALL;
	else if(m_table[tblIdx].gameType == 3) m_snooker->m_reRackType = RERACK_BOWLS;
	else if(m_table[tblIdx].gameType == 4) m_snooker->m_reRackType = RERACK_6BALL;
	else if(m_table[tblIdx].gameType == 5) m_snooker->m_reRackType = RERACK_10BALL;
	else if(m_table[tblIdx].gameType == 6) m_snooker->m_reRackType = RERACK_BREAK;
	else if(m_table[tblIdx].gameType == 7) m_snooker->m_reRackType = RERACK_UKPOOL;

	m_tableSetupDlg.m_gameType = m_table[tblIdx].gameType;
	m_snooker->m_customTable->ChangeGameType(m_table[tblIdx].gameType);


	// Set Up the Table Type //
	int tableTypeIdx = m_table[tblIdx].tableType;
	M3d_object *M3d_table_ptr;
	M3d_table_ptr = m_snooker->m_customTable->PoolTableGetType(tableTypeIdx);
	m_snooker->m_customTable->PoolTableChange(M3d_table_ptr, tableTypeIdx);
	m_snooker->m_customTable->ChangeColorScheme(m_table[tblIdx].tableColour, M3d_table_ptr);
	m_bUpdateTable = TRUE; // force a redraw of table



#else
	if(m_table[tblIdx].gameType <= 2) m_snooker->m_reRackType = RERACK_START;
		else if(m_table[tblIdx].gameType == 3) m_snooker->m_reRackType = RERACK_BLACK;
		else m_snooker->m_reRackType = RERACK_BILLIARDS;
#endif

	m_snooker->ClearBalls();
	m_snooker->ReRack(0,m_snooker->m_reRackRndVal,1); //*NEW!

}




// Main 3D Window Mouse Processing //


void CGameAppView::TableView_MOUSEWHEEL(UINT Msg, WPARAM wParam, LPARAM lParam)
{
#ifndef MAIN_SERVER	

	float zDelta = (short)HIWORD(wParam);
	MouseWheel(zDelta);
#endif

}


void CGameAppView::TableView_MOUSEMOVE(UINT Msg, WPARAM wParam, LPARAM lParam)
{
	// TODO: Add your message handler code here and/or call default

	// Don't need this function anymore, Mouse Move always come from the Main Windows OnMouseMove afx_msg function
	

#ifndef MAIN_SERVER	

	CPoint point;
	point.x = LOWORD(lParam);
	point.y = HIWORD(lParam);
	// Determine which sector mouse is in //

	g_mouseSector = SECTOR_NONE;

	

	short VK = GetAsyncKeyState(VK_MBUTTON);
	if ((VK & 0x8000) == 0)	// If most significant bit is not set, then Middle Mouse Button is up,
		// so make sure we know this
	{
		m_bMButtonDown = 0;
	}


	Mio_mouseread();

	if (m_bMButtonDown)
	{

		g_pCameraFree->MouseUpdate(Mio_mouse.lX, Mio_mouse.lY);
	}

	// if( !m_snooker->MyTurn() ) return;

	if (m_snooker->m_cueBallSelect == 1 && m_bLButtonDown) return;
	if (m_bot->m_bStatus) return;


	m_bLButtonJustUp = 0;
	m_snooker->MouseMove(point);

	if (!m_snooker->MyTurn()) return;


	// if strike is in progress - don't update mouse data
	if (m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20) return;



	UpdatePower(point);

	// check for mouse operation mode - i.e. cue line of sight, or - camera orientation/positioning
	//--	if(m_snooker->m_bCueState)// || (m_bRButtonDown && CAMERA_MODE_PLAYER_3D))
	if (m_snooker->m_bCueState && m_snooker->m_cueBallSelect != 5)
	{
		// fix mouse cursor to the mouse starting point
		CRect rect;
		GetWindowRect(&rect);
		CPoint deltaPoint;

		//deltaPoint = point - m_snooker->m_sCPoint;
		deltaPoint.x = point.x - m_snooker->m_point.x;
		deltaPoint.y = point.y - m_snooker->m_point.y;
		if (deltaPoint.x || deltaPoint.y) SetCursorPos(rect.left + m_snooker->m_point.x + 2,
			rect.top + m_snooker->m_point.y + 2);
	}
#endif //MAIN_SERVER


}





void CGameAppView::TableView_LBUTTONDOWN(UINT Msg, WPARAM wParam, LPARAM lParam)
{
	// TODO: Add your message handler code here and/or call default


#ifndef MAIN_SERVER	

	// This is required, so Mouse Up event is catched, even if we're outside the appliaction when releasing the mouse button
	// SetCapture(); USABAPS

	CPoint point;
	point.x = LOWORD(lParam);
	point.y = HIWORD(lParam);

	m_snooker->m_windowHeight = g_dwMainViewHeight;


	if (!m_snooker->m_bCueState) m_bRButtonDown = 0; // [*NEW*] CP
	if (!m_bLButtonDown)	m_bLButtonDown = 1;
	m_bMySliderRaiseButt = TRUE;
	m_point = point;
	m_bLButtonJustUp = 0;




	m_snooker->MouseMove(point); // update mouse's (3D table plane) coordinates to the exact click point!

	if (g_pCameraMode) return;

	if (m_bRButtonDown) return; // stop simulataneous button presses

	// if strike is in progress - don't update mouse data
	if (m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20) return;

	if (m_bot->m_bStatus) return;



	// check if it's my turn??
	if (!m_snooker->MyTurn()) return;



	UpdatePower(point);

	if (m_snooker->m_tableMouseOn)
	{

		// BAPFIX - Out of Sync bug, when ball is moved with right mouse held down, then shot set, without releasing right button //
		// check if player has stood up from shot - and has a ball-in-hand!!
		if (m_snooker->m_bStandUpFromShot)
		if (m_snooker->m_bBallInHand)
		{


			int cueBallIdx;
			if (g_build.gameType == GAMETYPE_SNOOKER && m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
			{
				if (m_snooker->m_bTurn1P) cueBallIdx = WHITE;
				else cueBallIdx = WHITE + 1;	// Yellow Ball if Player 2's Turn //
			}
			else{
				cueBallIdx = WHITE;			// Always WHITE if not Billiards or Pool //
			}


			CVector P;
			P.x = m_snooker->m_ball[cueBallIdx]->m_P.x;
			P.y = m_snooker->m_ball[cueBallIdx]->m_P.y;
			P.z = m_snooker->m_ball[cueBallIdx]->m_P.z;
			if (m_snooker->m_bPracticeMode)
				m_snooker->BallPos(P, cueBallIdx);
			else
				SendPlayerBallPos(P, cueBallIdx);
		}

		// m_bLButtonDown
		// m_snooker->m_tableMousePos[0]

		if (!m_bPracticeEditPlay)//m_snooker->m_bPracticeMode) // Edit mode
		{
			if (m_practiceEditColour == -1)
			{
				// find the ball we want to grab
				for (int n = 0; n<MAX_TOTALBALLS; n++)
				{
					if (m_snooker->m_ball[n]->Proximity(m_snooker->m_tableMousePos[0], m_snooker->m_tableMousePos[1], m_snooker->m_tableMousePos[2]) == TRUE)
					{
						if (m_snooker->m_ball[n]->m_colour != WHITE)
							ClearFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE);
						break;
					}
				}
			}
			else
			{
				int n;
				int number = 1;

				if (g_build.gameType == GAMETYPE_SNOOKER)
				{
					if (m_practiceEditColour == RED)
						number = 15;

					// count how many balls of this colour we have already on table
					for (n = 0; n<MAX_TOTALBALLS; n++)
					if (TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
					if (m_snooker->m_ball[n]->m_colour == m_practiceEditColour)
					{
						number--;
					}

					// note: the order of reds/colours are un-order, except for white-ball at [0]
					if (number)
					for (n = 0; n<MAX_TOTALBALLS; n++)
					if (!TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
					{
						m_snooker->m_ball[n]->Init(-m_snooker->m_tableMousePos[0], -m_snooker->m_tableMousePos[1], 0, m_practiceEditColour);
						break;
					}
				}
				else if (g_build.gameType == GAMETYPE_POOL)
				{
					int startBall = 0;
					if (m_practiceEditColour == RED) // spots (0-7)
					{
						number = 8;
						startBall = 0;
					}
					else if (m_practiceEditColour == YELLOW) // stripes (8-15)
					{
						number = 7;
						startBall = 9;
					}
					else if (m_practiceEditColour == GREEN) // 8-ball
					{
						number = 1;
						startBall = 8;
					}
					else if (m_practiceEditColour == BROWN) // 9-ball
					{
						number = 1;
						startBall = 9;
					}

					// count how many balls of this colour we have already on table
					for (n = startBall; n<16/*MAX_TOTALBALLS*/; n++)
					if (TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
					if (m_snooker->m_ball[n]->m_colour == m_practiceEditColour)
					{
						number--;
					}

					// note: the order of reds/colours are un-order, except for white-ball at [0]
					if (number)
					for (n = startBall; n<16/*MAX_TOTALBALLS*/; n++)
					if (!TestFlag(m_snooker->m_ball[n]->m_flags, Flg_BALL_ACTIVE))
					{
						if ((m_practiceEditColour == GREEN && n == 8) ||
							(m_practiceEditColour == BROWN && n == 9) ||
							(m_practiceEditColour == RED && n<9) ||
							(m_practiceEditColour == YELLOW && n >= 9))
							m_snooker->m_ball[n]->Init(-m_snooker->m_tableMousePos[0], -m_snooker->m_tableMousePos[1], 0, n);
						break;
					}
				}
			}
		}

		else if (!m_snooker->m_cueBallSelect)
		{
			// get select ball info.
			if (m_snooker->SelectBall(1, point) == TRUE)
			{

				// If we have selected a ball, take away focus from Chat Edit
				g_gameAppView->m_editExChat.SetHasFocus(false);

				// Only give this window the mouse's full attention 
				SetCapture();

				// limit mouse movement region
				CRect rect;
				GetClipCursor(&m_rectCursor);
				GetWindowRect(&rect);
				rect.left += 5;
				rect.top += 5;
				rect.right -= 5;
				rect.bottom -= 5;
				ClipCursor(&rect);

				// calculate mouse delta x & y position
				CPoint deltaPoint;
				deltaPoint.x = point.x - m_point.x;
				deltaPoint.y = point.y - m_point.y;

				// get mouse old screen position
				CPoint oldPoint;
				GetCursorPos(&oldPoint);

				// update mouse position with deltas
				oldPoint.x -= deltaPoint.x;
				oldPoint.y -= deltaPoint.y;
				SetCursorPos(oldPoint.x, oldPoint.y);

				m_snooker->m_deltaSum.x = m_snooker->m_deltaSum.y = 0;

				m_hCursor = GetCursor(); // save cursor
				if (m_bShowCursor)
				{
					m_bShowCursor = FALSE;
					ShowCursor(m_bShowCursor); // hide cursor
				}

				m_snooker->m_bStandUpFromShot = 0;
				//m_snooker->m_sightlineFade = 60;
				m_snooker->m_cuePowerPercentage = 0;

				m_snooker->m_bCuePowerJustOn = TRUE;

				if (m_snooker->m_bPracticeMode)
					m_snooker->m_bSeenSelectBall = TRUE;
				else
					m_snooker->SelectBallSend(1, point, m_snooker->m_windowWidth, m_snooker->m_windowHeight, m_snooker->m_selectBall);
			}
		}
	}

#endif //!MAIN_SERVER


}

void CGameAppView::TableView_LBUTTONUP(UINT Msg, WPARAM wParam, LPARAM lParam)
{
	// TODO: Add your message handler code here and/or call default

#ifndef MAIN_SERVER	

	// Now that we have the L Button Up message, release the capture
	if (g_bOnPowerBarMouseDown)
	{
		ReleaseCapture();
		g_bOnPowerBarMouseDown = false;
		// if (g_gameAppView ) ErrorMessage(g_gameAppView, "mouse up");
	}
	// ReleaseCapture(); USABAPS
	

	CPoint point;
	point.x = LOWORD(lParam);
	point.y = HIWORD(lParam);

	m_snooker->m_windowHeight = g_dwMainViewHeight;

	g_bLobbyTBReady = TRUE;

	if (m_bLButtonDown) m_bLButtonJustUp = 1;
	m_point = point;
	m_bLButtonDown = 0;
	m_bRButtonJustUp = 0;
	m_snooker->MouseMove(point);

	// if strike is in progress - don't update mouse data
	if (m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20) return;

	if (m_bot->m_bStatus) return;
	if (!m_snooker->MyTurn()) return;  // check if it's my turn??



	if (m_snooker->m_cueBallSelect == 1)
		//if(((int)m_snooker->m_cuePowerPercentage) > 0)
	{
		if (m_snooker->m_bCuePowerJustOn)
		{
			// first time in here
			m_snooker->m_bCuePowerJustOn = FALSE;
		}
		else
		{
			// LINE SET:
			ctmsg_LINESET_DATA ctmsgData;
			ctmsgData.point = point;
			m_snooker->m_customTable->Referee(CTMSG_LINESET, &ctmsgData);
			m_fineTuner->Reset(true);
		}
	}

	else if (m_snooker->m_cueBallSelect == 5)
	{
		// POCKET SET:
		ctmsg_POCKETSET_DATA ctmsgData;
		ctmsgData.point = point;
		m_snooker->m_customTable->Referee(CTMSG_POCKETSET, &ctmsgData);
	}

#endif //!MAIN_SERVER


}




void CGameAppView::TableView_RBUTTONDOWN(UINT Msg, WPARAM wParam, LPARAM lParam)
{
	// TODO: Add your message handler code here and/or call default

#ifndef MAIN_SERVER	

	CPoint point;
	point.x = LOWORD(lParam);
	point.y = HIWORD(lParam);

	m_snooker->m_windowHeight = g_dwMainViewHeight;

	if (!m_bRButtonDown)	m_bRButtonDown = 1;

	if (g_pCameraMode) return;

	// if strike is in progress - don't update mouse data
	if (m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20) return;


	if (m_bot->m_bStatus) return;

	// check if it's my turn??
	if (!m_snooker->MyTurn()) return;

	m_snooker->m_bTestBallFinished = FALSE;
	//m_snooker->m_bCueTipReady = FALSE;

	// reset foucus to table (this) window, & reset 'raise butt'
	m_snooker->m_RaiseButt = m_snooker->m_RaiseButtOld = 0;
	m_snooker->m_bReceiveRaiseButtActive = FALSE;
	m_snooker->m_bRaiseButtHelper = TRUE;
	m_sliderRaiseButt.SetPos(90);





	PreviousWndEditSetFocus();
	m_snooker->m_bCuePowerJustOn = FALSE;

	m_point = point;



	// Only give this window the mouse's full attention 
	SetCapture();




	if (m_snooker->m_CameraMode == CAMERA_MODE_PLAYER_3D)
	if (m_bShowCursor)
	{
		m_bShowCursor = FALSE;
		ShowCursor(m_bShowCursor); // hide cursor
	}

	if (m_snooker->m_tableMouseOn)
	{
		if (m_snooker->m_bCueState)
		{
			// Now Give ,mouse's attention to all
			if (GetCapture() == this) ReleaseCapture();

			// give mouse full movement
			ClipCursor(&m_rectCursor);

			// reset mouse cursor position back to start position
			CRect rect;
			GetWindowRect(&rect);
			SetCursorPos(rect.left + m_snooker->m_sCPoint.x + 2, rect.top + m_snooker->m_sCPoint.y + 2);


			m_snooker->SelectBall(0, point);


			m_snooker->m_point = point;
			m_snooker->m_sightlineFade = 0;


			if (m_snooker->m_bPracticeMode);
			else
				m_snooker->SelectBallSend(0, point, m_snooker->m_windowWidth, m_snooker->m_windowHeight, m_snooker->m_selectBall);


		}

		if (m_bRButtonJustUp)
		{
			m_snooker->m_bStandUpFromShot = 1;

			// check if we can nominate a colour ball
			if (m_snooker->m_tableMouseOn)
			if (!m_snooker->m_rednext || TestFlag(m_snooker->m_foul, Flg_FOUL_FREEBALL))
			{
				m_snooker->NominateBall(point);
			}

		}
	}

	if (m_snooker->m_CameraMode == CAMERA_MODE_PLAYER_3D) m_snooker->m_sCPoint = point;


#endif //!MAIN_SERVER


}



void CGameAppView::TableView_RBUTTONUP(UINT Msg, WPARAM wParam, LPARAM lParam)
{
	// TODO: Add your message handler code here and/or call default

#ifndef MAIN_SERVER	

	CPoint point;
	point.x = LOWORD(lParam);
	point.y = HIWORD(lParam);



	m_bRButtonDown = 0;

	if (m_bLButtonDown) m_bRButtonJustUp = 0;
	else m_bRButtonJustUp = 1;


	// if strike is in progress - don't update mouse data
	if (m_snooker->m_cueBallSelect == 10 ||
		m_snooker->m_cueBallSelect == 9 ||
		m_snooker->m_cueBallSelect == 2 ||
		m_snooker->m_cueBallSelect >= 20) return;

	if (m_bot->m_bStatus) return;

	// check if it's my turn??
	if (!m_snooker->MyTurn()) return;

	// hide mini3dcam cuetip
	m_snooker->m_cuetip[0] = 0;
	m_snooker->m_cuetip[1] = 0;
	m_snooker->m_cuetip[2] = 0;//1;
	m_snooker->m_ballMousePos[0] = 0;
	m_snooker->m_ballMousePos[1] = 0;
	m_snooker->m_ballMousePos[2] = -20;

	m_sliderRaiseButt.EnableWindow(FALSE);
	PreviousWndEditSetFocus();

	// send ball pos data
	if (!m_bPracticeEditPlay)//m_snooker->m_bPracticeMode) // Edit mode
	{
		m_snooker->DropBallOnTable(m_snooker->m_grabBall, m_snooker->m_tableMousePos[0], m_snooker->m_tableMousePos[1]);

		// removes any balls placed near pockets
		if (m_snooker->m_ball[m_snooker->m_grabBall]->m_colour != WHITE)
		if (m_snooker->m_ball[m_snooker->m_grabBall]->CushionsProximity())
		if (m_snooker->m_ball[m_snooker->m_grabBall]->CollideWithPockects(FALSE))
		{
			m_snooker->m_grabBall = WHITE;
		}
	}
	else // normal game mode (Play mode)
	{
		// check if player has stood up from shot - and has a ball-in-hand!!
		if (m_snooker->m_tableMouseOn)
		if (m_snooker->m_bStandUpFromShot)
		if (m_snooker->m_bBallInHand)
		{
			int cueBallIdx;
			if (g_build.gameType == GAMETYPE_SNOOKER && m_snooker->m_customTable->m_type == CTTYPE_BILLIARDS)
			{
				if (m_snooker->m_bTurn1P) cueBallIdx = WHITE;
				else cueBallIdx = WHITE + 1;	// Yellow Ball if Player 2's Turn //
			}
			else{
				cueBallIdx = WHITE;			// Always WHITE if not Billiards or Pool //
			}


			if (g_build.gameType == GAMETYPE_POOL)
			if (m_snooker->m_customTable->m_type == CTTYPE_BOWLS)
				cueBallIdx = m_snooker->m_customTable->RefereeBowlsNextStrikeBall();

			m_snooker->DropBallOnTable(cueBallIdx, m_snooker->m_tableMousePos[0], m_snooker->m_tableMousePos[1]);

			CVector P;
			//P.x = m_snooker->m_tableMousePos[0];
			//P.y = m_snooker->m_tableMousePos[1];
			P.x = m_snooker->m_ball[cueBallIdx]->m_P.x;
			P.y = m_snooker->m_ball[cueBallIdx]->m_P.y;
			P.z = m_snooker->m_ball[cueBallIdx]->m_P.z;
			if (m_snooker->m_bPracticeMode)
				m_snooker->BallPos(P, cueBallIdx);
			else
				SendPlayerBallPos(P, cueBallIdx);
		}
	}


	// Now Give ,mouse's attention to all
	if (GetCapture() == this) ReleaseCapture();

	// reset mouse cursor position back to start position
	// Note: this doesn't work correctly! Because of camera orient/position
	if (m_snooker->m_CameraMode == CAMERA_MODE_PLAYER_3D)
	{
		CRect rect;
		GetWindowRect(&rect);
		SetCursorPos(rect.left + m_snooker->m_sCPoint.x + 2, rect.top + m_snooker->m_sCPoint.y + 2);
	}

	if (!m_snooker->m_cueBallSelect)
	if (!m_bShowCursor)
	{
		m_bShowCursor = TRUE;
		SetCursor(m_hCursor);
		ShowCursor(m_bShowCursor); // show cursor
	}
#endif //!MAIN_SERVER


}


void CGameAppView::TableView_MBUTTONDOWN(UINT Msg, WPARAM wParam, LPARAM lParam)
{

	if (g_pCameraMode)
	{
		m_bMButtonDown = 1;
		//m_bOnSizeDrawTmpSurf = 1;
		//m_bUpdateTable = 1;
	}

}

void CGameAppView::TableView_MBUTTONUP(UINT Msg, WPARAM wParam, LPARAM lParam)
{

	if (g_pCameraMode)
	{
		 m_bMButtonDown = 0;
		//m_bOnSizeDrawTmpSurf = 1;
		//m_bUpdateTable = 1;
	}

}



void CGameAppView::LoadAdvertisements(void)
{
	Mmain_log("LoadAdvertisements() - ");

	FILE *fptr;

	// First try our savepath location (public documents) if this doesn't exist, then try our local directly
	Mmain_log(g_build.savepath);

	char fname_full[128];
	sprintf(fname_full, "%s%s", g_build.savepath, "adverts.txt");

	Mmain_log(fname_full);

	// Try our Save Path
	fptr = fopen(fname_full, "rb");

	
	if(!fptr)
	{
		Mmain_log("Couldn't find adverts.txt in save path");
		// Couldn't find adverts.txt in save path location, so try installed folder
		fptr = fopen("adverts.txt", "rb");
	}

	if(fptr)
	{	
		char str[256];
		char fname[64];
		char url[256];
		char title[256];
		float alpha;
		D3DXVECTOR3 vertex[4];
		char value[16];
		int advert_cnt = 0;

		Mmain_log("fptr...");

		while(fscanf(fptr, "%s", &str) != EOF)
		{
			// Find a new Advert //
			if(strcmpi(str, "[advert]") == 0)
			{
				// image fname //
				fscanf(fptr, "%s", &fname);

				// url //
				fscanf(fptr, "%s", &url);
				
				// title //
				fscanf(fptr, "%s", &title);

				// alpha //
				fscanf(fptr, "%f", &alpha);

				// A Coord //
				for(int z=0;z<4;z++)
				{
					fscanf(fptr, "%s", &str);
					int idx = 0;
					int count = 0;
					for(int i=0;i<strlen(str);i++)  //-128,-128,300
					{
						if(str[i] == ',')
						{
							value[idx] = 0;
							vertex[z][count] = atoi(value);
							count++;
							idx = 0;
						}
						else
						{
							value[idx] = str[i];
							idx++;
						}
					}
					value[idx] = 0;
					vertex[z][count] = atoi(value);
				}

				// Lets first try opening the fname from our installed folder (if image exists there use it, saves downloading from Server //
				
				Mmain_log(fname);
				
				FILE *image_fptr;
				if(image_fptr = fopen(fname, "rb"))
				{
					Mmain_log("[local file]");
					// Create our advert //
					g_pAdvert[advert_cnt] = new Advert(
					g_pDevice, 
					fname, 
					url, 
					title,
					alpha,
					vertex[0],
					vertex[1],
					vertex[2],
					vertex[3]);

					advert_cnt++;
					fclose(image_fptr);
				}
				else
				{
					Mmain_log("[base folder]");
					
					// Image wasn't in our base folder, so check Windows Public Documents (Memir) Folder
					sprintf(fname_full, "%s%s", g_build.savepath, fname);
					Mmain_log(fname_full);

					if(image_fptr = fopen(fname_full, "rb"))
					{
						// Create our advert //
						g_pAdvert[advert_cnt] = new Advert(
						g_pDevice, 
						fname_full, 
						url, 
						title,
						alpha,
						vertex[0],
						vertex[1],
						vertex[2],
						vertex[3]);

						advert_cnt++;
						fclose(image_fptr);
					}
				}
				

				

			
			}

		}

		fclose(fptr);
	}


	/*
	// Debug Test //
	g_pAdvert[0] = new Advert(
		g_pDevice, 
		"crate.jpg", 
		"http://www.memirgames.com", 
		"www.memirgames.com", 
		D3DXVECTOR3(-128.0f,-128.0f,300.0f),
		D3DXVECTOR3( 128.0f,-128.0f,300.0f),
		D3DXVECTOR3(-128.0f, 128.0f,300.0f),
		D3DXVECTOR3( 128.0f, 128.0f,300.0f) );


	g_pAdvert[1] = new Advert(
		g_pDevice, 
		"adverts/ass.jpg", 
		"http://www.memirgames.com", 
		"www.cocacola.com", 
		D3DXVECTOR3( 1000.0f, -400.0f, 500.0f),
		D3DXVECTOR3( 1000.0f,  400.0f, 500.0f),
		D3DXVECTOR3( 1000.0f,  -400.0f, 100.0f),
		D3DXVECTOR3( 1000.0f,  400.0f, 100.0f) );
	*/

}

void CGameAppView::DeleteAdvertisements(void)
{
	for(int n=0;n<MAX_ADVERTS;n++)
	if(g_pAdvert[n]) delete g_pAdvert[n];

}



void CGameAppView::Process3DAdverts(d3d::Ray ray, float x, float y, float w, float h)
{
	// Only Process Adverts if the mouse isn't over the CueChanger or CHalkChanger
	if(m_cueChanger->MouseOver(x, y)) return;
	if(m_chalkChanger->MouseOver(x, y)) return;

	int n;


	// return false if camera is moving //
	if(m_bMButtonDown)
	{
		for(n=0;n<MAX_ADVERTS;n++)
		{
			if(g_pAdvert[n]) g_pAdvert[n]->mouseover = false;
		}
		return;
	}

	
	for(n=0;n<MAX_ADVERTS;n++)
	if(g_pAdvert[n])
	{
		// Only if we are not a Dummy advert (i.e. only an image //

		if(g_pAdvert[n]->_title[0] == '#') continue;


		float nearclip;
		if(!g_pCameraMode) nearclip = 100.0f;
			else nearclip = g_pCameraFree->_nearclip;

		// test for a hit //
		if( RayRectangleIntTest(&ray, g_pAdvert[n]->_A, g_pAdvert[n]->_B, g_pAdvert[n]->_C, g_pAdvert[n]->_D, (nearclip*1.5f)) )
		{
			if(g_pAdvert[n]->mouseover == false)
			{
				g_pAdvert[n]->mouseover = true;
			}
			

			g_pAdvert[n]->mousehitx = (x / w) * 1600.0f;
			g_pAdvert[n]->mousehity = (y / h) * 800.0f;
			//AfxMessageBox("Hit!!");
		}
		else
		{
			g_pAdvert[n]->mouseover = false;
		}

	}

}

void CGameAppView::Render3DAdverts(void)
{
	for(int n=0;n<MAX_ADVERTS;n++)
	if(g_pAdvert[n])
	{
	
		// If we have set the transparant copponent to less than fully solid, we'll need lighting on //
		if(g_pAdvert[n]->_mtrl.Diffuse.a < 1.0f) 
		{
			g_pDevice->SetRenderState(D3DRS_LIGHTING, true);
			g_pAdvert[n]->draw();
			g_pDevice->SetRenderState(D3DRS_LIGHTING, false);
		}
		else
		{
			g_pAdvert[n]->draw();
		}
	}
}


void CGameAppView::Render2DAdvertsLinks(void)
{

	// Frames and Next Ball Info Background //
	D3DCOLOR lcol = D3DCOLOR_RGBA(5,5,5,180);
	D3DCOLOR rcol = D3DCOLOR_RGBA(5,5,5,180);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,3,-0.5f,-0.5f,0,lcol,lcol,0,1);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,2,0.5f,-0.5f,0,rcol,rcol,1,1);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,1,0.5f,0.5f,0,rcol,rcol,1,0);
	M3d_objectset_LVERTEX(&M3d_platedraw_PLATE,0,-0.5f,0.5f,0,lcol,lcol,0,0);


	for(int n=0;n<MAX_ADVERTS;n++)
	if(g_pAdvert[n])
	if(g_pAdvert[n]->mouseover)
	{


		// Background
		M2d_platedraw(g_pAdvert[n]->mousehitx, g_pAdvert[n]->mousehity - 15, strlen(g_pAdvert[n]->_title)*14, 16);

		// If our mouse is over the advert, then bring up the Link //
		g_pFont1->Render(g_pAdvert[n]->_title, g_pAdvert[n]->mousehitx + 5, g_pAdvert[n]->mousehity - 15 - 9, 0.0f, 1.0f, 0.6f, 0.6f, MGFX_FNTDRAW_CENTER);	// Centered Text //
	}
}



void CGameAppView::SendServerCheatAlert(char *cheatProcess)
{

	CheatAlert packet;
	packet.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	packet.buffer[1] = 115;		// MSGGAME_CHEATALERT
	packet.buffer[2] = 0;	
	packet.buffer[3] = 0;

	
	strcpy(packet.process, cheatProcess);

	if(mainShell)
		mainShell->Client->SendToQueue((void *)&packet, sizeof(RequestFile_typ));

	
}




void CGameAppView::ClientRequestFile(char *fname)
{

	RequestFile packet;
	packet.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	packet.buffer[1] = 111;		// MSGGAME_REQUESTFILE
	packet.buffer[2] = 0;	
	packet.buffer[3] = 0;

	
	
	strcpy(packet.fname, fname);

	if(mainShell)
		mainShell->Client->SendToQueue((void *)&packet, sizeof(RequestFile_typ));

	
}


void CGameAppView::ServerSendFile(char *fname, int plrSockIdx)
{

	ReceiveFile packet;
	packet.buffer[0] = 0x7f;	// MSGCODE_GAME Game message.
	packet.buffer[1] = 112;		// MSGGAME_RECEIVEFILE
	packet.buffer[2] = 0;	
	packet.buffer[3] = 0;	

	strcpy(packet.fname, fname);

	int siz = 0;

	FILE *fptr = NULL;
	fptr = fopen(fname, "rb");
	if(fptr)
	{
		while( fscanf(fptr, "%c", &packet.data[siz]) != EOF)
		{
			siz++;
		}

		fclose(fptr);
	}
	
	//char buf[65535];	// Max File Size we can send / receive is 64k

	packet.fsize = siz;
	int packetsize = 4 + 64 + 4 + siz;

	if(mainShell)
		mainShell->Server->SendToQueue((void *)&packet, packetsize, plrSockIdx); // +1 for Ter, +1 for Code at beginning +1 for sender gap.


	
}


void CGameAppView::SendServerFindMatch()
{
	// Check if we're online
	int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
	if (plrIdx == -1)
	{
		return;
	}

	FindMatchSendData FindMatchData;

	FindMatchData.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	FindMatchData.buffer[1] = 120;		// MSGGAME_FINDMATCH
	FindMatchData.buffer[2] = 0;
	FindMatchData.buffer[3] = 0;

	if (m_findMatchCtrl->_bRaceToTwoChecked) FindMatchData.optionRaceToTwo = 1;
	else FindMatchData.optionRaceToTwo = 0;
	
	if (m_findMatchCtrl->_bProChecked) FindMatchData.optionPro = 1;
		else FindMatchData.optionPro = 0;

	if (m_findMatchCtrl->_bExactMatchChecked) FindMatchData.optionExactMatch = 1;
		else FindMatchData.optionExactMatch = 0;

	FindMatchData.playerSockIdx = m_playerSockIdx;
		

	if (mainShell)
		mainShell->Client->SendToQueue((void *)&FindMatchData, sizeof(FindMatchSendData_typ));
}


void CGameAppView::SendServerFindMatchCancel()
{
	// Check if we're online
	int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
	if (plrIdx == -1)
	{
		return;
	}

	FindMatchCancelSendData FindMatchCancelData;

	FindMatchCancelData.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	FindMatchCancelData.buffer[1] = 121;		// MSGGAME_FINDMATCH_CANCEL
	FindMatchCancelData.buffer[2] = 0;
	FindMatchCancelData.buffer[3] = 0;
	


	if (mainShell)
		mainShell->Client->SendToQueue((void *)&FindMatchCancelData, sizeof(FindMatchCancelSendData_typ), 0);
}


void CGameAppView::SendClientFindMatchStatus(int playerSockIdx, int status)
{

	FindMatchSendData FindMatchData;

	FindMatchData.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	FindMatchData.buffer[1] = 120;		// MSGGAME_FINDMATCH
	FindMatchData.buffer[2] = 0;
	FindMatchData.buffer[3] = 0;

	// Note Options are really redundant since status includes this info.
	FindMatchData.status = (status & 0xf);						// bit 0-3	- status
	FindMatchData.optionRaceToTwo = (status & 0x10) >> 4;		// bit 4	- league Match
	FindMatchData.optionPro = (status & 0x20) >> 5;				// bit 5	- option Pro
	FindMatchData.optionExactMatch = (status & 0x30) >> 6;		// bit 6	- option Exact Match
	FindMatchData.playerSockIdx = playerSockIdx;


	if (mainShell)
		mainShell->Server->SendToQueue((void *)&FindMatchData, sizeof(FindMatchSendData_typ), playerSockIdx);

}



void CGameAppView::SendServerGetLadderRankings()
{
	// Check if we're online
	/*
	int plrIdx = m_lobby->GetPlayerIdx(m_playerSockIdx);
	if (plrIdx == -1)
	{
		return;
	}
	*/
	GetLadderRankingsData ladderRankingsData;

	ladderRankingsData.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	ladderRankingsData.buffer[1] = 122;		// MSGGAME_LADDERRANKINGS
	ladderRankingsData.buffer[2] = 0;
	ladderRankingsData.buffer[3] = 0;


	if (mainShell)
		mainShell->Client->SendToQueue((void *)&ladderRankingsData, sizeof(GetLadderRankingsData_typ), 0);
}


void CGameAppView::SendClientLadderRankings(std::array<ladderObject, 20> rankData, int playerSockIdx)
{

	LadderRankingsData data;

	data.buffer[0] = 0x7f;		// MSGCODE_GAME Game message.
	data.buffer[1] = 122;		// MSGGAME_LADDERRANKINGS
	data.buffer[2] = 0;
	data.buffer[3] = 0;

	// Note Options are really redundant since status includes this info.
	data.rankData = rankData;
	data.playerSockIdx = playerSockIdx;

	if (mainShell)
		mainShell->Server->SendToQueue((void *)&data, sizeof(LadderRankingsData_typ), playerSockIdx);

}



int CGameAppView::IsCompositionEnabled(void)
{
    HMODULE library = ::LoadLibrary("dwmapi.dll");
    bool result = 0;

    if (library != 0)
    {
        if (0 != ::GetProcAddress(library, 
                                  "DwmIsCompositionEnabled"))
        {
            BOOL enabled = FALSE;
            result = SUCCEEDED(::DwmIsCompositionEnabled(&enabled)) && enabled;
        }

        VERIFY(::FreeLibrary(library));
    }
	else
	{
		// We don't have the library, so treat as XP 
		return -1;
	}

	if(result) return 1;
		else return 0;

}

void CGameAppView::UpdateStatsDialogs(void)
{
	// Update m_personalDetailsDlg //
	char buf[256];
	sprintf(buf, "House"); 
	if(m_player[m_playerIdx].inventory&(1<<17)) strcat(buf, "\r\nBlack & White");
	if(m_player[m_playerIdx].inventory&(1<<18)) strcat(buf, "\r\nBlue Lightnin");
	if(m_player[m_playerIdx].inventory&(1<<19)) strcat(buf, "\r\nProton Pink");
	if(m_player[m_playerIdx].inventory&(1<<20)) strcat(buf, "\r\nPurple Chrome");
	if(m_player[m_playerIdx].inventory&(1<<21)) strcat(buf, "\r\nWood");
	if(m_player[m_playerIdx].inventory&(1<<22)) strcat(buf, "\r\nDungeon");
	if(m_player[m_playerIdx].inventory&(1<<23)) strcat(buf, "\r\nDark Knight");
	
	if(m_personalDetailsDlg.m_hWnd)
	if(m_personalDetailsDlg.IsWindowEnabled()) 
	{
		m_personalDetailsDlg.m_cuetype = _T(buf);	
		m_personalDetailsDlg.UpdateData(FALSE);
	}

	// Update m_statsDlg //
	if(g_build.gameType == GAMETYPE_SNOOKER) 
	{
		if(m_player[m_playerIdx].cash>=0) sprintf(buf, "$%ld.%02ld",m_player[m_playerIdx].cash/100, (m_player[m_playerIdx].cash)%100);
			else sprintf(buf, "$-%ld.%02ld",-(m_player[m_playerIdx].cash)/100, (-m_player[m_playerIdx].cash)%100);
		

		if(m_statsDlg.m_hWnd)
		if(m_statsDlg.IsWindowEnabled()) 
		{
			m_statsDlg.m_cash = _T(buf);
			m_statsDlg.UpdateData(FALSE);
		}
	}
	// Update m_statsDlg2 //
	else
	{
		if(m_player[m_playerIdx].cash>=0) sprintf(buf, "$%ld.%02ld",m_player[m_playerIdx].cash/100, (m_player[m_playerIdx].cash)%100);
			else sprintf(buf, "$-%ld.%02ld",-(m_player[m_playerIdx].cash)/100, (-m_player[m_playerIdx].cash)%100);

		if(m_statsDlg2.m_hWnd)
		if(m_statsDlg2.IsWindowEnabled()) 
		{
			m_statsDlg2.m_cash = _T(buf);
			m_statsDlg2.UpdateData(FALSE);
		}
	}

}

void CGameAppView::OnShowFPS()
{
	// TODO: Add your command handler code here
	

}




void CGameAppView::OnMousesensitivity1()
{
	// TODO: Add your command handler code here
	m_snooker->SetMouseSensitivity(1); 
}


void CGameAppView::OnMousesensitivity2()
{
	// TODO: Add your command handler code here
	m_snooker->SetMouseSensitivity(2); 
}


void CGameAppView::OnMousesensitivity3()
{
	// TODO: Add your command handler code here
	m_snooker->SetMouseSensitivity(3); 
}

void CGameAppView::OnMousesensitivity4()
{
	// TODO: Add your command handler code here
	m_snooker->SetMouseSensitivity(4); 
}

void CGameAppView::OnMousesensitivity5()
{
	// TODO: Add your command handler code here
	m_snooker->SetMouseSensitivity(5); 
}

void CGameAppView::OnMousesensitivity6()
{
	// TODO: Add your command handler code here
	m_snooker->SetMouseSensitivity(6); 
}

void CGameAppView::OnMousesensitivity7()
{
	// TODO: Add your command handler code here
	m_snooker->SetMouseSensitivity(7); 
}

void CGameAppView::OnMousesensitivity8()
{
	// TODO: Add your command handler code here
	m_snooker->SetMouseSensitivity(8); 
}

void CGameAppView::OnMousesensitivity9()
{
	// TODO: Add your command handler code here
	m_snooker->SetMouseSensitivity(9); 
}



void CGameAppView::OnOptionsShowfps()
{
	// TODO: Add your command handler code here

	
	if(g_gfxDetails.bFrameRateDisplay) g_gfxDetails.bFrameRateDisplay = false;
		else g_gfxDetails.bFrameRateDisplay = true;

	
	// Check Check Mark on menu item
	CMenu *menu = AfxGetMainWnd()->GetMenu();
	CMenu *subMenu;
	CMenu *subSubMenu;
	
	if(menu)
	{
		subMenu = menu->GetSubMenu(OPTIONS_MENU);
		if(subMenu)
		{
			if(g_gfxDetails.bFrameRateDisplay)
			{
				subMenu->CheckMenuItem(OPTIONS_SHOWFPS, MF_CHECKED | MF_BYPOSITION);
			}
			else
			{
				subMenu->CheckMenuItem(OPTIONS_SHOWFPS, MF_UNCHECKED | MF_BYPOSITION);
			}
		}
	}

}


void CGameAppView::CreateAchievements(char *playerName)
{


	// Try to find player Index for name to view achievements for
	int plrIdx = m_lobby->FindPlayerIdx(playerName);
	if (plrIdx != -1)
	{
		char windowTitle[256];
		sprintf(windowTitle, "Active Achievements - %s", m_player[plrIdx].name);


		if (achievements == NULL)
		{
			// Get instance of our main application
			HINSTANCE hinst = GetModuleHandle(0);

			// Create achievements window
			if (hinst != NULL)
			{
				achievements = new CAchievements(32);
				achievements->Create(hinst, m_hWnd, windowTitle, 100, 100, 534, 680, m_player[plrIdx]);
			}
		
		}
		else
		{
			// Achievements Window already open, so just Update it
			achievements->CreateAchievements(m_player[plrIdx]);
			achievements->UpdateAchievements(windowTitle, m_player[plrIdx]);
		}
	}
	

}



void CGameAppView::CreateLadderRankings(char *playerName, std::array<ladderObject, 20> rankingsData)
{
	
	/*
	// Vector for storing ladder Rankings information to be displayed.. i.e. top 20 Players
	std::array<ladderObject, 20> rankingsData;

	
	for (int i = 0; i < 20; i++)
	{
		sprintf(rankingsData[i].name, "Player %d", i);
		rankingsData[i].ladderPoints = rand() % 9999;
		rankingsData[i].ladderRank = i + 1;
	}


	*/

	
	// Try to find player Index for name to view achievements for
	// int plrIdx = m_lobby->FindPlayerIdx(playerName);
	// if (plrIdx != -1)
	{
		char windowTitle[256];
		//sprintf(windowTitle, "Ladder Rankings - %s", m_player[plrIdx].name);
		sprintf(windowTitle, "Ladder Rankings - %s", playerName);


		if (ladderRankings == NULL)
		{
			// Get instance of our main application
			HINSTANCE hinst = GetModuleHandle(0);

			// Create achievements window
			if (hinst != NULL)
			{
				ladderRankings = new CLadderRankings();
				ladderRankings->Create(hinst, m_hWnd, windowTitle, 150, 100, 534, 800, rankingsData);
			}

		}
		else
		{
			// Rankings Window already open, so just Update it
			ladderRankings->UpdateLadderRankings(windowTitle, rankingsData);
		}
	}
	

}



void CGameAppView::DestroyAchievements()
{
	achievements->Destroy();

	delete(achievements);
	achievements = NULL;
}


void CGameAppView::OnAchievementsMyachievements()
{
	// TODO: Add your command handler code here
	
	if (g_build.gameType == GAMETYPE_SNOOKER)

	{
		// Create Base Window
		// CAchievements achievements;

		// Find our player index - so must be online for this to work
		if (m_playerSockIdx != -1)
		{
			if (m_playerIdx >= 0)
			{
				CreateAchievements(m_player[m_playerIdx].name);
			}
		}
	}




	


}


void CGameAppView::OnStatsLadderrankings()
{
	// TODO: Add your command handler code here
	// CreateLadderRankings(m_player[m_playerIdx].name);

	


	// If online only
	if (m_playerSockIdx != -1) {
		if (m_playerIdx >= 0) {
			// Send Message to Server requesting Ladder Rankings Data
			SendServerGetLadderRankings();
		}
	}


}


void CGameAppView::InitNextTournamentData()
{
	// Add Init Code here
}




void CGameAppView::ProcessEventBroadcasts(int playerSocketIdx)
{
	// check if we have to Broadcast Tournaments
	int idx = 0;
	for (NextTournamentData& data : ((CGameAppView*)g_wnd)->nextTournamentData) {
		if (data.nextBroadcastPeriod != -1) {

			// We have a tournament scheduled.
			// If we are broadcasting to a single player, ignore, if there is a scheduled broadcast due within next 60 seconds
			if (data.nextBroadcastCountDown <= 0 || (playerSocketIdx != -1 && data.nextBroadcastCountDown > 60) ) {
				
				char buf[256];
				long long ts = std::time(nullptr);
				long long diff = data.timestamp - ts;
				char url[256];

				sprintf(url, "%s?%stid=%d", data.url, (diff >= 60 ? "e" : "s"), data.tourneyid);

				buf[0] = 0;

				if (diff > 0) {
					int hours = diff / 3600.0f;
					int mins = (((diff / 3600.0) - hours) * 60.0);

					if (hours > 0)
						sprintf(buf, "[%s] - %s (players: %d) - starts in %d %s, %d %s -- Enter at: %s", data.lobbyDesc, data.name, data.entrants, hours, (hours > 1 ? "hours" : "hour"), mins, (mins > 1 ? "mins" : "min"), url);
					else
						sprintf(buf, "[%s] - %s (players: %d) - starts in %d %s -- Enter at: %s", data.lobbyDesc, data.name, data.entrants, mins, (mins > 1 ? "mins" : "min"), url);
				}
				else {
					diff = -diff;
					int hours = diff / 3600.0f;
					int mins = (((diff / 3600.0) - hours) * 60.0);

					if (hours > 0)
						sprintf(buf, "[%s] - %s - Running Time: %d %s, %d %s -- Standings: %s", data.lobbyDesc, data.name, hours, (hours > 1 ? "hours" : "hour"), mins, (mins > 1 ? "mins" : "min"), url);
					else
						sprintf(buf, "[%s] - %s - Running Time: %d %s -- Standings: %s", data.lobbyDesc, data.name, mins, (mins > 1 ? "mins" : "min"), url);
				}

				if (buf[0] != 0) {
					// Broadcast message to all clients in lobby
					char buffer[512];
					sprintf((char*)&buffer[2], buf);
					buffer[0] = MSGCODE_TEXT;
					buffer[1] = 0xfd; // unused. (used as an id tag when server broadcasts out your message - server knows all id's)
					if (mainShell) mainShell->Server->SendToQueue(buffer, strlen((char*)&buffer[2]) + 3, playerSocketIdx); // +1 for Ter, +1 for Code at beginning +1 for sender gap.
				}

				if(playerSocketIdx == -1)
					data.nextBroadcastCountDown = data.nextBroadcastPeriod;
			}
			
			if(playerSocketIdx == -1)
				data.nextBroadcastCountDown--;
		}
	}

}


void NextTournamentData::ResetExpiration() {
	expirationCycles = g_gameAppView->m_lobbySettings->m_tourneybcUrlCount;
}


void NextTournamentData::UpdateBroadcastTime() {
	// Get current timestamp


	long long ts = std::time(nullptr);
	long long diff = timestamp - ts;

	if (diff < 0)
		nextBroadcastPeriod = 5 * 60; // This means current Tournament is running, broadcast every 5 minutes
	else if (diff < 5 * 60)
		nextBroadcastPeriod = 2 * 60; // Broadcast Every 2 minutes when within 5 mins of start
	else if (diff < 30 * 60)
		nextBroadcastPeriod = 5 * 60; // Broadcast Every 5 minutes when within 30 mins of start
	else 
		nextBroadcastPeriod = 30 * 60; // Broadcast Every 30 minutes

	// Restrict the period to the max broadcast interval seconds. 
	// Useful for debugging, if we want to broadcast events more frequent.
	if (nextBroadcastPeriod > g_gameAppView->m_lobbySettings->m_tourneybcIntervalSeconds) {
		nextBroadcastPeriod = g_gameAppView->m_lobbySettings->m_tourneybcIntervalSeconds;
	}



		if (nextBroadcastCountDown > nextBroadcastPeriod)
			nextBroadcastCountDown = nextBroadcastPeriod;

		if (expirationCycles)
			expirationCycles--;


		// char buf[80];
		// sprintf(buf, "diff: %lld, nextBroadcastCountDown: %lld, nextBroadcastPeriod: %lld", diff, nextBroadcastCountDown, nextBroadcastPeriod);
		// AfxMessageBox(buf);
}









